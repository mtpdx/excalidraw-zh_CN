{"version":3,"sources":["data/encode.ts","data/image.ts"],"names":["toByteString","data","Promise","resolve","reject","blob","Blob","TextEncoder","encode","reader","FileReader","onload","event","target","result","Error","readAsBinaryString","byteStringToArrayBuffer","byteString","buffer","ArrayBuffer","length","bufferView","Uint8Array","i","len","charCodeAt","byteStringToString","TextDecoder","decode","async","text","compress","deflated","deflate","error","console","version","encoding","compressed","encoded","decoded","inflate","to","blobToArrayBuffer","arrayBuffer","readAsArrayBuffer","getTEXtChunk","metadataChunk","decodePng","find","chunk","name","tEXt","encodePngMetadata","metadata","chunks","MIME_TYPES","excalidraw","JSON","stringify","splice","encodePng","type","decodePngMetadata","keyword","encodedData","parse","encodeSvgMetadata","base64","str","isByteString","btoa","stringToBase64","decodeSvgMetadata","svg","includes","match","versionMatch","json","atob","base64ToString"],"mappings":"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","file":"static/js/image.7c954eb1.chunk.js","sourcesContent":["import { deflate, inflate } from \"pako\";\n\n// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n\n// fast, Buffer-compatible implem\nexport const toByteString = (data: string | Uint8Array): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const blob =\n      typeof data === \"string\"\n        ? new Blob([new TextEncoder().encode(data)])\n        : new Blob([data]);\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target || typeof event.target.result !== \"string\") {\n        return reject(new Error(\"couldn't convert to byte string\"));\n      }\n      resolve(event.target.result);\n    };\n    reader.readAsBinaryString(blob);\n  });\n};\n\nconst byteStringToArrayBuffer = (byteString: string) => {\n  const buffer = new ArrayBuffer(byteString.length);\n  const bufferView = new Uint8Array(buffer);\n  for (let i = 0, len = byteString.length; i < len; i++) {\n    bufferView[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n};\n\nconst byteStringToString = (byteString: string) => {\n  return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n};\n\n// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\nexport const stringToBase64 = async (str: string, isByteString = false) => {\n  return isByteString ? btoa(str) : btoa(await toByteString(str));\n};\n\n// async to align with stringToBase64\nexport const base64ToString = async (base64: string, isByteString = false) => {\n  return isByteString ? atob(base64) : byteStringToString(atob(base64));\n};\n\n// -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n\ntype EncodedData = {\n  encoded: string;\n  encoding: \"bstring\";\n  /** whether text is compressed (zlib) */\n  compressed: boolean;\n  /** version for potential migration purposes */\n  version?: string;\n};\n\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nexport const encode = async ({\n  text,\n  compress,\n}: {\n  text: string;\n  /** defaults to `true`. If compression fails, falls back to bstring alone. */\n  compress?: boolean;\n}): Promise<EncodedData> => {\n  let deflated!: string;\n  if (compress !== false) {\n    try {\n      deflated = await toByteString(deflate(text));\n    } catch (error) {\n      console.error(\"encode: cannot deflate\", error);\n    }\n  }\n  return {\n    version: \"1\",\n    encoding: \"bstring\",\n    compressed: !!deflated,\n    encoded: deflated || (await toByteString(text)),\n  };\n};\n\nexport const decode = async (data: EncodedData): Promise<string> => {\n  let decoded: string;\n\n  switch (data.encoding) {\n    case \"bstring\":\n      // if compressed, do not double decode the bstring\n      decoded = data.compressed\n        ? data.encoded\n        : await byteStringToString(data.encoded);\n      break;\n    default:\n      throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n  }\n\n  if (data.compressed) {\n    return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n      to: \"string\",\n    });\n  }\n\n  return decoded;\n};\n","import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { MIME_TYPES } from \"../constants\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nconst blobToArrayBuffer = (blob: Blob): Promise<ArrayBuffer> => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  }\n  // Safari\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target?.result) {\n        return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\n      }\n      resolve(event.target.result as ArrayBuffer);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n};\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.excalidraw,\n    JSON.stringify(\n      await encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: \"image/png\" });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({ text }: { text: string }) => {\n  const base64 = await stringToBase64(\n    JSON.stringify(await encode({ text })),\n    true /* is already byte string */,\n  );\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\n\nexport const decodeSvgMetadata = async ({ svg }: { svg: string }) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = versionMatch?.[1] || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\"type\" in encodedData && encodedData.type === \"excalidraw\") {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n"],"sourceRoot":""}