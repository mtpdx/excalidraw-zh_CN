{"version":3,"sources":["constants.ts","analytics.ts","locales lazy /^/.//.*/.json$/ groupOptions: {} namespace object","css/variables.module.scss","i18n.ts","colors.ts","keys.ts","utils.ts","appState.ts","hooks/useCallbackRefState.ts","is-mobile.tsx","components/icons.tsx","components/Island.tsx","components/Modal.tsx","components/Dialog.tsx","components/ErrorDialog.tsx","components/TopErrorBoundary.tsx","components/LoadingMessage.tsx","components/InitializeApp.tsx","element/typeChecks.ts","math.ts","points.ts","element/bounds.ts","renderer/renderElement.ts","scene/Scene.ts","random.ts","element/mutateElement.ts","element/sizeHelpers.ts","groups.ts","element/newElement.ts","element/transformHandles.ts","ga.ts","galines.ts","gapoints.ts","gadirections.ts","gatransforms.ts","element/collision.ts","element/resizeTest.ts","element/linearElementEditor.ts","element/binding.ts","element/resizeElements.ts","element/dragElements.ts","element/textWysiwyg.tsx","element/textElement.ts","element/showSelectedShapeActions.ts","element/index.ts","scene/scrollbars.ts","scene/selection.ts","scene/scroll.ts","scene/comparisons.ts","scene/zoom.ts","components/ToolButton.tsx","actions/register.ts","actions/actionDeleteSelected.tsx","zindex.ts","actions/actionZindex.tsx","actions/actionSelectAll.ts","actions/actionDuplicateSelection.tsx","components/ButtonIconSelect.tsx","components/ButtonSelect.tsx","components/Popover.tsx","components/ColorPicker.tsx","components/IconPicker.tsx","actions/actionProperties.tsx","actions/actionCanvas.tsx","actions/actionFinalize.tsx","components/ProjectName.tsx","components/Tooltip.tsx","renderer/roundRect.ts","clients.ts","excalidraw-app/collab/types.ts","renderer/renderScene.ts","scene/export.ts","charts.ts","errors.ts","data/restore.ts","data/blob.ts","clipboard.ts","data/library.ts","data/json.ts","data/index.ts","actions/actionExport.tsx","actions/actionStyles.ts","components/HelpIcon.tsx","actions/actionGroup.tsx","actions/actionMenu.tsx","components/Avatar.tsx","actions/actionAddToLibrary.ts","actions/actionNavigate.tsx","align.ts","actions/actionAlign.tsx","disitrubte.ts","actions/actionDistribute.tsx","actions/actionClipboard.tsx","actions/actionToggleGridMode.tsx","actions/actionToggleZenMode.tsx","actions/actionToggleStats.tsx","actions/actionHistory.tsx","actions/manager.tsx","gesture.ts","history.ts","shapes.tsx","actions/shortcuts.ts","components/ContextMenu.tsx","components/Stack.tsx","components/Actions.tsx","components/DarkModeToggle.tsx","components/BackgroundPickerAndDarkModeToggle.tsx","components/CollabButton.tsx","components/ExportDialog.tsx","components/FixedSideContainer.tsx","components/GitHubCorner.tsx","components/HintViewer.tsx","components/LibraryUnit.tsx","components/LockIcon.tsx","components/Section.tsx","components/UserList.tsx","components/MobileMenu.tsx","components/PasteChartDialog.tsx","components/HelpDialog.tsx","components/LayerUI.tsx","excalidraw-app/data/localStorage.ts","components/Stats.tsx","components/Toast.tsx","actions/actionToggleViewMode.tsx","components/App.tsx","packages/excalidraw/index.tsx","excalidraw-app/app_constants.ts","excalidraw-app/data/index.ts","excalidraw-app/data/firebase.ts","excalidraw-app/collab/Portal.tsx","excalidraw-app/collab/RoomDialog.tsx","createInverseContext.tsx","excalidraw-app/collab/CollabWrapper.tsx","excalidraw-app/components/LanguageList.tsx","excalidraw-app/index.tsx","serviceWorker.tsx","excalidraw-app/pwa.ts","excalidraw-app/sentry.ts","index.tsx"],"names":["APP_NAME","DRAGGING_THRESHOLD","LINE_CONFIRM_THRESHOLD","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","TEXT_TO_CENTER_SNAP_THRESHOLD","SHIFT_LOCKING_ANGLE","Math","PI","CURSOR_TYPE","TEXT","CROSSHAIR","GRABBING","POINTER","MOVE","AUTO","POINTER_BUTTON","MAIN","WHEEL","SECONDARY","TOUCH","EVENT","ENV","TEST","DEVELOPMENT","CLASSES","SHAPE_ACTIONS_MENU","FONT_FAMILY","1","2","3","4","WINDOWS_EMOJI_FALLBACK_FONT","DEFAULT_FONT_SIZE","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","DEFAULT_VERSION","GRID_SIZE","MIME_TYPES","excalidraw","excalidrawlib","STORAGE_KEYS","LOCAL_STORAGE_LIBRARY","TAP_TWICE_TIMEOUT","TOUCH_CTX_MENU_TIMEOUT","TITLE_TIMEOUT","TOAST_TIMEOUT","VERSION_TIMEOUT","ZOOM_STEP","IDLE_THRESHOLD","ACTIVE_THRESHOLD","trackEvent","process","REACT_APP_GOOGLE_ANALYTICS_ID","window","gtag","category","name","label","value","event_category","event_label","JEST_WORKER_ID","map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","all","slice","t","keys","Object","module","exports","defaultLang","languages","rtl","concat","sort","left","right","filter","lang","percentages","currentLang","currentLangData","getLanguage","findPartsForData","data","parts","index","length","part","undefined","path","replacement","split","translation","fallbackLangData","key","replace","shades","oc","red","pink","grape","violet","indigo","blue","cyan","teal","green","lime","yellow","orange","canvasBackground","white","gray","elementBackground","elementStroke","black","isDarwin","test","navigator","platform","isWindows","CODES","KEYS","isArrowKey","getResizeCenterPointKey","event","altKey","getResizeWithSidesSameLengthKey","shiftKey","getRotateWithDiscreteAngleKey","SVG_NS","mockDateTime","getDateTime","date","Date","year","getFullYear","month","getMonth","padStart","day","getDate","hr","getHours","min","getMinutes","capitalizeString","str","charAt","toUpperCase","isWritableElement","target","HTMLElement","dataset","type","HTMLBRElement","HTMLTextAreaElement","HTMLInputElement","getFontFamilyString","fontFamily","getFontString","fontSize","measureText","text","font","line","document","createElement","body","style","position","whiteSpace","appendChild","innerText","x","join","width","offsetWidth","height","offsetHeight","span","display","overflow","baseline","offsetTop","removeChild","debounce","fn","timeout","lastArgs","handle","ret","args","clearTimeout","setTimeout","flush","cancel","distance","y","abs","resetCursor","documentElement","cursor","setCursorForShape","shape","isFullScreen","fullscreenElement","nodeName","getShortcutKey","shortcut","viewportCoordsToSceneCoords","clientX","clientY","zoom","offsetLeft","scrollX","scrollY","invScale","sceneCoordsToViewportCoords","sceneX","sceneY","getGlobalCSSVariable","getComputedStyle","getPropertyValue","RE_RTL_CHECK","RegExp","isRTL","tupleToCoors","xyTuple","muteFSAbortError","error","resolvablePromise","reject","promise","_resolve","_reject","withBatchedUpdates","func","unstable_batchedUpdates","nFormatter","num","digits","si","symbol","toFixed","getVersion","querySelector","content","getDefaultAppState","appearance","collaborators","Map","currentChartType","currentItemBackgroundColor","currentItemEndArrowhead","currentItemFillStyle","currentItemFontFamily","currentItemFontSize","currentItemLinearStrokeSharpness","currentItemOpacity","currentItemRoughness","currentItemStartArrowhead","currentItemStrokeColor","currentItemStrokeSharpness","currentItemStrokeStyle","currentItemStrokeWidth","currentItemTextAlign","cursorButton","draggingElement","editingElement","editingGroupId","editingLinearElement","elementLocked","elementType","errorMessage","exportBackground","exportEmbedScene","fileHandle","gridSize","innerHeight","isBindingEnabled","isLibraryOpen","isLoading","isResizing","isRotating","lastPointerDownWith","multiElement","openMenu","pasteDialog","shown","previousSelectedElementIds","resizingElement","scrolledOutside","selectedElementIds","selectedGroupIds","selectionElement","shouldAddWatermark","shouldCacheIgnoreZoom","showHelpDialog","showStats","startBoundElement","suggestedBindings","toastMessage","viewBackgroundColor","innerWidth","zenModeEnabled","viewModeEnabled","APP_STATE_STORAGE_CONF","browser","export","_clearAppStateForStorage","appState","exportType","stateForExport","propConfig","clearAppStateForLocalStorage","cleanAppStateForExport","useCallbackRefState","refValue","setRefValue","useState","useCallback","context","React","createContext","getIsMobileMatcher","matchMedia","variables","isMobileQuery","matches","addListener","removeListener","IsMobileProvider","children","query","useRef","current","isMobile","setMobile","useEffect","handler","Provider","useIsMobile","useContext","activeElementColor","iconFillColor","handlerColor","createIcon","d","opts","mirror","aria-hidden","focusable","role","viewBox","className","clsx","fill","link","save","saveAs","load","clipboard","trash","palette","exportFile","zoomIn","zoomOut","done","menu","undo","redo","questionCircle","resetZoom","stroke","strokeWidth","BringForwardIcon","memo","SendBackwardIcon","BringToFrontIcon","SendToBackIcon","strokeLinejoin","AlignTopIcon","strokeLinecap","AlignBottomIcon","AlignLeftIcon","AlignRightIcon","DistributeHorizontallyIcon","DistributeVerticallyIcon","CenterVerticallyIcon","strokeDasharray","CenterHorizontallyIcon","users","start","stop","close","back","marginLeft","clone","shield","GroupIcon","UngroupIcon","FillHachureIcon","fillRule","clipRule","FillCrossHatchIcon","FillSolidIcon","StrokeWidthIcon","StrokeStyleSolidIcon","StrokeStyleDashedIcon","StrokeStyleDottedIcon","SloppinessArchitectIcon","SloppinessArtistIcon","SloppinessCartoonistIcon","EdgeSharpIcon","EdgeRoundIcon","ArrowheadNoneIcon","ArrowheadArrowIcon","flip","transform","ArrowheadDotIcon","r","ArrowheadBarIcon","Island","forwardRef","padding","ref","Modal","props","modalRoot","useBodyRoot","createPortal","aria-modal","onKeyDown","nativeEvent","stopImmediatePropagation","onCloseRequest","aria-labelledby","labelledBy","onClick","maxWidth","div","setDiv","useLayoutEffect","isDarkTheme","classList","contains","add","Dialog","islandNode","setIslandNode","focusableElements","queryFocusableElements","autofocus","focus","handleKeyDown","activeElement","currentIndex","findIndex","element","preventDefault","addEventListener","removeEventListener","node","querySelectorAll","Array","from","small","title","aria-label","ErrorDialog","message","onClose","modalIsShown","setModalIsShown","handleClose","TopErrorBoundary","Component","state","hasError","sentryEventId","localStorage","render","this","errorSplash","componentDidCatch","errorInfo","_localStorage","entries","JSON","parse","Sentry","scope","setExtras","eventId","setState","stringify","selectTextArea","select","templateStrFn","default","encodeURIComponent","console","open","location","reload","clear","createGithubIssue","rows","onPointerDown","readOnly","LoadingMessage","InitializeApp","find","langCode","async","dir","setLanguageFirstTime","isTextElement","isLinearElement","isLinearElementType","isBindingElement","isBindingElementType","isBindableElement","rotate","x1","y1","x2","y2","angle","cos","sin","rotatePoint","point","center","adjustXYWithRotation","sides","deltaX1","deltaY1","deltaX2","deltaY2","w","n","s","distance2d","xd","yd","hypot","isPathALoop","points","firstPoint","lastPoint","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","i","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","max","val","p1","q1","p2","q2","o1","o2","o3","o4","getGridPoint","round","getSizeFromPoints","xs","ys","rescalePoints","dimension","nextDimensionSize","prevPoints","prevDimValues","prevMaxDimension","prevMinDimension","prevDimensionSize","dimensionScaleFactor","nextMinDimension","Infinity","scaledPoints","prevPoint","currentDimension","scaledValue","scaledPoint","getElementAbsoluteCoords","getLinearElementAbsoluteCoords","getCurvePathOps","set","sets","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","minX","minY","maxX","maxY","reduce","limits","op","p3","p0","equation","idx","pow","getShapeForElement","getElementBounds","cx","cy","getLinearElementRotatedBounds","x11","y11","x12","y12","x22","y22","x21","y21","h","ww","hh","getCommonBounds","elements","forEach","getResizedElementAbsoluteCoords","nextWidth","nextHeight","gen","rough","generator","curve","strokeSharpness","linearPath","generateRoughOptions","getElementPointsCoords","sharpness","defaultAppState","CANVAS_PADDING","DASHARRAY_DASHED","DASHARRAY_DOTTED","drawElementOnCanvas","rc","globalAlpha","opacity","draw","shouldTemporarilyAttach","canvas","isConnected","setAttribute","fillStyle","strokeColor","textAlign","lines","lineHeight","verticalOffset","horizontalOffset","fillText","remove","elementWithCanvasCache","WeakMap","shapeCache","get","invalidateShapeForElement","delete","options","seed","strokeLineDash","strokeStyle","disableMultiStroke","fillWeight","hachureGap","roughness","backgroundColor","curveFitting","generateElementShape","rectangle","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","floor","getDiamondPoints","polygon","ellipse","startArrowhead","endArrowhead","getArrowheadShapes","arrowhead","arrowheadPoints","prevOp","nx","ny","size","arrow","bar","dot","total","px","py","minSize","x3","y3","x4","y4","getArrowheadPoints","circle","shapes","push","generateElementWithCanvas","sceneState","prevElementWithCanvas","shouldRegenerateBecauseZoom","canvasZoom","elementWithCanvas","getContext","canvasOffsetX","canvasOffsetY","devicePixelRatio","translate","scale","generateElementCanvas","renderElement","renderOptimizations","fillRect","drawImage","drawElementFromCanvas","shiftX","shiftY","isIdKey","elementKey","Scene","callbacks","Set","nonDeletedElements","elementsMap","scene","sceneMapById","sceneMapByElement","getElementsIncludingDeleted","getElements","getElement","getNonDeletedElement","isNonDeletedElement","getNonDeletedElements","result","replaceAllElements","nextElements","mapElementToScene","informMutation","callback","addCallback","cb","has","destroy","random","Random","now","randomInteger","randomId","nanoid","mutateElement","updates","didChange","nextPoints","didChangePoints","nextPoint","version","versionNonce","getScene","newElementWith","isInvisiblySmallElement","getPerfectElementSize","absWidth","absHeight","lockedAngle","atan","tan","sign","getNormalizedDimensions","selectGroup","groupId","elementsInGroup","groupIds","includes","fromEntries","isSelectedViaGroup","getSelectedGroupForElement","getSelectedGroupIds","isSelected","selectGroupsForSelectedElements","nextAppState","selectedElements","getSelectedElements","selectedElement","indexOfEditingGroup","indexOf","isElementInGroup","getElementsInGroup","addToGroup","prevGroupIds","newGroupId","positionOfEditingGroupId","positionToInsert","splice","_newElementBase","boundElementIds","rest","isDeleted","newElement","getTextElementPositionOffsets","metrics","verticalAlign","newTextElement","offsets","getAdjustedDimensions","nextText","nextBaseline","prevMetrics","nextX1","nextY1","nextX2","nextY2","isFinite","newLinearElement","lastCommittedPoint","startBinding","endBinding","deepCopyElement","depth","prototype","toString","call","tmp","constructor","create","getPrototypeOf","hasOwnProperty","isArray","k","arr","duplicateElement","groupIdMapForOperation","overrides","copy","mapper","endIndex","getNewGroupIdsForDuplication","assign","transformHandleSizes","mouse","pen","touch","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","OMIT_SIDES_FOR_TEXT_ELEMENT","OMIT_SIDES_FOR_LINE_SLASH","nw","se","OMIT_SIDES_FOR_LINE_BACKSLASH","ne","sw","generateTransformHandle","xx","yy","getTransformHandlesFromCoords","pointerType","omitSides","handleWidth","handleHeight","handleMarginX","handleMarginY","dashedLineMargin","centeringOffset","transformHandles","rotation","minimumSizeForEightHandles","getTransformHandles","nvector","reverse","a","b","isNumber","sub","mul","mulScalar","meet","joinScalar","norm","sqrt","inorm","normalized","inormalized","c","GA","through","to","orthogonal","toTuple","intersect","line1","line2","point1","point2","distanceToLine","pivot","apply","motor","isHittingElementBoundingBoxWithoutHittingElement","threshold","isHittingElementNotConsideringBoundingBox","isPointHittingElementBoundingBox","check","isStrictlyInside","isDraggableFromInside","isElementDraggableFromInside","isInsideCheck","isNearCheck","hitTestPointAgainstElement","isElementSelected","elementCenterX","elementCenterY","rotatedX","rotatedY","bindingBorderTest","maxBindingGap","isOutsideCheck","elementWidth","elementHeight","smallerDimension","distanceToBindableElement","hitTestLinear","warn","distanceToRectangle","distanceToDiamond","distanceToEllipse","pointRel","hwidth","hheight","pointRelativeToElement","GAPoint","GALine","side","tangent","ellipseParamsForTest","tx","ty","_","ex","ey","rx","ry","qx","qy","closestPoint","intersection","pointAbs","side1","side2","relX","relY","some","subshape","hitTestCurveInside","hitTestRoughShape","pointTuple","elementCoords","coordsCenter","GATransform","pointRotated","pointRelToCenterAbs","GADirection","elementPos","pointRelToPos","ax","ay","bx","by","relativizationToElementCenter","direction","determineFocusDistance","relateToCenter","aRel","bRel","m","mabs","nabs","getSortedElementLineIntersections","nearPoint","gap","intersections","corners","getCorners","flatMap","edge","intersectSegment","offsetSegment","getCircleIntersections","getEllipseIntersections","sortedIntersections","i1","i2","hx","hy","segment","offset","squares","discr","discrRoot","xn","yn","radius","findFocusPointForEllipse","relativeDistance","relativeDistanceAbs","orientation","pyo","findFocusPointForRectangulars","maxDistance","tangentPoint","corner","drawable","odd","operation","polygonPoints","pointsOnBezierCurves","lineThreshold","mx","my","pointInBezierEquation","isInsideTransformHandle","transformHandle","getElementWithTransformHandleType","scenePointerX","scenePointerY","transformHandleType","rotationTransformHandle","resizeTest","getTransformHandleTypeFromCoords","RESIZE_CURSORS","getCursorForResizingElement","shouldSwapCursors","rotateResizeCursor","LinearElementEditor","elementId","activePointIndex","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","normalizePoints","maybeSuggestBinding","newPoint","createPointAt","movePoint","binding","getHoveredElementForBinding","getPointAtIndexGlobalCoordinates","history","scenePointer","didAddPoint","hitElement","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","bindOrUnbindLinearElement","targetPoint","indexMaybeFromEnd","absoluteCoords","pointHandles","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","pointerOnGrid","offsetX","offsetY","_idx","pointIndex","targetPosition","otherUpdates","deltaX","deltaY","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","rotated","linearElement","boundToElementIds","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","unbound","unbindLinearElement","bindOrUnbindSelectedElements","getElligibleElementForBindingElement","maybeBindBindableElement","getElligibleElementsForBindableElementAndWhere","where","maybeBindLinearElement","pointerCoords","hoveredElement","calculateFocusAndGap","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","unbindLinearElements","field","getElementAtPosition","edgePointIndex","adjacentPointIndex","edgePoint","adjacentPoint","updateBoundElements","changedElement","newSize","simultaneouslyUpdated","simultaneouslyUpdatedElementIds","getSimultaneouslyUpdatedElementIds","doesNeedUpdate","maybeCalculateNewGapWhenScaling","updateBoundPoint","boundElement","bindingElement","focusPointAbsolute","adjecentPoint","adjecentPointRel","reverseRelateToCenter","determineFocusPoint","newEdgePoint","intersectElementWithLine","pointFromAbsoluteCoords","currentBinding","newWidth","newHeight","getElligibleElementsForBindingElement","getLinearElementEdgeCoors","canBindStart","isLinearElementEligibleForNewBindingByBindable","canBindEnd","maybeElement","fixBindingsAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","duplicatesServeAsOld","allBoundElementIds","allBindableElementIds","shouldReverseRoles","oldElement","boundElementId","newBindingAfterDuplication","fixBindingsAfterDeletion","deletedElements","deletedElementIds","deletedElement","newBindingAfterDeletion","normalizeAngle","rotateSingleElement","pointerX","pointerY","isRotateWithDiscreteAngle","atan2","reshapeSingleTwoPointElement","resizeArrowDirection","getPerfectElementSizeWithRotation","nextElementX","nextElementY","rescalePointsInElement","measureFontSizeFromWH","nextFontSize","resizeSingleTextElement","isResizeFromCenter","nextFont","getSidesForTransformHandle","resizeSingleElement","stateAtResizeStart","shouldKeepSidesRatio","transformHandleDirection","startTopLeft","startBottomRight","startCenter","rotatedPointer","esx1","esy1","esx2","esy2","boundsCurrentWidth","boundsCurrentHeight","scaleX","scaleY","eleInitialWidth","eleInitialHeight","eleNewWidth","eleNewHeight","widthRatio","heightRatio","ratio","newBoundsX1","newBoundsY1","newBoundsX2","newBoundsY2","newBoundsWidth","newBoundsHeight","newTopLeft","bottomLeft","topRight","rotatedTopLeft","newCenter","rotatedNewCenter","rescaledPoints","newOrigin","resizedElement","resizeMultipleElements","getNextXY","origX1","origY1","finalX1","finalY1","origX2","origY2","finalX2","finalY2","prev","origCoords","finalCoords","rotateMultipleElements","pointerDownState","centerX","centerY","centerAngle","origAngle","originalElements","rotatedCX","rotatedCY","dragNewElement","originX","originY","isResizeWithSidesSameLength","isResizeCenterPoint","newX","newY","normalizeText","getTransform","degree","redrawTextBoundingBox","showSelectedShapeActions","Boolean","getSyncableElements","el","getElementMap","acc","getSceneVersion","_clearElements","clearElementsForExport","clearElementsForLocalStorage","isOverScrollBars","scrollBars","isOverHorizontal","isOverVertical","horizontal","vertical","scrollBar","isOverEither","isSomeElementSelected","getTargetElements","centerScrollOn","scenePoint","viewportDimensions","calculateScrollCenter","cords","viewportX1","viewportY1","viewportX2","viewportY2","isOutsideViewPort","minDistance","closestElement","getClosestElementBounds","hasBackground","hasStroke","canChangeSharpness","hasText","canHaveArrowheads","isAtPositionFn","getNewZoom","newZoomValue","prevZoom","canvasOffset","zoomOnViewportPoint","top","getNormalizedZoom","normalizedZoom","parseFloat","ToolButton","innerRef","useImperativeHandle","sizeCn","visible","hidden","ToolIcon","selected","icon","keyBindingLabel","showAriaLabel","aria-keyshortcuts","data-testid","onChange","checked","defaultProps","actions","register","action","handleGroupEditingState","siblingElements","actionDeleteSelected","perform","commitToHistory","deleteSelectedElements","contextItemLabel","keyTest","PanelComponent","updateData","getIndicesToMove","selectedIndices","deletedIndices","includeDeletedIndex","getTargetIndex","boundaryIndex","sourceElement","indexFilter","candidateIndex","array","fromIndex","findLastIndex","nextElement","siblingGroupId","elementsInSiblingGroup","shiftElements","groupedIndices","toContiguousGroups","indices","leadingIndex","trailingIndex","targetIndex","leadingElements","targetElements","displacedElements","trailingElements","shiftElementsToEnd","indicesToMove","groupElements","moveOneLeft","moveOneRight","moveAllLeft","moveAllRight","actionSendBackward","keyPriority","actionBringForward","actionSendToBack","actionBringToFront","actionSelectAll","actionDuplicateSelection","selectedPoint","duplicateElements","groupIdMap","newElements","duplicateAndOffsetElement","finalElements","ButtonIconSelect","group","option","active","ButtonSelect","Popover","fitInViewport","popoverRef","getBoundingClientRect","viewportWidth","viewportHeight","isValidColor","color","Option","keyBindings","flat","Picker","colors","showInput","firstItem","activeItem","gallery","colorInput","nextIndex","toLowerCase","tabIndex","_color","currentTarget","onFocus","ColorInput","innerValue","setInnerValue","inputRef","changeColor","inputValue","getColor","spellCheck","onBlur","ColorPicker","isActive","setActive","pickerButton","Suspense","fallback","changedColor","rFirstItem","rActiveItem","rGallery","pressedOption","keyBinding","metaKey","ctrlKey","IconPicker","rPickerButton","changeProperty","getFormValue","getAttribute","defaultValue","attributes","getCommonAttributeOfSelectedElements","zoomToFitElements","step","onWheel","stopPropagation","shouldUpdateForNonLinearElements","every","shouldUpdateForLinearElements","confirm","_elements","zoomToSelection","commonBounds","zoomValue","bounds","commonBoundsWidth","zoomValueForWidth","commonBoundsHeight","zoomValueForHeight","smallestZoomValue","zoomAdjustedToSteps","zoomValueToFitBoundsOnViewport","newZoom","actionFinalize","blur","multiPointElement","isLoop","linePoints","ProjectName","handleFocus","selection","getSelection","range","createRange","selectNodeContents","removeAllRanges","addRange","selectNode","handleBlur","trim","removeSelection","isComposing","keyCode","makeEditable","editable","contentEditable","suppressContentEditableWarning","data-type","Tooltip","long","getClientColors","clientId","currentUser","sum","charCodeAt","backgrounds","strokes","background","UserIdleState","hasEmojiSupport","ctx","textBaseline","getImageData","supportsEmoji","strokeRectWithRotation","strokeRect","fillCircle","beginPath","arc","renderScene","renderScrollbars","renderSelection","renderGrid","atLeastOneVisibleElement","normalizedCanvasWidth","normalizedCanvasHeight","clearRect","zoomTranslationX","zoomTranslationY","origStrokeStyle","moveTo","lineTo","strokeGrid","ceil","visibleElements","isVisibleElement","lineWidth","setLineDash","renderLinearPointHandles","suggestedBinding","renderBindingHighlight","selections","selectionColors","remoteSelectedElementIds","socketId","elementX1","elementY1","elementX2","elementY2","addSelectionForGroupId","renderSelectionBorder","locallySelectedElements","renderTransformHandles","dashedLinePadding","initialLineDash","getLineDash","remotePointerViewportCoords","isOutOfBounds","userState","remotePointerUserStates","AWAY","remotePointerButton","closePath","username","remotePointerUsernames","usernameAndIdleState","IDLE","paddingHorizontal","paddingVertical","measure","measureHeight","actualBoundingBoxDescent","actualBoundingBoxAscent","elementsMinX","elementsMinY","elementsMaxX","elementsMaxY","viewportWidthWithZoom","viewportHeightWithZoom","viewportWidthDiff","viewportHeightDiff","safeArea","parseInt","bottom","viewportMinX","viewportMinY","viewportMaxX","viewportMaxY","sceneMinX","sceneMinY","sceneMaxX","sceneMaxY","SCROLLBAR_MARGIN","getScrollBars","quadraticCurveTo","roundRect","SCROLLBAR_WIDTH","elementProperties","lineDashOffset","dashWidth","spaceWidth","originalStrokeStyle","originalLineWidth","renderHighlight","renderBindingHighlightForSuggestedPointBinding","renderBindingHighlightForBindableElement","strokeOffset","strokeDiamondWithRotation","strokeEllipseWithRotation","canvasWidth","canvasHeight","viewTransformations","topLeftSceneCoords","bottomRightSceneCoords","renderSceneToSvg","rsvg","svgRoot","ownerDocument","createElementNS","textAnchor","textContent","renderElementToSvg","SVG_EXPORT_TAG","exportToCanvas","exportPadding","createCanvas","tempCanvas","getElementsAndWatermark","getCanvasSize","newScale","exportToSvg","metadata","innerHTML","rect","svg","getWatermarkElement","BAR_WIDTH","BAR_GAP","BAR_HEIGHT","NOT_SPREADSHEET","VALID_SPREADSHEET","tryParseNumber","match","exec","isNumericColumn","columnIndex","tryParseCells","cells","numCols","reason","hasHeader","values","spreadsheet","labels","valueColumnIndex","labelColumnIndex","row","bgColors","commonProps","getChartDimentions","chartWidth","chartHeight","chartXLabels","chartYLabels","minYLabel","toLocaleString","chartLines","chartBaseElements","debug","debugRect","renderSpreadsheet","chartType","dots","chartTypeLine","barHeight","chartTypeBar","CanvasError","super","restoreElementWithProperties","extra","base","restoreElement","fontPx","_fontFamily","fontFamilyName","fontFamilyString","getFontFamilyByName","restoreElements","migratedElement","restoreAppState","localAppState","restoredValue","localValue","restore","parseFileContents","contents","blob","decodePngMetadata","Blob","reader","FileReader","readAsText","onloadend","readyState","DONE","decodeSvgMetadata","getMimeType","loadFromBlob","canvasToBlob","toBlob","TYPE_ELEMENTS","CLIPBOARD","PREFER_APP_CLIPBOARD","probablySupportsClipboardReadText","probablySupportsClipboardWriteText","probablySupportsClipboardBlob","HTMLCanvasElement","copyToClipboard","created","json","copyTextToSystemClipboard","getAppClipboard","parsePotentialSpreadsheet","numColsFirstLine","transposedResults","nextCells","col","nextCellRow","transposeCells","tryParseSpreadsheet","parseClipboard","systemClipboard","clipboardData","getData","readText","getSystemClipboard","spreadsheetResult","appClipboardData","systemClipboardData","copied","writeText","copyTextViaExecCommand","textarea","border","margin","yPosition","pageYOffset","scrollTop","success","setSelectionRange","execCommand","Library","libraryFile","loadLibraryFromBlob","library","existingLibraryItems","loadLibrary","filtered","libraryItem","restored","targetLibraryItem","libItemExcalidrawItem","isUniqueitem","saveLibrary","libraryCache","resetLibrary","removeItem","getItem","items","prevLibraryItems","serializedItems","setItem","serializeAsJSON","source","origin","saveAsJSON","serialized","fileSave","fileName","description","extensions","exportCanvas","tempSvg","encodeSvgMetadata","outerHTML","encodePngMetadata","write","ClipboardItem","copyCanvasToClipboardAsPng","fileHandleExists","loadedElements","loadedAppState","fileOpen","mimeTypes","loadFromJSON","copiedStyles","actionCopyStyles","actionPasteStyles","pastedElement","HelpIcon","enableActionGroup","requestFullscreen","exitFullscreen","allElementsInSameGroup","actionGroup","selectedGroupId","elementIdsInGroup","updatedElements","lastElementInGroup","lastGroupElementIndex","lastIndexOf","elementsAfterGroup","updatedElementsInOrder","updatedElement","contextItemPredicate","actionUngroup","nextGroupIds","removeFromSelectedGroups","Avatar","actionAddToLibrary","collaborator","shortName","names","substring","firstName","lastName","getClientInitials","pointer","getMaximumGroups","groups","currentGroupMembers","calculateTranslation","selectionBoundingBox","axis","groupBoundingBox","getCommonBoundingBox","noTranslation","alignSelectedElements","alignment","alignElements","updatedElementsMap","midX","midY","distributeSelectedElements","distribution","mid","end","extent","index0","g","index1","pos","box","distributeElements","actionCopy","space","actionCut","app","actionCopyAsSvg","_data","actionCopyAsPng","actionToggleGridMode","actionToggleZenMode","actionToggleStats","writeData","prevElements","updater","prevElementMap","nextElementMap","prevElement","syncHistory","ActionManager","getAppState","renderAction","formState","actionResult","registerAction","registerAll","executeAction","getCenter","pointers","allCoords","coords","getDistance","item","clearAppStatePropertiesForHistory","SceneHistory","elementCache","recording","stateHistory","redoStack","lastEntry","generateEntry","dehydrateHistoryEntry","hydrateHistoryEntry","dehydratedExcalidrawElement","versions","getSnapshotForTest","dehydratedHistoryEntry","shouldCreateEntry","nextEntry","pushEntry","newEntryDehydrated","newEntry","clearRedoStack","redoOnce","entryToRestore","pop","undoOnce","currentEntry","setCurrentState","record","SHAPES","shortcutMap","cut","paste","copyStyles","pasteStyles","selectAll","duplicateSelection","sendBackward","bringForward","sendToBack","bringToFront","copyAsPng","copyAsSvg","ungroup","gridMode","zenMode","stats","addToLibrary","viewMode","getShortcutFromShortcutName","shortcuts","ContextMenu","actionManager","onContextMenu","actionName","dangerous","checkmark","contextMenuNode","getContextMenuNode","unmountComponentAtNode","params","of","align","justifyContent","alignItems","justifyItems","SelectedShapeActions","isEditing","showFillIcons","isRGBTransparent","substr","isRRGGBBTransparent","isTransparent","showChangeBackgroundIcons","LIBRARY_ICON","ShapesSwitcher","setAppState","letter","ZoomActions","marginInlineStart","DarkModeToggle","ICONS","MOON","SUN","BackgroundPickerAndDarkModeToggle","CollabButton","isCollaborating","collaboratorCount","scales","defaultScale","ErrorCanvasPreview","renderPreview","previewNode","ExportModal","onExportToPng","onExportToSvg","onExportToClipboard","onExportToBackend","someElementIsSelected","setScale","exportSelected","setExportSelected","previewRef","exportedElements","catch","trunc","getExportSize","scaleButtonTitle","ExportDialog","triggerButton","FixedSideContainer","GitHubCorner","xmlns","href","rel","transformOrigin","HintViewer","hint","multiMode","targetElement","getHints","PLUS_ICON","LibraryUnit","pendingElements","onRemoveFromLibrary","elementsToRender","child","tagName","isHovered","setIsHovered","adder","onMouseEnter","onMouseLeave","draggable","onDragStart","dataTransfer","setData","CHECKED","UNCHECKED","LockIcon","Section","heading","header","UserList","mobile","UserList_mobile","MobileMenu","libraryMenu","exportButton","onCollabButtonClick","onLockToggle","renderCustomFooter","marginBottom","marginRight","client","Fragment","ChartPreviewBtn","chartElements","setChartElements","parentNode","PasteChartDialog","onInsertChart","handleChartClick","Header","Columns","flexDirection","flexWrap","Column","ShortcutIsland","caption","Shortcut","flex","minWidth","ShortcutKey","isOr","HelpDialog","LibraryMenuItems","onAddToLibrary","onInsertShape","numCells","CELLS_PER_ROW","numRows","addedPendingElements","importLibrary","importLibraryFromJSON","saveLibraryAsJSON","shouldAddPendingElements","bind","LibraryMenu","onClickOutside","listener","Element","useOnClickOutside","closest","libraryItems","setLibraryItems","loadingState","setIsLoading","loadingTimerRef","race","removeFromLibrary","nextItems","indexToRemove","LayerUI","onInsertElements","showExitZenModeBtn","toggleZenMode","renderExportDialog","createExporter","closeLibrary","deselectItems","dialogs","shouldRenderSelectedShapeActions","zIndex","renderFixedSideContainer","areEqual","getNecessaryObj","prevAppState","importUsernameFromLocalStorage","getElementsStorageSize","getTotalStorageSize","collab","APP_STORAGE_KEYS","appStateSize","collabSize","getStorageSizes","Stats","storageSizes","setStorageSizes","sizes","boundingBox","selectedBoundingBox","hash","timestamp","colSpan","Toast","clearToast","timerRef","scheduleTimeout","actionToggleViewMode","didTapTwice","tappedTwiceTimer","cursorX","cursorY","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","touchTimeout","invalidateContextMenu","lastPointerUp","gesture","lastCenter","initialDistance","initialScale","App","unmounted","excalidrawContainerRef","createRef","getSceneElementsIncludingDeleted","getSceneElements","syncActionResult","gridModeEnabled","onUnload","disableEvent","onFontLoaded","onSceneUpdated","importLibraryFromUrl","replaceState","request","fetch","url","isValidLibrary","numShapes","alert","resetHistory","resetScene","resetLoadingState","initializeScene","launchQueue","setConsumer","launchParams","files","getFile","initialData","addToLibraryUrl","URLSearchParams","search","onResize","onCut","cutAll","onCopy","copyAll","onTapStart","resetTapTwice","touches","handleCanvasDoubleClick","onTapEnd","pasteFromClipboard","elementUnderCursor","elementFromPoint","addElementsFromPasteOrLibrary","addTextFromPaste","selectShapeTool","clipboardElements","elementsCenterX","elementsCenterY","dx","dy","gridX","gridY","obj","removePointer","pointerId","toggleLock","prevState","toggleStats","setScrollToCenter","remoteElements","updateScene","sceneData","updateCurrentCursorPosition","Proxy","ev","prop","HTMLSelectElement","maybeSuggestBindingForAll","startTextEditing","findShapeByKey","onKeyUp","onGestureStart","onGestureChange","onGestureEnd","insertAtParentCenter","existingTextElement","getTextElementAtPosition","parentCenterPosition","getTextWysiwygSnappedToCenterPosition","handleTextWysiwyg","isExistingElement","getSelectedGroupIdForElement","handleCanvasPointerMove","savePointer","scaleFactor","resetShouldCacheIgnoreZoomDebounced","isOverScrollBar","handlePointerMove","maybeSuggestBindingAtCursor","maybeSuggestBindingForLinearElementAtCursor","buttons","elementWithTransformHandleType","isHittingCommonBoundingBoxOfSelectedElements","handleTouchMove","handleCanvasPointerDown","persist","maybeOpenContextMenuAfterPointerDownOnTouchDevices","maybeCleanupAfterMissingPointerUp","handleCanvasPanUsingWheelOrSpaceDrag","button","updateGestureOnPointerDown","initialPointerDownState","handleDraggingScrollBar","clearSelectionIfNotUsingSelection","updateBindingEnabledOnPointerMove","handleSelectionOnPointerDown","handleTextOnPointerDown","handleLinearElementOnPointerDown","createGenericElementOnPointerDown","onPointerMove","onPointerMoveFromPointerDownHandler","onPointerUp","onPointerUpFromPointerDownHandler","onKeyDownFromPointerDownHandler","onKeyUpFromPointerDownHandler","POINTER_MOVE","POINTER_UP","KEYDOWN","KEYUP","eventListeners","onMove","onUp","openContextMenu","nextPastePrevented","isLinux","lastX","lastY","preventNextPaste","PASTE","enableNextPaste","teardown","BLUR","passive","resize","handleType","getResizeOffsetXY","arrowDirection","getResizeArrowDirection","handlePointerDown","hit","allHitElements","getElementsAtPosition","someHitElementIsSelected","isASelectedElement","hasHitCommonBoundingBoxOfSelectedElements","clearSelection","wasAddedToSelection","shouldEnableBinding","shouldEnableBindingForPointerEvent","hoveredBindableElement","oppositeBindingBoundElement","handleCanvasRef","handleWheel","TOUCH_START","TOUCH_END","handleCanvasOnDrop","file","libraryShapes","endsWith","getAsFileSystemHandle","handleCanvasContextMenu","maybeDragNewGenericElement","lastCoords","originInGrid","maybeHandleResize","resizeX","resizeY","transformElements","maybeGroupAction","maybeUngroupAction","separator","_isMobile","appStates","viewModeOptions","MAX_STEP","delta","log10","isNaN","onPointerUpdate","pointersMap","excalidrawRef","getCanvasOffsets","readyPromise","api","ready","createRedoAction","renderCanvas","canvasScale","canvasDOMWidth","canvasDOMHeight","onPointerCancel","onTouchMove","onDoubleClick","onDrop","renderFooter","DEFAULT_PASTE_X","DEFAULT_PASTE_Y","defineProperties","configurable","addEventListeners","componentWillUnmount","removeEventListeners","COPY","CUT","MOUSE_MOVE","RESIZE","UNLOAD","DRAG_OVER","DROP","GESTURE_START","GESTURE_CHANGE","GESTURE_END","fonts","componentDidUpdate","prevProps","updateLanguage","toggle","pointerViewportCoords","pointerUsernames","pointerUserStates","user","updateElement","_element","updateTextElement","onSubmit","getViewportCoords","updateWysiwygStyle","viewportX","viewportY","wrap","minHeight","backfaceVisibility","outline","oninput","onkeydown","handleSubmit","stopEvent","cleanup","isDestroyed","onblur","rebindBlur","unbindUpdate","capture","textWysiwyg","elementWithHighestZIndex","hitTest","scrollbars","hasBeenDuplicated","drag","hasOccurred","handlePointerMoveOverScrollbars","getDragOffsetXY","handlePointDragging","dragX","dragY","dragDistanceX","dragDistanceY","lockDirection","distanceX","distanceY","lockX","lockY","original","dragSelectedElements","elementsToAppend","duplicatedElement","originDragX","originDragY","nextSceneElements","simplify","elementsWithinSelection","selectionX1","selectionY1","selectionX2","selectionY2","getElementsWithinSelection","childEvent","handlePointerUp","idsOfSelectedElementsThatAreInGroups","prevId","_prevState","gId","includedElementIds","getEligibleElementsForBinding","elementClickedInside","getElementContainingPosition","parentElement","setLanguage","Excalidraw","nextProps","prevInitialData","nextInitialData","prevKeys","nextKeys","lanCode","forwardedRefComp","BROADCAST","SCENE","byteToHex","byte","createIV","Uint8Array","crypto","getRandomValues","generateCollaborationLinkData","roomId","generateRandomID","roomKey","subtle","generateKey","exportKey","generateEncryptionKey","getImportedKey","usage","importKey","alg","ext","key_ops","kty","loadScene","privateKey","response","ok","buffer","arrayBuffer","iv","decrypted","decrypt","string","TextDecoder","decode","importFromBackend","firebasePromise","getFirebase","firebase","firebaseConfig","initializeApp","loadFirebase","firebaseSceneVersionCache","isSavedToFirebase","portal","socket","sceneVersion","saveToFirebase","ciphertext","importedKey","encoded","TextEncoder","encode","encrypt","encryptElements","nextDocData","firestore","fromUint8Array","db","docRef","collection","doc","didUpdate","runTransaction","transaction","exists","update","loadFromFirebase","storedScene","toUint8Array","decodedData","decryptElements","Portal","socketInitialized","broadcastedElementVersions","broadcastScene","sceneType","syncableElements","syncAll","INIT","syncableElement","payload","broadcastPromise","_broadcastSocketData","saveCollabRoomToFirebase","broadcastIdleChange","broadcastMouseLocation","excalidrawAPI","on","emit","clients","setCollaborators","isOpen","volatile","encrypted","encryptAESGEM","RoomDialog","activeRoomLink","onUsernameChange","onRoomCreate","onRoomDestroy","setErrorMessage","roomLinkInput","copyRoomLink","selectInput","htmlFor","onKeyPress","Context","CollabContext","Consumer","CollabContextConsumer","CollabContextProvider","initialValue","InverseConsumer","_updateProviderValue","InverseProvider","componentDidMount","createInverseContext","CollabWrapper","PureComponent","activeIntervalId","idleTimeoutId","socketInitializationTimer","lastBroadcastedOrReceivedSceneVersion","destroySocketClient","isUnload","beforeUnload","returnValue","room","openPortal","initializeSocketClient","closePortal","pushState","existingRoomLinkData","pathname","scenePromise","socketIOClient","initializeSocket","encryptedData","decryptedData","decryptAESGEM","reconciledElements","reconcileElements","handleRemoteSceneUpdate","init","UPDATE","socketID","off","initializeIdleDetector","currentElements","localElementMap","setLastBroadcastedOrReceivedSceneVersion","initFromSnapshot","reportIdle","setInterval","reportActive","onVisibilityChange","clearInterval","onIdleStateChange","ACTIVE","VISIBILITY_CHANGE","getLastBroadcastedOrReceivedSceneVersion","broadcastElements","queueBroadcastAllElements","throttle","currentVersion","newVersion","saveUsernameToLocalStorage","contextValue","getContextValue","BEFORE_UNLOAD","sockets","LanguageList","i18n","currentLangCode","floating","languageDetector","LanguageDetector","languageUtils","formatLanguageCode","isWhitelisted","checkWhitelist","saveDebounced","saveToLocalStorage","jsonMatch","savedElements","savedState","importFromLocalStorage","roomLinkData","URL","getCollaborationLinkData","once","collabAPI","ExcalidrawWrapper","dimensions","setDimensions","detect","setLangCode","initialStatePromiseRef","excalidrawRefCallback","onHashChange","titleTimeout","HASHCHANGE","cacheUserLanguage","renderLanguageList","exportedKey","method","urlString","prompt","error_class","exportToBackend","ExcalidrawApp","isLocalhost","hostname","registerValidSW","swUrl","config","serviceWorker","registration","onupdatefound","installingWorker","installing","onstatechange","controller","info","onUpdate","onSuccess","checkValidServiceWorker","headers","contentType","status","unregister","userAgent","registerServiceWorker","waitingServiceWorker","waiting","STATE_CHANGE","postMessage","SentryEnvHostnameMap","onlineEnv","REACT_APP_DISABLE_SENTRY","dsn","environment","release","ignoreErrors","integrations","SentryIntegrations","levels","beforeSend","__EXCALIDRAW_SHA__","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.0426162a.chunk.js","sourcesContent":["import { FontFamily } from \"./element/types\";\n\nexport const APP_NAME = \"Excalidraw\";\n\nexport const DRAGGING_THRESHOLD = 10; // 10px\nexport const LINE_CONFIRM_THRESHOLD = 10; // 10px\nexport const ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nexport const ELEMENT_TRANSLATE_AMOUNT = 1;\nexport const TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\nexport const SHIFT_LOCKING_ANGLE = Math.PI / 12;\nexport const CURSOR_TYPE = {\n  TEXT: \"text\",\n  CROSSHAIR: \"crosshair\",\n  GRABBING: \"grabbing\",\n  POINTER: \"pointer\",\n  MOVE: \"move\",\n  AUTO: \"\",\n};\nexport const POINTER_BUTTON = {\n  MAIN: 0,\n  WHEEL: 1,\n  SECONDARY: 2,\n  TOUCH: -1,\n};\n\nexport enum EVENT {\n  COPY = \"copy\",\n  PASTE = \"paste\",\n  CUT = \"cut\",\n  KEYDOWN = \"keydown\",\n  KEYUP = \"keyup\",\n  MOUSE_MOVE = \"mousemove\",\n  RESIZE = \"resize\",\n  UNLOAD = \"unload\",\n  BLUR = \"blur\",\n  DRAG_OVER = \"dragover\",\n  DROP = \"drop\",\n  GESTURE_END = \"gestureend\",\n  BEFORE_UNLOAD = \"beforeunload\",\n  GESTURE_START = \"gesturestart\",\n  GESTURE_CHANGE = \"gesturechange\",\n  POINTER_MOVE = \"pointermove\",\n  POINTER_UP = \"pointerup\",\n  STATE_CHANGE = \"statechange\",\n  WHEEL = \"wheel\",\n  TOUCH_START = \"touchstart\",\n  TOUCH_END = \"touchend\",\n  HASHCHANGE = \"hashchange\",\n  VISIBILITY_CHANGE = \"visibilitychange\",\n}\n\nexport const ENV = {\n  TEST: \"test\",\n  DEVELOPMENT: \"development\",\n};\n\nexport const CLASSES = {\n  SHAPE_ACTIONS_MENU: \"App-menu__left\",\n};\n\n// 1-based in case we ever do `if(element.fontFamily)`\nexport const FONT_FAMILY = {\n  1: \"Virgil\",\n  2: \"Helvetica\",\n  3: \"Cascadia\",\n  4: \"ZHIWNDXSG\",\n} as const;\n\nexport const WINDOWS_EMOJI_FALLBACK_FONT = \"Segoe UI Emoji\";\n\nexport const DEFAULT_FONT_SIZE = 20;\nexport const DEFAULT_FONT_FAMILY: FontFamily = 1;\nexport const DEFAULT_TEXT_ALIGN = \"left\";\nexport const DEFAULT_VERTICAL_ALIGN = \"top\";\nexport const DEFAULT_VERSION = \"{version}\";\n\nexport const CANVAS_ONLY_ACTIONS = [\"selectAll\"];\n\nexport const GRID_SIZE = 20; // TODO make it configurable?\n\nexport const MIME_TYPES = {\n  excalidraw: \"application/vnd.excalidraw+json\",\n  excalidrawlib: \"application/vnd.excalidrawlib+json\",\n};\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_LIBRARY: \"excalidraw-library\",\n};\n\n// time in milliseconds\nexport const TAP_TWICE_TIMEOUT = 300;\nexport const TOUCH_CTX_MENU_TIMEOUT = 500;\nexport const TITLE_TIMEOUT = 10000;\nexport const TOAST_TIMEOUT = 5000;\nexport const VERSION_TIMEOUT = 30000;\n\nexport const ZOOM_STEP = 0.1;\n\n// Report a user inactive after IDLE_THRESHOLD milliseconds\nexport const IDLE_THRESHOLD = 60_000;\n// Report a user active each ACTIVE_THRESHOLD milliseconds\nexport const ACTIVE_THRESHOLD = 3_000;\n","export const trackEvent =\n  typeof process !== \"undefined\" &&\n  process.env?.REACT_APP_GOOGLE_ANALYTICS_ID &&\n  typeof window !== \"undefined\" &&\n  window.gtag\n    ? (category: string, name: string, label?: string, value?: number) => {\n        window.gtag(\"event\", name, {\n          event_category: category,\n          event_label: label,\n          value,\n        });\n      }\n    : typeof process !== \"undefined\" && process.env?.JEST_WORKER_ID\n    ? (category: string, name: string, label?: string, value?: number) => {}\n    : (category: string, name: string, label?: string, value?: number) => {\n        // Uncomment the next line to track locally\n        // console.info(\"Track Event\", category, name, label, value);\n      };\n","var map = {\n\t\"./ar-SA.json\": [\n\t\t75,\n\t\t4\n\t],\n\t\"./bg-BG.json\": [\n\t\t76,\n\t\t5\n\t],\n\t\"./ca-ES.json\": [\n\t\t77,\n\t\t6\n\t],\n\t\"./de-DE.json\": [\n\t\t78,\n\t\t7\n\t],\n\t\"./el-GR.json\": [\n\t\t79,\n\t\t8\n\t],\n\t\"./en.json\": [\n\t\t28\n\t],\n\t\"./es-ES.json\": [\n\t\t80,\n\t\t9\n\t],\n\t\"./fa-IR.json\": [\n\t\t81,\n\t\t10\n\t],\n\t\"./fi-FI.json\": [\n\t\t82,\n\t\t11\n\t],\n\t\"./fr-FR.json\": [\n\t\t83,\n\t\t12\n\t],\n\t\"./he-IL.json\": [\n\t\t84,\n\t\t13\n\t],\n\t\"./hi-IN.json\": [\n\t\t85,\n\t\t14\n\t],\n\t\"./hu-HU.json\": [\n\t\t86,\n\t\t15\n\t],\n\t\"./id-ID.json\": [\n\t\t87,\n\t\t16\n\t],\n\t\"./it-IT.json\": [\n\t\t88,\n\t\t17\n\t],\n\t\"./ja-JP.json\": [\n\t\t89,\n\t\t18\n\t],\n\t\"./kab-KAB.json\": [\n\t\t90,\n\t\t19\n\t],\n\t\"./ko-KR.json\": [\n\t\t91,\n\t\t20\n\t],\n\t\"./my-MM.json\": [\n\t\t92,\n\t\t21\n\t],\n\t\"./nb-NO.json\": [\n\t\t93,\n\t\t22\n\t],\n\t\"./nl-NL.json\": [\n\t\t94,\n\t\t23\n\t],\n\t\"./nn-NO.json\": [\n\t\t95,\n\t\t24\n\t],\n\t\"./pa-IN.json\": [\n\t\t96,\n\t\t25\n\t],\n\t\"./percentages.json\": [\n\t\t29\n\t],\n\t\"./pl-PL.json\": [\n\t\t97,\n\t\t26\n\t],\n\t\"./pt-BR.json\": [\n\t\t98,\n\t\t27\n\t],\n\t\"./pt-PT.json\": [\n\t\t99,\n\t\t28\n\t],\n\t\"./ro-RO.json\": [\n\t\t100,\n\t\t29\n\t],\n\t\"./ru-RU.json\": [\n\t\t101,\n\t\t30\n\t],\n\t\"./sk-SK.json\": [\n\t\t102,\n\t\t31\n\t],\n\t\"./sv-SE.json\": [\n\t\t103,\n\t\t32\n\t],\n\t\"./tr-TR.json\": [\n\t\t104,\n\t\t33\n\t],\n\t\"./uk-UA.json\": [\n\t\t105,\n\t\t34\n\t],\n\t\"./zh-CN.json\": [\n\t\t106,\n\t\t35\n\t],\n\t\"./zh-TW.json\": [\n\t\t107,\n\t\t36\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, 3);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 32;\nmodule.exports = webpackAsyncContext;","// extracted by mini-css-extract-plugin\nmodule.exports = {\"isMobileQuery\":\"(max-width: 600px), (max-height: 500px) and (max-width: 1000px)\"};","import fallbackLangData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\n\nconst COMPLETION_THRESHOLD = 85;\n\nexport interface Language {\n  code: string;\n  label: string;\n  rtl?: boolean;\n}\n\nexport const defaultLang = { code: \"en\", label: \"English\" };\n\nconst allLanguages: Language[] = [\n  { code: \"ar-SA\", label: \"\", rtl: true },\n  { code: \"bg-BG\", label: \"\" },\n  { code: \"ca-ES\", label: \"Catal\" },\n  { code: \"de-DE\", label: \"Deutsch\" },\n  { code: \"el-GR\", label: \"\" },\n  { code: \"es-ES\", label: \"Espaol\" },\n  { code: \"fa-IR\", label: \"\", rtl: true },\n  { code: \"fi-FI\", label: \"Suomi\" },\n  { code: \"fr-FR\", label: \"Franais\" },\n  { code: \"he-IL\", label: \"\", rtl: true },\n  { code: \"hi-IN\", label: \"\" },\n  { code: \"hu-HU\", label: \"Magyar\" },\n  { code: \"id-ID\", label: \"Bahasa Indonesia\" },\n  { code: \"it-IT\", label: \"Italiano\" },\n  { code: \"ja-JP\", label: \"\" },\n  { code: \"kab-KAB\", label: \"Taqbaylit\" },\n  { code: \"ko-KR\", label: \"\" },\n  { code: \"my-MM\", label: \"Burmese\" },\n  { code: \"nb-NO\", label: \"Norsk bokml\" },\n  { code: \"nl-NL\", label: \"Nederlands\" },\n  { code: \"nn-NO\", label: \"Norsk nynorsk\" },\n  { code: \"pa-IN\", label: \"\" },\n  { code: \"pl-PL\", label: \"Polski\" },\n  { code: \"pt-BR\", label: \"Portugus Brasileiro\" },\n  { code: \"pt-PT\", label: \"Portugus\" },\n  { code: \"ro-RO\", label: \"Romn\" },\n  { code: \"ru-RU\", label: \"\" },\n  { code: \"sk-SK\", label: \"Slovenina\" },\n  { code: \"sv-SE\", label: \"Svenska\" },\n  { code: \"tr-TR\", label: \"Trke\" },\n  { code: \"uk-UA\", label: \"\" },\n  { code: \"zh-CN\", label: \"\" },\n  { code: \"zh-TW\", label: \"\" },\n].concat([defaultLang]);\n\nexport const languages: Language[] = allLanguages\n  .sort((left, right) => (left.label > right.label ? 1 : -1))\n  .filter(\n    (lang) =>\n      (percentages as Record<string, number>)[lang.code] >=\n      COMPLETION_THRESHOLD,\n  );\n\nlet currentLang: Language = defaultLang;\nlet currentLangData = {};\n\nexport const setLanguage = async (lang: Language) => {\n  currentLang = lang;\n  document.documentElement.dir = currentLang.rtl ? \"rtl\" : \"ltr\";\n\n  currentLangData = await import(\n    /* webpackChunkName: \"i18n-[request]\" */ `./locales/${currentLang.code}.json`\n  );\n};\n\nexport const setLanguageFirstTime = async (lang: Language) => {\n  currentLang = lang;\n  document.documentElement.dir = currentLang.rtl ? \"rtl\" : \"ltr\";\n\n  currentLangData = await import(\n    /* webpackChunkName: \"i18n-[request]\" */ `./locales/${currentLang.code}.json`\n  );\n};\n\nexport const getLanguage = () => currentLang;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (let index = 0; index < parts.length; ++index) {\n    const part = parts[index];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (path: string, replacement?: { [key: string]: string }) => {\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLangData, parts) ||\n    findPartsForData(fallbackLangData, parts);\n  if (translation === undefined) {\n    throw new Error(`Can't find translation for ${path}`);\n  }\n\n  if (replacement) {\n    for (const key in replacement) {\n      translation = translation.replace(`{{${key}}}`, replacement[key]);\n    }\n  }\n  return translation;\n};\n","import oc from \"open-color\";\n\nconst shades = (index: number) => [\n  oc.red[index],\n  oc.pink[index],\n  oc.grape[index],\n  oc.violet[index],\n  oc.indigo[index],\n  oc.blue[index],\n  oc.cyan[index],\n  oc.teal[index],\n  oc.green[index],\n  oc.lime[index],\n  oc.yellow[index],\n  oc.orange[index],\n];\n\nexport default {\n  canvasBackground: [oc.white, oc.gray[0], oc.gray[1], ...shades(0)],\n  elementBackground: [\"transparent\", oc.gray[4], oc.gray[6], ...shades(6)],\n  elementStroke: [oc.black, oc.gray[8], oc.gray[7], ...shades(9)],\n};\n","export const isDarwin = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\nexport const isWindows = /^Win/.test(window.navigator.platform);\n\nexport const CODES = {\n  EQUAL: \"Equal\",\n  MINUS: \"Minus\",\n  NUM_ADD: \"NumpadAdd\",\n  NUM_SUBTRACT: \"NumpadSubtract\",\n  NUM_ZERO: \"Numpad0\",\n  BRACKET_RIGHT: \"BracketRight\",\n  BRACKET_LEFT: \"BracketLeft\",\n  ONE: \"Digit1\",\n  TWO: \"Digit2\",\n  NINE: \"Digit9\",\n  QUOTE: \"Quote\",\n  ZERO: \"Digit0\",\n  C: \"KeyC\",\n  G: \"KeyG\",\n  F: \"KeyF\",\n  H: \"KeyH\",\n  V: \"KeyV\",\n  X: \"KeyX\",\n  Z: \"KeyZ\",\n  R: \"KeyR\",\n} as const;\n\nexport const KEYS = {\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_UP: \"ArrowUp\",\n  BACKSPACE: \"Backspace\",\n  ALT: \"Alt\",\n  CTRL_OR_CMD: isDarwin ? \"metaKey\" : \"ctrlKey\",\n  DELETE: \"Delete\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  QUESTION_MARK: \"?\",\n  SPACE: \" \",\n  TAB: \"Tab\",\n\n  A: \"a\",\n  D: \"d\",\n  E: \"e\",\n  L: \"l\",\n  O: \"o\",\n  P: \"p\",\n  Q: \"q\",\n  R: \"r\",\n  S: \"s\",\n  T: \"t\",\n  V: \"v\",\n  X: \"x\",\n  Y: \"y\",\n  Z: \"z\",\n} as const;\n\nexport type Key = keyof typeof KEYS;\n\nexport const isArrowKey = (key: string) =>\n  key === KEYS.ARROW_LEFT ||\n  key === KEYS.ARROW_RIGHT ||\n  key === KEYS.ARROW_DOWN ||\n  key === KEYS.ARROW_UP;\n\nexport const getResizeCenterPointKey = (event: MouseEvent | KeyboardEvent) =>\n  event.altKey;\n\nexport const getResizeWithSidesSameLengthKey = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n\nexport const getRotateWithDiscreteAngleKey = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n","import colors from \"./colors\";\nimport {\n  CURSOR_TYPE,\n  DEFAULT_VERSION,\n  FONT_FAMILY,\n  WINDOWS_EMOJI_FALLBACK_FONT,\n} from \"./constants\";\nimport { FontFamily, FontString } from \"./element/types\";\nimport { Zoom } from \"./types\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { isDarwin } from \"./keys\";\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n\nlet mockDateTime: string | null = null;\n\nexport const setDateTimeForTests = (dateTime: string) => {\n  mockDateTime = dateTime;\n};\n\nexport const getDateTime = () => {\n  if (mockDateTime) {\n    return mockDateTime;\n  }\n\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = `${date.getMonth() + 1}`.padStart(2, \"0\");\n  const day = `${date.getDate()}`.padStart(2, \"0\");\n  const hr = `${date.getHours()}`.padStart(2, \"0\");\n  const min = `${date.getMinutes()}`.padStart(2, \"0\");\n\n  return `${year}-${month}-${day}-${hr}${min}`;\n};\n\nexport const capitalizeString = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const isToolIcon = (\n  target: Element | EventTarget | null,\n): target is HTMLElement =>\n  target instanceof HTMLElement && target.className.includes(\"ToolIcon\");\n\nexport const isInputLike = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLSelectElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLInputElement ||\n  target instanceof HTMLTextAreaElement ||\n  target instanceof HTMLSelectElement;\n\nexport const isWritableElement = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLTextAreaElement ||\n  (target instanceof HTMLInputElement &&\n    (target.type === \"text\" || target.type === \"number\"));\n\nexport const getFontFamilyString = ({\n  fontFamily,\n}: {\n  fontFamily: FontFamily;\n}) => {\n  return `${FONT_FAMILY[fontFamily]}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;\n};\n\n/** returns fontSize+fontFamily string for assignment to DOM elements */\nexport const getFontString = ({\n  fontSize,\n  fontFamily,\n}: {\n  fontSize: number;\n  fontFamily: FontFamily;\n}) => {\n  return `${fontSize}px ${getFontFamilyString({ fontFamily })}` as FontString;\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport const measureText = (text: string, font: FontString) => {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"pre\";\n  line.style.font = font;\n  body.appendChild(line);\n  line.innerText = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n};\n\nexport const debounce = <T extends any[]>(\n  fn: (...args: T) => void,\n  timeout: number,\n) => {\n  let handle = 0;\n  let lastArgs: T;\n  const ret = (...args: T) => {\n    lastArgs = args;\n    clearTimeout(handle);\n    handle = window.setTimeout(() => fn(...args), timeout);\n  };\n  ret.flush = () => {\n    clearTimeout(handle);\n    if (lastArgs) {\n      fn(...lastArgs);\n    }\n  };\n  ret.cancel = () => {\n    clearTimeout(handle);\n  };\n  return ret;\n};\n\nexport const selectNode = (node: Element) => {\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n};\n\nexport const removeSelection = () => {\n  const selection = window.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n  }\n};\n\nexport const distance = (x: number, y: number) => Math.abs(x - y);\n\nexport const resetCursor = () => {\n  document.documentElement.style.cursor = \"\";\n};\n\nexport const setCursorForShape = (shape: string) => {\n  if (shape === \"selection\") {\n    resetCursor();\n  } else {\n    document.documentElement.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  }\n};\n\nexport const isFullScreen = () =>\n  document.fullscreenElement?.nodeName === \"HTML\";\n\nexport const allowFullScreen = () =>\n  document.documentElement.requestFullscreen();\n\nexport const exitFullScreen = () => document.exitFullscreen();\n\nexport const getShortcutKey = (shortcut: string): string => {\n  shortcut = shortcut\n    .replace(/\\bAlt\\b/i, \"Alt\")\n    .replace(/\\bShift\\b/i, \"Shift\")\n    .replace(/\\b(Enter|Return)\\b/i, \"Enter\")\n    .replace(/\\bDel\\b/i, \"Delete\");\n\n  if (isDarwin) {\n    return shortcut\n      .replace(/\\bCtrlOrCmd\\b/i, \"Cmd\")\n      .replace(/\\bAlt\\b/i, \"Option\");\n  }\n  return shortcut.replace(/\\bCtrlOrCmd\\b/i, \"Ctrl\");\n};\n\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY }: { clientX: number; clientY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const invScale = 1 / zoom.value;\n  const x = (clientX - zoom.translation.x - offsetLeft) * invScale - scrollX;\n  const y = (clientY - zoom.translation.y - offsetTop) * invScale - scrollY;\n  return { x, y };\n};\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY }: { sceneX: number; sceneY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const x = (sceneX + scrollX + offsetLeft) * zoom.value + zoom.translation.x;\n  const y = (sceneY + scrollY + offsetTop) * zoom.value + zoom.translation.y;\n  return { x, y };\n};\n\nexport const getGlobalCSSVariable = (name: string) =>\n  getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);\n\nconst RS_LTR_CHARS =\n  \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\" +\n  \"\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RS_RTL_CHARS = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\n/**\n * Checks whether first directional character is RTL. Meaning whether it starts\n *  with RTL characters, or indeterminate (numbers etc.) characters followed by\n *  RTL.\n * See https://github.com/excalidraw/excalidraw/pull/1722#discussion_r436340171\n */\nexport const isRTL = (text: string) => RE_RTL_CHECK.test(text);\n\nexport const tupleToCoors = (\n  xyTuple: readonly [number, number],\n): { x: number; y: number } => {\n  const [x, y] = xyTuple;\n  return { x, y };\n};\n\n/** use as a rejectionHandler to mute filesystem Abort errors */\nexport const muteFSAbortError = (error?: Error) => {\n  if (error?.name === \"AbortError\") {\n    return;\n  }\n  throw error;\n};\n\nexport const findIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = 0,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length, Math.max(fromIndex, 0));\n  let index = fromIndex - 1;\n  while (++index < array.length) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const findLastIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = array.length - 1,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));\n  let index = fromIndex + 1;\n  while (--index > -1) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const isTransparent = (color: string) => {\n  const isRGBTransparent = color.length === 5 && color.substr(4, 1) === \"0\";\n  const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === \"00\";\n  return (\n    isRGBTransparent ||\n    isRRGGBBTransparent ||\n    color === colors.elementBackground[0]\n  );\n};\n\nexport type ResolvablePromise<T> = Promise<T> & {\n  resolve: [T] extends [undefined] ? (value?: T) => void : (value: T) => void;\n  reject: (error: Error) => void;\n};\nexport const resolvablePromise = <T>() => {\n  let resolve!: any;\n  let reject!: any;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  (promise as any).resolve = resolve;\n  (promise as any).reject = reject;\n  return promise as ResolvablePromise<T>;\n};\n\n/**\n * @param func handler taking at most single parameter (event).\n */\nexport const withBatchedUpdates = <\n  TFunction extends ((event: any) => void) | (() => void)\n>(\n  func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never,\n) =>\n  ((event) => {\n    unstable_batchedUpdates(func as TFunction, event);\n  }) as TFunction;\n\n//https://stackoverflow.com/a/9462382/8418\nexport const nFormatter = (num: number, digits: number): string => {\n  const si = [\n    { value: 1, symbol: \"b\" },\n    { value: 1e3, symbol: \"k\" },\n    { value: 1e6, symbol: \"M\" },\n    { value: 1e9, symbol: \"G\" },\n  ];\n  const rx = /\\.0+$|(\\.[0-9]*[1-9])0+$/;\n  let index;\n  for (index = si.length - 1; index > 0; index--) {\n    if (num >= si[index].value) {\n      break;\n    }\n  }\n  return (\n    (num / si[index].value).toFixed(digits).replace(rx, \"$1\") + si[index].symbol\n  );\n};\n\nexport const getVersion = () => {\n  return (\n    document.querySelector<HTMLMetaElement>('meta[name=\"version\"]')?.content ||\n    DEFAULT_VERSION\n  );\n};\n\n// Adapted from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/emoji.js\nexport const supportsEmoji = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return false;\n  }\n  const offset = 12;\n  ctx.fillStyle = \"#f00\";\n  ctx.textBaseline = \"top\";\n  ctx.font = \"32px Arial\";\n  // Modernizr used , but it is sort of supported on Windows 7.\n  // Luckily  isn't supported.\n  ctx.fillText(\"\", 0, 0);\n  return ctx.getImageData(offset, offset, 1, 1).data[0] !== 0;\n};\n","import oc from \"open-color\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n} from \"./constants\";\nimport { t } from \"./i18n\";\nimport { AppState, NormalizedZoomValue } from \"./types\";\nimport { getDateTime } from \"./utils\";\n\nexport const getDefaultAppState = (): Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\"\n> => {\n  return {\n    appearance: \"light\",\n    collaborators: new Map(),\n    currentChartType: \"bar\",\n    currentItemBackgroundColor: \"transparent\",\n    currentItemEndArrowhead: \"arrow\",\n    currentItemFillStyle: \"hachure\",\n    currentItemFontFamily: DEFAULT_FONT_FAMILY,\n    currentItemFontSize: DEFAULT_FONT_SIZE,\n    currentItemLinearStrokeSharpness: \"round\",\n    currentItemOpacity: 100,\n    currentItemRoughness: 1,\n    currentItemStartArrowhead: null,\n    currentItemStrokeColor: oc.black,\n    currentItemStrokeSharpness: \"sharp\",\n    currentItemStrokeStyle: \"solid\",\n    currentItemStrokeWidth: 1,\n    currentItemTextAlign: DEFAULT_TEXT_ALIGN,\n    cursorButton: \"up\",\n    draggingElement: null,\n    editingElement: null,\n    editingGroupId: null,\n    editingLinearElement: null,\n    elementLocked: false,\n    elementType: \"selection\",\n    errorMessage: null,\n    exportBackground: true,\n    exportEmbedScene: false,\n    fileHandle: null,\n    gridSize: null,\n    height: window.innerHeight,\n    isBindingEnabled: true,\n    isLibraryOpen: false,\n    isLoading: false,\n    isResizing: false,\n    isRotating: false,\n    lastPointerDownWith: \"mouse\",\n    multiElement: null,\n    name: `${t(\"labels.untitled\")}-${getDateTime()}`,\n    openMenu: null,\n    pasteDialog: { shown: false, data: null },\n    previousSelectedElementIds: {},\n    resizingElement: null,\n    scrolledOutside: false,\n    scrollX: 0,\n    scrollY: 0,\n    selectedElementIds: {},\n    selectedGroupIds: {},\n    selectionElement: null,\n    shouldAddWatermark: false,\n    shouldCacheIgnoreZoom: false,\n    showHelpDialog: false,\n    showStats: false,\n    startBoundElement: null,\n    suggestedBindings: [],\n    toastMessage: null,\n    viewBackgroundColor: oc.white,\n    width: window.innerWidth,\n    zenModeEnabled: false,\n    zoom: { value: 1 as NormalizedZoomValue, translation: { x: 0, y: 0 } },\n    viewModeEnabled: false,\n  };\n};\n\n/**\n * Config containing all AppState keys. Used to determine whether given state\n *  prop should be stripped when exporting to given storage type.\n */\nconst APP_STATE_STORAGE_CONF = (<\n  Values extends {\n    /** whether to keep when storing to browser storage (localStorage/IDB) */\n    browser: boolean;\n    /** whether to keep when exporting to file/database */\n    export: boolean;\n  },\n  T extends Record<keyof AppState, Values>\n>(\n  config: { [K in keyof T]: K extends keyof AppState ? T[K] : never },\n) => config)({\n  appearance: { browser: true, export: false },\n  collaborators: { browser: false, export: false },\n  currentChartType: { browser: true, export: false },\n  currentItemBackgroundColor: { browser: true, export: false },\n  currentItemEndArrowhead: { browser: true, export: false },\n  currentItemFillStyle: { browser: true, export: false },\n  currentItemFontFamily: { browser: true, export: false },\n  currentItemFontSize: { browser: true, export: false },\n  currentItemLinearStrokeSharpness: { browser: true, export: false },\n  currentItemOpacity: { browser: true, export: false },\n  currentItemRoughness: { browser: true, export: false },\n  currentItemStartArrowhead: { browser: true, export: false },\n  currentItemStrokeColor: { browser: true, export: false },\n  currentItemStrokeSharpness: { browser: true, export: false },\n  currentItemStrokeStyle: { browser: true, export: false },\n  currentItemStrokeWidth: { browser: true, export: false },\n  currentItemTextAlign: { browser: true, export: false },\n  cursorButton: { browser: true, export: false },\n  draggingElement: { browser: false, export: false },\n  editingElement: { browser: false, export: false },\n  editingGroupId: { browser: true, export: false },\n  editingLinearElement: { browser: false, export: false },\n  elementLocked: { browser: true, export: false },\n  elementType: { browser: true, export: false },\n  errorMessage: { browser: false, export: false },\n  exportBackground: { browser: true, export: false },\n  exportEmbedScene: { browser: true, export: false },\n  fileHandle: { browser: false, export: false },\n  gridSize: { browser: true, export: true },\n  height: { browser: false, export: false },\n  isBindingEnabled: { browser: false, export: false },\n  isLibraryOpen: { browser: false, export: false },\n  isLoading: { browser: false, export: false },\n  isResizing: { browser: false, export: false },\n  isRotating: { browser: false, export: false },\n  lastPointerDownWith: { browser: true, export: false },\n  multiElement: { browser: false, export: false },\n  name: { browser: true, export: false },\n  offsetLeft: { browser: false, export: false },\n  offsetTop: { browser: false, export: false },\n  openMenu: { browser: true, export: false },\n  pasteDialog: { browser: false, export: false },\n  previousSelectedElementIds: { browser: true, export: false },\n  resizingElement: { browser: false, export: false },\n  scrolledOutside: { browser: true, export: false },\n  scrollX: { browser: true, export: false },\n  scrollY: { browser: true, export: false },\n  selectedElementIds: { browser: true, export: false },\n  selectedGroupIds: { browser: true, export: false },\n  selectionElement: { browser: false, export: false },\n  shouldAddWatermark: { browser: true, export: false },\n  shouldCacheIgnoreZoom: { browser: true, export: false },\n  showHelpDialog: { browser: false, export: false },\n  showStats: { browser: true, export: false },\n  startBoundElement: { browser: false, export: false },\n  suggestedBindings: { browser: false, export: false },\n  toastMessage: { browser: false, export: false },\n  viewBackgroundColor: { browser: true, export: true },\n  width: { browser: false, export: false },\n  zenModeEnabled: { browser: true, export: false },\n  zoom: { browser: true, export: false },\n  viewModeEnabled: { browser: false, export: false },\n});\n\nconst _clearAppStateForStorage = <ExportType extends \"export\" | \"browser\">(\n  appState: Partial<AppState>,\n  exportType: ExportType,\n) => {\n  type ExportableKeys = {\n    [K in keyof typeof APP_STATE_STORAGE_CONF]: typeof APP_STATE_STORAGE_CONF[K][ExportType] extends true\n      ? K\n      : never;\n  }[keyof typeof APP_STATE_STORAGE_CONF];\n  const stateForExport = {} as { [K in ExportableKeys]?: typeof appState[K] };\n  for (const key of Object.keys(appState) as (keyof typeof appState)[]) {\n    const propConfig = APP_STATE_STORAGE_CONF[key];\n    if (propConfig?.[exportType]) {\n      // @ts-ignore see https://github.com/microsoft/TypeScript/issues/31445\n      stateForExport[key] = appState[key];\n    }\n  }\n  return stateForExport;\n};\n\nexport const clearAppStateForLocalStorage = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"browser\");\n};\n\nexport const cleanAppStateForExport = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"export\");\n};\n","import { useCallback, useState } from \"react\";\n\nexport const useCallbackRefState = <T>() => {\n  const [refValue, setRefValue] = useState<T | null>(null);\n  const refCallback = useCallback((value: T | null) => setRefValue(value), []);\n  return [refValue, refCallback] as const;\n};\n","import React, { useState, useEffect, useRef, useContext } from \"react\";\nimport variables from \"./css/variables.module.scss\";\n\nconst context = React.createContext(false);\n\nconst getIsMobileMatcher = () => {\n  return window.matchMedia\n    ? window.matchMedia(variables.isMobileQuery)\n    : (({\n        matches: false,\n        addListener: () => {},\n        removeListener: () => {},\n      } as any) as MediaQueryList);\n};\n\nexport const IsMobileProvider = ({\n  children,\n}: {\n  children: React.ReactNode;\n}) => {\n  const query = useRef<MediaQueryList>();\n  if (!query.current) {\n    query.current = getIsMobileMatcher();\n  }\n  const [isMobile, setMobile] = useState(query.current.matches);\n\n  useEffect(() => {\n    const handler = () => setMobile(query.current!.matches);\n    query.current!.addListener(handler);\n    return () => query.current!.removeListener(handler);\n  }, []);\n\n  return <context.Provider value={isMobile}>{children}</context.Provider>;\n};\n\nexport const isMobile = () => getIsMobileMatcher().matches;\n\nexport default function useIsMobile() {\n  return useContext(context);\n}\n","//\n// All icons are imported from https://fontawesome.com/icons?d=gallery\n// Icons are under the license https://fontawesome.com/license\n//\n\n// Note: when adding new icons, review https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/RTL_Guidelines\n// to determine whether or not the icons should be mirrored in right-to-left languages.\n\nimport React from \"react\";\n\nimport oc from \"open-color\";\nimport clsx from \"clsx\";\n\nconst activeElementColor = (appearance: \"light\" | \"dark\") =>\n  appearance === \"light\" ? oc.orange[4] : oc.orange[9];\nconst iconFillColor = (appearance: \"light\" | \"dark\") =>\n  appearance === \"light\" ? oc.black : oc.gray[4];\nconst handlerColor = (appearance: \"light\" | \"dark\") =>\n  appearance === \"light\" ? oc.white : \"#1e1e1e\";\n\ntype Opts = {\n  width?: number;\n  height?: number;\n  mirror?: true;\n} & React.SVGProps<SVGSVGElement>;\n\nconst createIcon = (d: string | React.ReactNode, opts: number | Opts = 512) => {\n  const { width = 512, height = width, mirror, style } =\n    typeof opts === \"number\" ? ({ width: opts } as Opts) : opts;\n  return (\n    <svg\n      aria-hidden=\"true\"\n      focusable=\"false\"\n      role=\"img\"\n      viewBox={`0 0 ${width} ${height}`}\n      className={clsx({ \"rtl-mirror\": mirror })}\n      style={style}\n    >\n      {typeof d === \"string\" ? <path fill=\"currentColor\" d={d} /> : d}\n    </svg>\n  );\n};\n\nexport const link = createIcon(\n  \"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\",\n  { mirror: true },\n);\n\nexport const save = createIcon(\n  \"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z\",\n  { width: 448, height: 512 },\n);\n\nexport const saveAs = createIcon(\n  \"M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z\",\n  { width: 448, height: 512 },\n);\n\nexport const load = createIcon(\n  \"M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const clipboard = createIcon(\n  \"M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z\",\n  { width: 384, height: 512 },\n);\n\nexport const trash = createIcon(\n  \"M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z\",\n  { width: 448, height: 512 },\n);\n\nexport const palette = createIcon(\n  \"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\",\n);\n\nexport const exportFile = createIcon(\n  \"M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const zoomIn = createIcon(\n  \"M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const zoomOut = createIcon(\n  \"M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const done = createIcon(\n  \"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z\",\n);\n\nexport const menu = createIcon(\n  \"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z\",\n);\n\nexport const undo = createIcon(\n  \"M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z\",\n  { mirror: true },\n);\n\nexport const redo = createIcon(\n  \"M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z\",\n  { mirror: true },\n);\n\nexport const questionCircle = createIcon(\n  \"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z\",\n  { mirror: true },\n);\n\n// Icon imported form Storybook\n// Storybook is licensed under MIT https://github.com/storybookjs/storybook/blob/next/LICENSE\nexport const resetZoom = createIcon(\n  <path\n    stroke=\"currentColor\"\n    strokeWidth=\"40\"\n    fill=\"currentColor\"\n    d=\"M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z\"\n  />,\n  { width: 1024 },\n);\n\nexport const BringForwardIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M22 9.556C22 8.696 21.303 8 20.444 8H16v8H8v4.444C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const SendBackwardIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M22 9.556C22 8.696 21.303 8 20.444 8H9.556C8.696 8 8 8.697 8 9.556v10.888C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const BringToFrontIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M13 21a1 1 0 001 1h7a1 1 0 001-1v-7a1 1 0 00-1-1h-3v5h-5v3zM11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h3V6h5V3z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const SendToBackIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeLinejoin=\"round\"\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h8V3zM22 14a1 1 0 00-1-1h-7a1 1 0 00-1 1v7a1 1 0 001 1h8v-8z\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeLinejoin=\"round\"\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\n//\n// Align action icons created from scratch to match those of z-index actions\n// Note: vertical align icons are flipped so the larger item is always the\n// first one the user sees. Horizontal align icons should not be flipped since\n// that would make them lie about their function.\n//\nexport const AlignTopIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 2,5 H 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M 6,7 C 5.446,7 5,7.446 5,8 v 9.999992 c 0,0.554 0.446,1 1,1 h 3.0000001 c 0.554,0 0.9999999,-0.446 0.9999999,-1 V 8 C 10,7.446 9.5540001,7 9.0000001,7 Z m 9,0 c -0.554,0 -1,0.446 -1,1 v 5.999992 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 V 8 C 19,7.446 18.554,7 18,7 Z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const AlignBottomIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 2,19 H 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 6,16.999992 c -0.554,0 -1,-0.446 -1,-1 V 6 C 5,5.446 5.446,5 6,5 H 9.0000001 C 9.5540001,5 10,5.446 10,6 v 9.999992 c 0,0.554 -0.4459999,1 -0.9999999,1 z m 9,0 c -0.554,0 -1,-0.446 -1,-1 V 10 c 0,-0.554 0.446,-1 1,-1 h 3 c 0.554,0 1,0.446 1,1 v 5.999992 c 0,0.554 -0.446,1 -1,1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const AlignLeftIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 5,2 V 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 7.000004,5.999996 c 0,-0.554 0.446,-1 1,-1 h 9.999992 c 0.554,0 1,0.446 1,1 v 3.0000001 c 0,0.554 -0.446,0.9999999 -1,0.9999999 H 8.000004 c -0.554,0 -1,-0.4459999 -1,-0.9999999 z m 0,9 c 0,-0.554 0.446,-1 1,-1 h 5.999992 c 0.554,0 1,0.446 1,1 v 3 c 0,0.554 -0.446,1 -1,1 H 8.000004 c -0.554,0 -1,-0.446 -1,-1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const AlignRightIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 19,2 V 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 16.999996,5.999996 c 0,-0.554 -0.446,-1 -1,-1 H 6.000004 c -0.554,0 -1,0.446 -1,1 v 3.0000001 c 0,0.554 0.446,0.9999999 1,0.9999999 h 9.999992 c 0.554,0 1,-0.4459999 1,-0.9999999 z m 0,9 c 0,-0.554 -0.446,-1 -1,-1 h -5.999992 c -0.554,0 -1,0.446 -1,1 v 3 c 0,0.554 0.446,1 1,1 h 5.999992 c 0.554,0 1,-0.446 1,-1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const DistributeHorizontallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M5 5V19Z\" fill=\"black\" />\n        <path\n          d=\"M19 5V19M5 5V19\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\n<svg\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n></svg>;\n\nexport const DistributeVerticallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M5 5L19 5M5 19H19\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const CenterVerticallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"m 5.000004,16.999996 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -10 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z m 9,-2 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -6 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z\"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 2,12 H 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const CenterHorizontallyIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 7 5 C 6.446 5 6 5.446 6 6 L 6 9 C 6 9.554 6.446 10 7 10 L 17 10 C 17.554 10 18 9.554 18 9 L 18 6 C 18 5.446 17.554 5 17 5 L 7 5 z M 9 14 C 8.446 14 8 14.446 8 15 L 8 18 C 8 18.554 8.446 19 9 19 L 15 19 C 15.554 19 16 18.554 16 18 L 16 15 C 16 14.446 15.554 14 15 14 L 9 14 z \"\n          fill={activeElementColor(appearance)}\n          stroke={activeElementColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 12,2 V 22\"\n          fill={iconFillColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const users = createIcon(\n  \"M192 256c61.9 0 112-50.1 112-112S253.9 32 192 32 80 82.1 80 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C51.6 288 0 339.6 0 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zM480 256c53 0 96-43 96-96s-43-96-96-96-96 43-96 96 43 96 96 96zm48 32h-3.8c-13.9 4.8-28.6 8-44.2 8s-30.3-3.2-44.2-8H432c-20.4 0-39.2 5.9-55.7 15.4 24.4 26.3 39.7 61.2 39.7 99.8v38.4c0 2.2-.5 4.3-.6 6.4H592c26.5 0 48-21.5 48-48 0-61.9-50.1-112-112-112z\",\n  { width: 640, height: 512, mirror: true },\n);\n\n// not mirrored because it's inspired by a playback control, which is always RTL\nexport const start = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z\",\n);\n\nexport const stop = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z\",\n);\n\nexport const close = createIcon(\n  \"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z\",\n  { width: 352, height: 512 },\n);\n\nexport const back = createIcon(\n  \"M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z\",\n  { width: 320, height: 512, style: { marginLeft: \"-0.2rem\" }, mirror: true },\n);\n\nexport const clone = createIcon(\n  \"M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z\",\n  { mirror: true },\n);\n\n// modified https://feathericons.com/?query=shield\nexport const shield = createIcon(\n  \"M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z\",\n  { width: 24 },\n);\n\nexport const GroupIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M25 26H111V111H25\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path d=\"M100 100H160V160H100\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n      </>,\n      { width: 182, height: 182, mirror: true },\n    ),\n);\n\nexport const UngroupIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M25 26H111V111H25\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <path d=\"M100 100H160V160H100\" fill={iconFillColor(appearance)} />\n        <path\n          d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"2\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"78.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"149.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"147.5\"\n          y=\"78.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"105.5\"\n          y=\"2.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n        <rect\n          x=\"2.5\"\n          y=\"102.5\"\n          width=\"30\"\n          height=\"30\"\n          fill={handlerColor(appearance)}\n          stroke={iconFillColor(appearance)}\n          strokeWidth=\"6\"\n        />\n      </>,\n      { width: 182, height: 182, mirror: true },\n    ),\n);\n\nexport const FillHachureIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\"\n        fill={iconFillColor(appearance)}\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FillCrossHatchIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <g fill={iconFillColor(appearance)} fillRule=\"evenodd\" clipRule=\"evenodd\">\n        <path d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\" />\n        <path d=\"M14.0001 18L3.00006 4.00002L4.5727 2.76438L15.5727 16.7644L14.0001 18ZM25.0001 18L14.0001 4.00002L15.5727 2.76438L26.5727 16.7644L25.0001 18ZM36.0001 18L25.0001 4.00002L26.5727 2.76438L37.5727 16.7644L36.0001 18Z\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FillSolidIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(<path d=\"M2 2H38V18H2V2Z\" fill={iconFillColor(appearance)} />, {\n      width: 40,\n      height: 20,\n    }),\n);\n\nexport const StrokeWidthIcon = React.memo(\n  ({\n    appearance,\n    strokeWidth,\n  }: {\n    appearance: \"light\" | \"dark\";\n    strokeWidth: number;\n  }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={strokeWidth}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleSolidIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      {\n        width: 40,\n        height: 20,\n      },\n    ),\n);\n\nexport const StrokeStyleDashedIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2.5}\n        strokeDasharray={\"10, 8\"}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleDottedIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2.5}\n        strokeDasharray={\"4, 4\"}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const SloppinessArchitectIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3.00098 16.1691C6.28774 13.9744 19.6399 2.8905 22.7215 3.00082C25.8041 3.11113 19.1158 15.5488 21.4962 16.8309C23.8757 18.1131 34.4155 11.7148 37.0001 10.6919\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessArtistIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3 17C6.68158 14.8752 16.1296 9.09849 22.0648 6.54922C28 3.99995 22.2896 13.3209 25 14C27.7104 14.6791 36.3757 9.6471 36.3757 9.6471M6.40706 15C13 11.1918 20.0468 1.51045 23.0234 3.0052C26 4.49995 20.457 12.8659 22.7285 16.4329C25 20 36.3757 13 36.3757 13\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessCartoonistIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3 15.6468C6.93692 13.5378 22.5544 2.81528 26.6206 3.00242C30.6877 3.18956 25.6708 15.3346 27.4009 16.7705C29.1309 18.2055 35.4001 12.4762 37 11.6177M3.97143 10.4917C6.61158 9.24563 16.3706 2.61886 19.8104 3.01724C23.2522 3.41472 22.0773 12.2013 24.6181 12.8783C27.1598 13.5536 33.3179 8.04068 35.0571 7.07244\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeSharpIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M10 17L10 5L35 5\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeRoundIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M10 17V15C10 8 13 5 21 5L33.5 5\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const ArrowheadNoneIcon = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      {\n        width: 40,\n        height: 20,\n      },\n    ),\n);\n\nexport const ArrowheadArrowIcon = React.memo(\n  ({\n    appearance,\n    flip = false,\n  }: {\n    appearance: \"light\" | \"dark\";\n    flip?: boolean;\n  }) =>\n    createIcon(\n      <g\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        stroke={iconFillColor(appearance)}\n        strokeWidth={2}\n        fill=\"none\"\n      >\n        <path d=\"M34 10H6M34 10L27 5M34 10L27 15\" />\n        <path d=\"M27.5 5L34.5 10L27.5 15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadDotIcon = React.memo(\n  ({\n    appearance,\n    flip = false,\n  }: {\n    appearance: \"light\" | \"dark\";\n    flip?: boolean;\n  }) =>\n    createIcon(\n      <g\n        stroke={iconFillColor(appearance)}\n        fill={iconFillColor(appearance)}\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <circle r=\"4\" transform=\"matrix(-1 0 0 1 30 10)\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadBarIcon = React.memo(\n  ({\n    appearance,\n    flip = false,\n  }: {\n    appearance: \"light\" | \"dark\";\n    flip?: boolean;\n  }) =>\n    createIcon(\n      <g transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}>\n        <path\n          d=\"M34 10H5.99996M34 10L34 5M34 10L34 15\"\n          stroke={iconFillColor(appearance)}\n          strokeWidth={2}\n          fill=\"none\"\n        />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n","import \"./Island.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype IslandProps = {\n  children: React.ReactNode;\n  padding?: number;\n  className?: string | boolean;\n  style?: object;\n};\n\nexport const Island = React.forwardRef<HTMLDivElement, IslandProps>(\n  ({ children, padding, className, style }, ref) => (\n    <div\n      className={clsx(\"Island\", className)}\n      style={{ \"--padding\": padding, ...style }}\n      ref={ref}\n    >\n      {children}\n    </div>\n  ),\n);\n","import \"./Modal.scss\";\n\nimport React, { useState, useLayoutEffect } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport clsx from \"clsx\";\nimport { KEYS } from \"../keys\";\n\nexport const Modal = (props: {\n  className?: string;\n  children: React.ReactNode;\n  maxWidth?: number;\n  onCloseRequest(): void;\n  labelledBy: string;\n}) => {\n  const modalRoot = useBodyRoot();\n\n  if (!modalRoot) {\n    return null;\n  }\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.ESCAPE) {\n      event.nativeEvent.stopImmediatePropagation();\n      props.onCloseRequest();\n    }\n  };\n\n  return createPortal(\n    <div\n      className={clsx(\"Modal\", props.className)}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      onKeyDown={handleKeydown}\n      aria-labelledby={props.labelledBy}\n    >\n      <div className=\"Modal__background\" onClick={props.onCloseRequest}></div>\n      <div\n        className=\"Modal__content\"\n        style={{ \"--max-width\": `${props.maxWidth}px` }}\n      >\n        {props.children}\n      </div>\n    </div>,\n    modalRoot,\n  );\n};\n\nconst useBodyRoot = () => {\n  const [div, setDiv] = useState<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const isDarkTheme = !!document\n      .querySelector(\".excalidraw\")\n      ?.classList.contains(\"Appearance_dark\");\n    const div = document.createElement(\"div\");\n\n    div.classList.add(\"excalidraw\");\n\n    if (isDarkTheme) {\n      div.classList.add(\"Appearance_dark\");\n      div.classList.add(\"Appearance_dark-background-none\");\n    }\n    document.body.appendChild(div);\n\n    setDiv(div);\n\n    return () => {\n      document.body.removeChild(div);\n    };\n  }, []);\n\n  return div;\n};\n","import clsx from \"clsx\";\nimport React, { useEffect } from \"react\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { KEYS } from \"../keys\";\nimport \"./Dialog.scss\";\nimport { back, close } from \"./icons\";\nimport { Island } from \"./Island\";\nimport { Modal } from \"./Modal\";\n\nexport const Dialog = (props: {\n  children: React.ReactNode;\n  className?: string;\n  small?: boolean;\n  onCloseRequest(): void;\n  title: React.ReactNode;\n  autofocus?: boolean;\n}) => {\n  const [islandNode, setIslandNode] = useCallbackRefState<HTMLDivElement>();\n\n  useEffect(() => {\n    if (!islandNode) {\n      return;\n    }\n\n    const focusableElements = queryFocusableElements(islandNode);\n\n    if (focusableElements.length > 0 && props.autofocus !== false) {\n      // If there's an element other than close, focus it.\n      (focusableElements[1] || focusableElements[0]).focus();\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(islandNode);\n        const { activeElement } = document;\n        const currentIndex = focusableElements.findIndex(\n          (element) => element === activeElement,\n        );\n\n        if (currentIndex === 0 && event.shiftKey) {\n          focusableElements[focusableElements.length - 1].focus();\n          event.preventDefault();\n        } else if (\n          currentIndex === focusableElements.length - 1 &&\n          !event.shiftKey\n        ) {\n          focusableElements[0].focus();\n          event.preventDefault();\n        }\n      }\n    };\n\n    islandNode.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => islandNode.removeEventListener(\"keydown\", handleKeyDown);\n  }, [islandNode, props.autofocus]);\n\n  const queryFocusableElements = (node: HTMLElement) => {\n    const focusableElements = node.querySelectorAll<HTMLElement>(\n      \"button, a, input, select, textarea, div[tabindex]\",\n    );\n\n    return focusableElements ? Array.from(focusableElements) : [];\n  };\n\n  return (\n    <Modal\n      className={clsx(\"Dialog\", props.className)}\n      labelledBy=\"dialog-title\"\n      maxWidth={props.small ? 550 : 800}\n      onCloseRequest={props.onCloseRequest}\n    >\n      <Island ref={setIslandNode}>\n        <h2 id=\"dialog-title\" className=\"Dialog__title\">\n          <span className=\"Dialog__titleContent\">{props.title}</span>\n          <button\n            className=\"Modal__close\"\n            onClick={props.onCloseRequest}\n            aria-label={t(\"buttons.close\")}\n          >\n            {useIsMobile() ? back : close}\n          </button>\n        </h2>\n        <div className=\"Dialog__content\">{props.children}</div>\n      </Island>\n    </Modal>\n  );\n};\n","import React, { useState } from \"react\";\nimport { t } from \"../i18n\";\n\nimport { Dialog } from \"./Dialog\";\n\nexport const ErrorDialog = ({\n  message,\n  onClose,\n}: {\n  message: string;\n  onClose?: () => void;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(!!message);\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  return (\n    <>\n      {modalIsShown && (\n        <Dialog\n          small\n          onCloseRequest={handleClose}\n          title={t(\"errorDialog.title\")}\n        >\n          <div>\n            {message.split(\"\\n\").map((line) => (\n              <>\n                {line}\n                <br />\n              </>\n            ))}\n          </div>\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import React from \"react\";\nimport * as Sentry from \"@sentry/browser\";\nimport { resetCursor } from \"../utils\";\nimport { t } from \"../i18n\";\n\ninterface TopErrorBoundaryState {\n  hasError: boolean;\n  sentryEventId: string;\n  localStorage: string;\n}\n\nexport class TopErrorBoundary extends React.Component<\n  any,\n  TopErrorBoundaryState\n> {\n  state: TopErrorBoundaryState = {\n    hasError: false,\n    sentryEventId: \"\",\n    localStorage: \"\",\n  };\n\n  render() {\n    return this.state.hasError ? this.errorSplash() : this.props.children;\n  }\n\n  componentDidCatch(error: Error, errorInfo: any) {\n    resetCursor();\n    const _localStorage: any = {};\n    for (const [key, value] of Object.entries({ ...localStorage })) {\n      try {\n        _localStorage[key] = JSON.parse(value);\n      } catch (error) {\n        _localStorage[key] = value;\n      }\n    }\n\n    Sentry.withScope((scope) => {\n      scope.setExtras(errorInfo);\n      const eventId = Sentry.captureException(error);\n\n      this.setState((state) => ({\n        hasError: true,\n        sentryEventId: eventId,\n        localStorage: JSON.stringify(_localStorage),\n      }));\n    });\n  }\n\n  private selectTextArea(event: React.MouseEvent<HTMLTextAreaElement>) {\n    if (event.target !== document.activeElement) {\n      event.preventDefault();\n      (event.target as HTMLTextAreaElement).select();\n    }\n  }\n\n  private async createGithubIssue() {\n    let body = \"\";\n    try {\n      const templateStrFn = (\n        await import(\n          /* webpackChunkName: \"bug-issue-template\" */ \"../bug-issue-template\"\n        )\n      ).default;\n      body = encodeURIComponent(templateStrFn(this.state.sentryEventId));\n    } catch (error) {\n      console.error(error);\n    }\n\n    window.open(\n      `https://github.com/excalidraw/excalidraw/issues/new?body=${body}`,\n    );\n  }\n\n  private errorSplash() {\n    return (\n      <div className=\"ErrorSplash excalidraw\">\n        <div className=\"ErrorSplash-messageContainer\">\n          <div className=\"ErrorSplash-paragraph bigger align-center\">\n            {t(\"errorSplash.headingMain_pre\")}\n            <button onClick={() => window.location.reload()}>\n              {t(\"errorSplash.headingMain_button\")}\n            </button>\n          </div>\n          <div className=\"ErrorSplash-paragraph align-center\">\n            {t(\"errorSplash.clearCanvasMessage\")}\n            <button\n              onClick={() => {\n                try {\n                  localStorage.clear();\n                  window.location.reload();\n                } catch (error) {\n                  console.error(error);\n                }\n              }}\n            >\n              {t(\"errorSplash.clearCanvasMessage_button\")}\n            </button>\n            <br />\n            <div className=\"smaller\">\n              <span role=\"img\" aria-label=\"warning\">\n                \n              </span>\n              {t(\"errorSplash.clearCanvasCaveat\")}\n              <span role=\"img\" aria-hidden=\"true\">\n                \n              </span>\n            </div>\n          </div>\n          <div>\n            <div className=\"ErrorSplash-paragraph\">\n              {t(\"errorSplash.trackedToSentry_pre\")}\n              {this.state.sentryEventId}\n              {t(\"errorSplash.trackedToSentry_post\")}\n            </div>\n            <div className=\"ErrorSplash-paragraph\">\n              {t(\"errorSplash.openIssueMessage_pre\")}\n              <button onClick={() => this.createGithubIssue()}>\n                {t(\"errorSplash.openIssueMessage_button\")}\n              </button>\n              {t(\"errorSplash.openIssueMessage_post\")}\n            </div>\n            <div className=\"ErrorSplash-paragraph\">\n              <div className=\"ErrorSplash-details\">\n                <label>{t(\"errorSplash.sceneContent\")}</label>\n                <textarea\n                  rows={5}\n                  onPointerDown={this.selectTextArea}\n                  readOnly={true}\n                  value={this.state.localStorage}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport { t } from \"../i18n\";\n\nexport const LoadingMessage = () => {\n  // !! KEEP THIS IN SYNC WITH index.html !!\n  return (\n    <div className=\"LoadingMessage\">\n      <span>{t(\"labels.loadingScene\")}</span>\n    </div>\n  );\n};\n","import React from \"react\";\n\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport {\n  defaultLang,\n  Language,\n  languages,\n  setLanguageFirstTime,\n} from \"../i18n\";\n\ninterface Props {\n  langCode: Language[\"code\"];\n}\ninterface State {\n  isLoading: boolean;\n}\nexport class InitializeApp extends React.Component<Props, State> {\n  public state: { isLoading: boolean } = {\n    isLoading: true,\n  };\n\n  async componentDidMount() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguageFirstTime(currentLang);\n    this.setState({\n      isLoading: false,\n    });\n  }\n\n  public render() {\n    return this.state.isLoading ? <LoadingMessage /> : this.props.children;\n  }\n}\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawGenericElement,\n} from \"./types\";\n\nexport const isGenericElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawGenericElement => {\n  return (\n    element != null &&\n    (element.type === \"selection\" ||\n      element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\")\n  );\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLinearElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" || elementType === \"draw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isBindingElementType(element.type);\n};\n\nexport const isBindingElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"text\")\n  );\n};\n\nexport const isExcalidrawElement = (element: any): boolean => {\n  return (\n    element?.type === \"text\" ||\n    element?.type === \"diamond\" ||\n    element?.type === \"rectangle\" ||\n    element?.type === \"ellipse\" ||\n    element?.type === \"arrow\" ||\n    element?.type === \"draw\" ||\n    element?.type === \"line\"\n  );\n};\n","import { Point } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // =()cos()sin+\n  // =()sin+()cos+.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n): boolean => {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return (\n      distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <=\n      LINE_CONFIRM_THRESHOLD\n    );\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nconst isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n","import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n","import { ExcalidrawElement, ExcalidrawLinearElement, Arrowhead } from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [number, number, number, number];\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): Bounds => {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  const length = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the whole length of the\n  // arrowhead instead of last segment of the arrowhead.\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2);\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!isLinearElement(element)) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  const gen = rough.generator();\n  const curve =\n    element.strokeSharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    sharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  Arrowhead,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { isTextElement, isLinearElement } from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getArrowheadPoints,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  SVG_NS,\n  distance,\n  getFontString,\n  getFontFamilyString,\n  isRTL,\n} from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Zoom } from \"../types\";\nimport { getDefaultAppState } from \"../appState\";\n\nconst defaultAppState = getDefaultAppState();\n\nconst CANVAS_PADDING = 20;\n\nconst DASHARRAY_DASHED = [12, 8];\nconst DASHARRAY_DOTTED = [3, 6];\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: Zoom[\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element)) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom.value +\n      CANVAS_PADDING * zoom.value * 2;\n  }\n\n  context.translate(CANVAS_PADDING * zoom.value, CANVAS_PADDING * zoom.value);\n\n  context.scale(\n    window.devicePixelRatio * zoom.value,\n    window.devicePixelRatio * zoom.value,\n  );\n\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(\n    -(CANVAS_PADDING * zoom.value),\n    -(CANVAS_PADDING * zoom.value),\n  );\n  context.scale(\n    1 / (window.devicePixelRatio * zoom.value),\n    1 / (window.devicePixelRatio * zoom.value),\n  );\n  return {\n    element,\n    canvas,\n    canvasZoom: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n  };\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"draw\":\n    case \"line\": {\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        const font = context.font;\n        context.font = getFontString(element);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            (index + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (element: ExcalidrawElement): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? DASHARRAY_DASHED\n        : element.strokeStyle === \"dotted\"\n        ? DASHARRAY_DOTTED\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"draw\": {\n      // If shape is a line and is a closed shape,\n      // fill the shape if a color is set.\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        if (element.strokeSharpness === \"round\") {\n          const w = element.width;\n          const h = element.height;\n          const r = Math.min(w, h) * 0.25;\n          shape = generator.path(\n            `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n              h - r\n            } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n              h - r\n            } L 0 ${r} Q 0 0, ${r} 0`,\n            generateRoughOptions(element),\n          );\n        } else {\n          shape = generator.rectangle(\n            0,\n            0,\n            element.width,\n            element.height,\n            generateRoughOptions(element),\n          );\n        }\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"draw\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (element.strokeSharpness === \"sharp\") {\n          if (options.fill) {\n            shape = [generator.polygon(points as [number, number][], options)];\n          } else {\n            shape = [\n              generator.linearPath(points as [number, number][], options),\n            ];\n          }\n        } else {\n          shape = [generator.curve(points as [number, number][], options)];\n        }\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n          function getArrowheadShapes(\n            element: ExcalidrawLinearElement,\n            shape: Drawable[],\n            position: \"start\" | \"end\",\n            arrowhead: Arrowhead,\n          ) {\n            const arrowheadPoints = getArrowheadPoints(\n              element,\n              shape,\n              position,\n              arrowhead,\n            );\n\n            if (arrowheadPoints === null) {\n              return [];\n            }\n\n            // Other arrowheads here...\n            if (arrowhead === \"dot\") {\n              const [x, y, r] = arrowheadPoints;\n\n              return [\n                generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                }),\n              ];\n            }\n\n            // Arrow arrowheads\n            const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n            if (element.strokeStyle === \"dotted\") {\n              // for dotted arrows caps, reduce gap to make it more legible\n              options.strokeLineDash = [3, 4];\n            } else {\n              // for solid/dashed, keep solid arrow cap\n              delete options.strokeLineDash;\n            }\n            return [\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ];\n          }\n\n          if (startArrowhead !== null) {\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"start\",\n              startArrowhead,\n            );\n            shape.push(...shapes);\n          }\n\n          if (endArrowhead !== null) {\n            if (endArrowhead === undefined) {\n              // Hey, we have an old arrow here!\n            }\n\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"end\",\n              endArrowhead,\n            );\n            shape.push(...shapes);\n          }\n        }\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState?: SceneState,\n) => {\n  const zoom: Zoom = sceneState ? sceneState.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom.value &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      (CANVAS_PADDING * elementWithCanvas.canvasZoom) /\n        elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      (CANVAS_PADDING * elementWithCanvas.canvasZoom) /\n        elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"draw\":\n    case \"arrow\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"draw\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          (element.type === \"line\" || element.type === \"draw\") &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getNonDeletedElements, isNonDeletedElement } from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n\n  // TODO: getAllElementsIncludingDeleted\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  // TODO: getAllNonDeletedElements\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  // TODO: Rename methods here, this is confusing\n  getNonDeletedElements(\n    ids: readonly ExcalidrawElement[\"id\"][],\n  ): NonDeleted<ExcalidrawElement>[] {\n    const result: NonDeleted<ExcalidrawElement>[] = [];\n    ids.forEach((id) => {\n      const element = this.getNonDeletedElement(id);\n      if (element != null) {\n        result.push(element);\n      }\n    });\n    return result;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n}\n\nexport default Scene;\n","import { Random } from \"roughjs/bin/math\";\nimport { nanoid } from \"nanoid\";\n\nlet random = new Random(Date.now());\nlet testIdBase = 0;\n\nexport const randomInteger = () => Math.floor(random.next() * 2 ** 31);\n\nexport const reseed = (seed: number) => {\n  random = new Random(seed);\n  testIdBase = 0;\n};\n\nexport const randomId = () =>\n  process.env.NODE_ENV === \"test\" ? `id${testIdBase++}` : nanoid();\n","import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint: Point = prevPoints[index];\n            const nextPoint: Point = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  Scene.getScene(element)?.informMutation();\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => ({\n  ...element,\n  ...updates,\n  version: element.version + 1,\n  versionNonce: randomInteger(),\n});\n","import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"draw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n","import { GroupId, ExcalidrawElement, NonDeleted } from \"./element/types\";\nimport { AppState } from \"./types\";\nimport { getSelectedElements } from \"./scene\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  const elementsInGroup = elements.filter((element) =>\n    element.groupIds.includes(groupId),\n  );\n\n  if (elementsInGroup.length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(\n        elementsInGroup.map((element) => [element.id, true]),\n      ),\n    },\n  };\n};\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (appState: AppState): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport const selectGroupsForSelectedElements = (\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  let nextAppState = { ...appState };\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: readonly ExcalidrawElement[],\n  groupId: string,\n) => elements.filter((element) => isElementInGroup(element, groupId));\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  FontFamily,\n  GroupId,\n  VerticalAlign,\n  Arrowhead,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"boundElementIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    strokeSharpness,\n    boundElementIds = null,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  strokeSharpness,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n  boundElementIds,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamily;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n  const { textAlign, verticalAlign } = element;\n\n  let x: number;\n  let y: number;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points?: ExcalidrawLinearElement[\"points\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n// (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  copy.id = process.env.NODE_ENV === \"test\" ? `${copy.id}_copy` : randomId();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n","import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords, Bounds } from \"./bounds\";\nimport { rotate } from \"../math\";\nimport { Zoom } from \"../types\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = [number, number, number, number];\nexport type TransformHandles = Partial<\n  { [T in TransformHandleType]: TransformHandle }\n>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  ne: true,\n  sw: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): TransformHandle => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2]: Bounds,\n  angle: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  const dashedLineMargin = 4 / zoom.value;\n\n  const centeringOffset = (size - 8) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  pointerType: PointerType = \"mouse\",\n): TransformHandles => {\n  let omitSides: { [T in TransformHandleType]?: boolean } = {};\n  if (\n    element.type === \"arrow\" ||\n    element.type === \"line\" ||\n    element.type === \"draw\"\n  ) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (element.type === \"text\") {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  }\n\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n  );\n};\n","/**\n * This is a 2D Projective Geometric Algebra implementation.\n *\n * For wider context on geometric algebra visit see https://bivector.net.\n *\n * For this specific algebra see cheatsheet https://bivector.net/2DPGA.pdf.\n *\n * Converted from generator written by enki, with a ton of added on top.\n *\n * This library uses 8-vectors to represent points, directions and lines\n * in 2D space.\n *\n * An array `[a, b, c, d, e, f, g, h]` represents a n(8)vector:\n *   a + b*e0 + c*e1 + d*e2 + e*e01 + f*e20 + g*e12 + h*e012\n *\n * See GAPoint, GALine, GADirection and GATransform modules for common\n * operations.\n */\n\nexport type Point = NVector;\nexport type Direction = NVector;\nexport type Line = NVector;\nexport type Transform = NVector;\n\nexport const point = (x: number, y: number): Point => [0, 0, 0, 0, y, x, 1, 0];\n\nexport const origin = (): Point => [0, 0, 0, 0, 0, 0, 1, 0];\n\nexport const direction = (x: number, y: number): Direction => {\n  const norm = Math.hypot(x, y); // same as `inorm(direction(x, y))`\n  return [0, 0, 0, 0, y / norm, x / norm, 0, 0];\n};\n\nexport const offset = (x: number, y: number): Direction => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  0,\n  0,\n];\n\n/// This is the \"implementation\" part of the library\n\ntype NVector = readonly [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n];\n\n// These are labels for what each number in an nvector represents\nconst NVECTOR_BASE = [\"1\", \"e0\", \"e1\", \"e2\", \"e01\", \"e20\", \"e12\", \"e012\"];\n\n// Used to represent points, lines and transformations\nexport const nvector = (value: number = 0, index: number = 0): NVector => {\n  const result = [0, 0, 0, 0, 0, 0, 0, 0];\n  if (index < 0 || index > 7) {\n    throw new Error(`Expected \\`index\\` betwen 0 and 7, got \\`${index}\\``);\n  }\n  if (value !== 0) {\n    result[index] = value;\n  }\n  return (result as unknown) as NVector;\n};\n\nconst STRING_EPSILON = 0.000001;\nexport const toString = (nvector: NVector): string => {\n  const result = nvector\n    .map((value, index) =>\n      Math.abs(value) > STRING_EPSILON\n        ? value.toFixed(7).replace(/(\\.|0+)$/, \"\") +\n          (index > 0 ? NVECTOR_BASE[index] : \"\")\n        : null,\n    )\n    .filter((representation) => representation != null)\n    .join(\" + \");\n  return result === \"\" ? \"0\" : result;\n};\n\n// Reverse the order of the basis blades.\nexport const reverse = (nvector: NVector): NVector => [\n  nvector[0],\n  nvector[1],\n  nvector[2],\n  nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  -nvector[7],\n];\n\n// Poincare duality operator.\nexport const dual = (nvector: NVector): NVector => [\n  nvector[7],\n  nvector[6],\n  nvector[5],\n  nvector[4],\n  nvector[3],\n  nvector[2],\n  nvector[1],\n  nvector[0],\n];\n\n// Clifford Conjugation\nexport const conjugate = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  nvector[7],\n];\n\n// Main involution\nexport const involute = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  nvector[4],\n  nvector[5],\n  nvector[6],\n  -nvector[7],\n];\n\n// Multivector addition\nexport const add = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] + b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] + b[0],\n    a[1] + b[1],\n    a[2] + b[2],\n    a[3] + b[3],\n    a[4] + b[4],\n    a[5] + b[5],\n    a[6] + b[6],\n    a[7] + b[7],\n  ];\n};\n\n// Multivector subtraction\nexport const sub = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] - b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] - b[0],\n    a[1] - b[1],\n    a[2] - b[2],\n    a[3] - b[3],\n    a[4] - b[4],\n    a[5] - b[5],\n    a[6] - b[6],\n    a[7] - b[7],\n  ];\n};\n\n// The geometric product.\nexport const mul = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [\n      a[0] * b,\n      a[1] * b,\n      a[2] * b,\n      a[3] * b,\n      a[4] * b,\n      a[5] * b,\n      a[6] * b,\n      a[7] * b,\n    ];\n  }\n  return [\n    mulScalar(a, b),\n    b[1] * a[0] +\n      b[0] * a[1] -\n      b[4] * a[2] +\n      b[5] * a[3] +\n      b[2] * a[4] -\n      b[3] * a[5] -\n      b[7] * a[6] -\n      b[6] * a[7],\n    b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n    b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n    b[4] * a[0] +\n      b[2] * a[1] -\n      b[1] * a[2] +\n      b[7] * a[3] +\n      b[0] * a[4] +\n      b[6] * a[5] -\n      b[5] * a[6] +\n      b[3] * a[7],\n    b[5] * a[0] -\n      b[3] * a[1] +\n      b[7] * a[2] +\n      b[1] * a[3] -\n      b[6] * a[4] +\n      b[0] * a[5] +\n      b[4] * a[6] +\n      b[2] * a[7],\n    b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n    b[7] * a[0] +\n      b[6] * a[1] +\n      b[5] * a[2] +\n      b[4] * a[3] +\n      b[3] * a[4] +\n      b[2] * a[5] +\n      b[1] * a[6] +\n      b[0] * a[7],\n  ];\n};\n\nexport const mulScalar = (a: NVector, b: NVector): number =>\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6];\n\n// The outer/exterior/wedge product.\nexport const meet = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0],\n  b[1] * a[0] + b[0] * a[1],\n  b[2] * a[0] + b[0] * a[2],\n  b[3] * a[0] + b[0] * a[3],\n  b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[0] * a[4],\n  b[5] * a[0] - b[3] * a[1] + b[1] * a[3] + b[0] * a[5],\n  b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n  b[7] * a[0] +\n    b[6] * a[1] +\n    b[5] * a[2] +\n    b[4] * a[3] +\n    b[3] * a[4] +\n    b[2] * a[5] +\n    b[1] * a[6],\n];\n\n// The regressive product.\nexport const join = (a: NVector, b: NVector): NVector => [\n  joinScalar(a, b),\n  a[1] * b[7] + a[4] * b[5] - a[5] * b[4] + a[7] * b[1],\n  a[2] * b[7] - a[4] * b[6] + a[6] * b[4] + a[7] * b[2],\n  a[3] * b[7] + a[5] * b[6] - a[6] * b[5] + a[7] * b[3],\n  a[4] * b[7] + a[7] * b[4],\n  a[5] * b[7] + a[7] * b[5],\n  a[6] * b[7] + a[7] * b[6],\n  a[7] * b[7],\n];\n\nexport const joinScalar = (a: NVector, b: NVector): number =>\n  a[0] * b[7] +\n  a[1] * b[6] +\n  a[2] * b[5] +\n  a[3] * b[4] +\n  a[4] * b[3] +\n  a[5] * b[2] +\n  a[6] * b[1] +\n  a[7] * b[0];\n\n// The inner product.\nexport const dot = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6],\n  b[1] * a[0] +\n    b[0] * a[1] -\n    b[4] * a[2] +\n    b[5] * a[3] +\n    b[2] * a[4] -\n    b[3] * a[5] -\n    b[7] * a[6] -\n    b[6] * a[7],\n  b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n  b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n  b[4] * a[0] + b[7] * a[3] + b[0] * a[4] + b[3] * a[7],\n  b[5] * a[0] + b[7] * a[2] + b[0] * a[5] + b[2] * a[7],\n  b[6] * a[0] + b[0] * a[6],\n  b[7] * a[0] + b[0] * a[7],\n];\n\nexport const norm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[0] * a[0] - a[2] * a[2] - a[3] * a[3] + a[6] * a[6]));\n\nexport const inorm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[7] * a[7] - a[5] * a[5] - a[4] * a[4] + a[1] * a[1]));\n\nexport const normalized = (a: NVector): NVector => {\n  const n = norm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  const sign = a[6] < 0 ? -1 : 1;\n  return mul(a, sign / n);\n};\n\nexport const inormalized = (a: NVector): NVector => {\n  const n = inorm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  return mul(a, 1 / n);\n};\n\nconst isNumber = (a: any): a is number => typeof a === \"number\";\n\nexport const E0: NVector = nvector(1, 1);\nexport const E1: NVector = nvector(1, 2);\nexport const E2: NVector = nvector(1, 3);\nexport const E01: NVector = nvector(1, 4);\nexport const E20: NVector = nvector(1, 5);\nexport const E12: NVector = nvector(1, 6);\nexport const E012: NVector = nvector(1, 7);\nexport const I = E012;\n","import * as GA from \"./ga\";\nimport { Line, Point } from \"./ga\";\n\n/**\n * A line is stored as an array `[0, c, a, b, 0, 0, 0, 0]` representing:\n *   c * e0 + a * e1 + b*e2\n *\n * This maps to a standard formula `a * x + b * y + c`.\n *\n * `(-b, a)` correponds to a 2D vector parallel to the line. The lines\n * have a natural orientation, corresponding to that vector.\n *\n * The magnitude (\"norm\") of the line is `sqrt(a ^ 2 + b ^ 2)`.\n * `c / norm(line)` is the oriented distance from line to origin.\n */\n\n// Returns line with direction (x, y) through origin\nexport const vector = (x: number, y: number): Line =>\n  GA.normalized([0, 0, -y, x, 0, 0, 0, 0]);\n\n// For equation ax + by + c = 0.\nexport const equation = (a: number, b: number, c: number): Line =>\n  GA.normalized([0, c, a, b, 0, 0, 0, 0]);\n\nexport const through = (from: Point, to: Point): Line =>\n  GA.normalized(GA.join(to, from));\n\nexport const orthogonal = (line: Line, point: Point): Line =>\n  GA.dot(line, point);\n\n// Returns a line perpendicular to the line through `against` and `intersection`\n// going through `intersection`.\nexport const orthogonalThrough = (against: Point, intersection: Point): Line =>\n  orthogonal(through(against, intersection), intersection);\n\nexport const parallel = (line: Line, distance: number): Line => {\n  const result = line.slice();\n  result[1] -= distance;\n  return (result as unknown) as Line;\n};\n\nexport const parallelThrough = (line: Line, point: Point): Line =>\n  orthogonal(orthogonal(point, line), point);\n\nexport const distance = (line1: Line, line2: Line): number =>\n  GA.inorm(GA.meet(line1, line2));\n\nexport const angle = (line1: Line, line2: Line): number =>\n  Math.acos(GA.dot(line1, line2)[0]);\n\n// The orientation of the line\nexport const sign = (line: Line): number => Math.sign(line[1]);\n","import * as GA from \"./ga\";\nimport * as GALine from \"./galines\";\nimport { Point, Line, join } from \"./ga\";\n\nexport const from = ([x, y]: readonly [number, number]): Point => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  1,\n  0,\n];\n\nexport const toTuple = (point: Point): [number, number] => [point[5], point[4]];\n\nexport const abs = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  Math.abs(point[4]),\n  Math.abs(point[5]),\n  1,\n  0,\n];\n\nexport const intersect = (line1: Line, line2: Line): Point =>\n  GA.normalized(GA.meet(line1, line2));\n\n// Projects `point` onto the `line`.\n// The returned point is the closest point on the `line` to the `point`.\nexport const project = (point: Point, line: Line): Point =>\n  intersect(GALine.orthogonal(line, point), line);\n\nexport const distance = (point1: Point, point2: Point): number =>\n  GA.norm(join(point1, point2));\n\nexport const distanceToLine = (point: Point, line: Line): number =>\n  GA.joinScalar(point, line);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point } from \"./ga\";\n\n/**\n * A direction is stored as an array `[0, 0, 0, 0, y, x, 0, 0]` representing\n * vector `(x, y)`.\n */\n\nexport const from = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  point[4],\n  point[5],\n  0,\n  0,\n];\n\nexport const fromTo = (from: Point, to: Point): Direction =>\n  GA.inormalized([0, 0, 0, 0, to[4] - from[4], to[5] - from[5], 0, 0]);\n\nexport const orthogonal = (direction: Direction): Direction =>\n  GA.inormalized([0, 0, 0, 0, -direction[5], direction[4], 0, 0]);\n\nexport const orthogonalToLine = (line: Line): Direction => GA.mul(line, GA.I);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point, Transform } from \"./ga\";\nimport * as GADirection from \"./gadirections\";\n\n/**\n * TODO: docs\n */\n\nexport const rotation = (pivot: Point, angle: number): Transform =>\n  GA.add(GA.mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));\n\nexport const translation = (direction: Direction): Transform => [\n  1,\n  0,\n  0,\n  0,\n  -(0.5 * direction[5]),\n  0.5 * direction[4],\n  0,\n  0,\n];\n\nexport const translationOrthogonal = (\n  direction: Direction,\n  distance: number,\n): Transform => {\n  const scale = 0.5 * distance;\n  return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];\n};\n\nexport const translationAlong = (line: Line, distance: number): Transform =>\n  GA.add(GA.mul(GADirection.orthogonalToLine(line), 0.5 * distance), 1);\n\nexport const compose = (motor1: Transform, motor2: Transform): Transform =>\n  GA.mul(motor2, motor1);\n\nexport const apply = (\n  motor: Transform,\n  nvector: Point | Direction | Line,\n): Point | Direction | Line =>\n  GA.normalized(GA.mul(GA.mul(motor, nvector), GA.reverse(motor)));\n","import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport { isPathALoop, isPointInPolygon, rotate } from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n} from \"./types\";\n\nimport { getElementAbsoluteCoords, getCurvePathOps, Bounds } from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n  const isDraggableFromInside = element.backgroundColor !== \"transparent\";\n  if (element.type === \"line\" || element.type === \"draw\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n  return isDraggableFromInside;\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (isElementSelected(appState, element)) {\n    return isPointHittingElementBoundingBox(element, point, threshold);\n  }\n\n  return isHittingElementNotConsideringBoundingBox(element, appState, point);\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(element, appState, [x, y]) &&\n    isPointHittingElementBoundingBox(element, [x, y], threshold)\n  );\n};\n\nconst isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  const check =\n    element.type === \"text\"\n      ? isStrictlyInside\n      : isElementDraggableFromInside(element)\n      ? isInsideCheck\n      : isNearCheck;\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nconst isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"arrow\":\n    case \"line\":\n    case \"draw\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element: ExcalidrawRectangleElement | ExcalidrawTextElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(subshape, relX, relY, element.strokeSharpness),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const [ax, ay, bx, by] = elementCoords;\n  const halfWidth = (bx - ax) / 2;\n  const halfHeight = (by - ay) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = ([ax, ay, bx, by]: Bounds): GA.Point => {\n  return GA.point((ax + bx) / 2, (ay + by) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const elementCoords = getElementAbsoluteCoords(element);\n    const center = coordsCenter(elementCoords);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection conincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  const n = (-m * px - 1) / py;\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (sharpness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points as any, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = (data as unknown) as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n","import {\n  ExcalidrawElement,\n  PointerType,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\nimport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  TransformHandleType,\n  TransformHandle,\n  MaybeTransformHandleType,\n} from \"./transformHandles\";\nimport { AppState, Zoom } from \"../types\";\n\nconst isInsideTransformHandle = (\n  transformHandle: TransformHandle,\n  x: number,\n  y: number,\n) =>\n  x >= transformHandle[0] &&\n  x <= transformHandle[0] + transformHandle[2] &&\n  y >= transformHandle[1] &&\n  y <= transformHandle[1] + transformHandle[3];\n\nexport const resizeTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n): MaybeTransformHandleType => {\n  if (!appState.selectedElementIds[element.id]) {\n    return false;\n  }\n\n  const {\n    rotation: rotationTransformHandle,\n    ...transformHandles\n  } = getTransformHandles(element, zoom, pointerType);\n\n  if (\n    rotationTransformHandle &&\n    isInsideTransformHandle(rotationTransformHandle, x, y)\n  ) {\n    return \"rotation\" as TransformHandleType;\n  }\n\n  const filter = Object.keys(transformHandles).filter((key) => {\n    const transformHandle = transformHandles[\n      key as Exclude<TransformHandleType, \"rotation\">\n    ]!;\n    if (!transformHandle) {\n      return false;\n    }\n    return isInsideTransformHandle(transformHandle, x, y);\n  });\n\n  if (filter.length > 0) {\n    return filter[0] as TransformHandleType;\n  }\n\n  return false;\n};\n\nexport const getElementWithTransformHandleType = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n) => {\n  return elements.reduce((result, element) => {\n    if (result) {\n      return result;\n    }\n    const transformHandleType = resizeTest(\n      element,\n      appState,\n      scenePointerX,\n      scenePointerY,\n      zoom,\n      pointerType,\n    );\n    return transformHandleType ? { element, transformHandleType } : null;\n  }, null as { element: NonDeletedExcalidrawElement; transformHandleType: MaybeTransformHandleType } | null);\n};\n\nexport const getTransformHandleTypeFromCoords = (\n  [x1, y1, x2, y2]: readonly [number, number, number, number],\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n): MaybeTransformHandleType => {\n  const transformHandles = getTransformHandlesFromCoords(\n    [x1, y1, x2, y2],\n    0,\n    zoom,\n    pointerType,\n    OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  );\n\n  const found = Object.keys(transformHandles).find((key) => {\n    const transformHandle = transformHandles[\n      key as Exclude<TransformHandleType, \"rotation\">\n    ]!;\n    return (\n      transformHandle &&\n      isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY)\n    );\n  });\n  return (found || false) as MaybeTransformHandleType;\n};\n\nconst RESIZE_CURSORS = [\"ns\", \"nesw\", \"ew\", \"nwse\"];\nconst rotateResizeCursor = (cursor: string, angle: number) => {\n  const index = RESIZE_CURSORS.indexOf(cursor);\n  if (index >= 0) {\n    const a = Math.round(angle / (Math.PI / 4));\n    cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];\n  }\n  return cursor;\n};\n\n/*\n * Returns bi-directional cursor for the element being resized\n */\nexport const getCursorForResizingElement = (resizingElement: {\n  element?: ExcalidrawElement;\n  transformHandleType: MaybeTransformHandleType;\n}): string => {\n  const { element, transformHandleType } = resizingElement;\n  const shouldSwapCursors =\n    element && Math.sign(element.height) * Math.sign(element.width) === -1;\n  let cursor = null;\n\n  switch (transformHandleType) {\n    case \"n\":\n    case \"s\":\n      cursor = \"ns\";\n      break;\n    case \"w\":\n    case \"e\":\n      cursor = \"ew\";\n      break;\n    case \"nw\":\n    case \"se\":\n      if (shouldSwapCursors) {\n        cursor = \"nesw\";\n      } else {\n        cursor = \"nwse\";\n      }\n      break;\n    case \"ne\":\n    case \"sw\":\n      if (shouldSwapCursors) {\n        cursor = \"nwse\";\n      } else {\n        cursor = \"nesw\";\n      }\n      break;\n    case \"rotation\":\n      return \"grab\";\n  }\n\n  if (cursor && element) {\n    cursor = rotateResizeCursor(cursor, element.angle);\n  }\n\n  return cursor ? `${cursor}-resize` : \"\";\n};\n","import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { SceneHistory } from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  public activePointIndex: number | null;\n  /** whether you're dragging a point */\n  public isDragging: boolean;\n  public lastUncommittedPoint: Point | null;\n  public pointerOffset: { x: number; y: number };\n  public startBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      startOrEnd: \"start\" | \"end\",\n    ) => void,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { activePointIndex, elementId, isDragging } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            isDragging: true,\n          },\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - editingLinearElement.pointerOffset.x,\n        scenePointerY - editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n      if (isBindingElement(element)) {\n        maybeSuggestBinding(element, activePointIndex === 0 ? \"start\" : \"end\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, activePointIndex, isDragging } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    let binding = {};\n    if (\n      isDragging &&\n      (activePointIndex === 0 || activePointIndex === element.points.length - 1)\n    ) {\n      if (isPathALoop(element.points)) {\n        LinearElementEditor.movePoint(\n          element,\n          activePointIndex,\n          activePointIndex === 0\n            ? element.points[element.points.length - 1]\n            : element.points[0],\n        );\n      }\n      const bindingElement = isBindingEnabled(appState)\n        ? getHoveredElementForBinding(\n            tupleToCoors(\n              LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                element,\n                activePointIndex!,\n              ),\n            ),\n            Scene.getScene(element)!,\n          )\n        : null;\n      binding = {\n        [activePointIndex === 0\n          ? \"startBindingElement\"\n          : \"endBindingElement\"]: bindingElement,\n      };\n    }\n    return {\n      ...editingLinearElement,\n      ...binding,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: SceneHistory,\n    scenePointer: { x: number; y: number },\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (appState.editingLinearElement.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n          endBindingElement: getHoveredElementForBinding(\n            scenePointer,\n            Scene.getScene(element)!,\n          ),\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, insted of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const {\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint\n          ? {\n              x: scenePointer.x - targetPoint[0],\n              y: scenePointer.y - targetPoint[1],\n            }\n          : { x: 0, y: 0 },\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n    gridSize: number | null,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return { ...editingLinearElement, lastUncommittedPoint: null };\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX - editingLinearElement.pointerOffset.x,\n      scenePointerY - editingLinearElement.pointerOffset.y,\n      gridSize,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return rotate(x + point[0], y + point[1], cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   *  expected in various parts of the codebase.\n   */\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    mutateElement(element, {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    });\n  }\n\n  static movePointByOffset(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number,\n    offset: { x: number; y: number },\n  ) {\n    const [x, y] = element.points[pointIndex];\n    LinearElementEditor.movePoint(element, pointIndex, [\n      x + offset.x,\n      y + offset.y,\n    ]);\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        // positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(\n      element,\n      nextPoints,\n      element.strokeSharpness || \"round\",\n    );\n    const prevCoords = getElementPointsCoords(\n      element,\n      points,\n      element.strokeSharpness || \"round\",\n    );\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n","import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isBindableElement, isBindingElement } from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLCanvasElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n  Scene.getScene(linearElement)!\n    .getNonDeletedElements(onlyUnbound)\n    .forEach((element) => {\n      mutateElement(element, {\n        boundElementIds: element.boundElementIds?.filter(\n          (id) => id !== linearElement.id,\n        ),\n      });\n    });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(\n    bindableElement,\n  ).forEach(([linearElement, where]) =>\n    bindOrUnbindLinearElement(\n      linearElement,\n      where === \"end\" ? \"keep\" : bindableElement,\n      where === \"start\" ? \"keep\" : bindableElement,\n    ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n  mutateElement(hoveredElement, {\n    boundElementIds: [\n      ...new Set([...(hoveredElement.boundElementIds ?? []), linearElement.id]),\n    ],\n  });\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getElements(),\n    (element) =>\n      isBindableElement(element) && bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundElementIds = changedElement.boundElementIds ?? [];\n  if (boundElementIds.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n  (Scene.getScene(changedElement)!.getNonDeletedElements(\n    boundElementIds,\n  ) as NonDeleted<ExcalidrawLinearElement>[]).forEach((linearElement) => {\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElementIds are stale\n    if (!doesNeedUpdate(linearElement, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(linearElement.id)) {\n      mutateElement(linearElement, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      linearElement,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      linearElement,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoint(\n    linearElement,\n    edgePointIndex,\n    LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint),\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getElements()\n    .map((element) => {\n      if (!isBindingElement(element)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElementIds } = oldElement;\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      boundElementIds.forEach((boundElementId) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElementId)) {\n          allBoundElementIds.add(boundElementId);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (sceneElements.filter(({ id }) =>\n    allBoundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElementIds } = bindableElement;\n      if (boundElementIds != null && boundElementIds.length > 0) {\n        mutateElement(bindableElement, {\n          boundElementIds: boundElementIds.map(\n            (boundElementId) =>\n              oldIdToDuplicatedId.get(boundElementId) ?? boundElementId,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // Non deleted and need an update\n  const boundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElementIds?.forEach((id) => {\n        if (!deletedElementIds.has(id)) {\n          boundElementIds.add(id);\n        }\n      });\n    }\n  });\n  (sceneElements.filter(({ id }) =>\n    boundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach(\n    (element: ExcalidrawLinearElement) => {\n      const { startBinding, endBinding } = element;\n      mutateElement(element, {\n        startBinding: newBindingAfterDeletion(startBinding, deletedElementIds),\n        endBinding: newBindingAfterDeletion(endBinding, deletedElementIds),\n      });\n    },\n  );\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n","import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\n\nimport {\n  rotate,\n  adjustXYWithRotation,\n  centerPoint,\n  rotatePoint,\n} from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\nimport { isLinearElement, isTextElement } from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { getCursorForResizingElement } from \"./resizeTest\";\nimport { measureText, getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport {\n  TransformHandleType,\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport { PointerDownState } from \"../components/App\";\nimport { Point } from \"../types\";\n\nconst normalizeAngle = (angle: number): number => {\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  pointerDownState: PointerDownState,\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  resizeArrowDirection: \"origin\" | \"end\",\n  isRotateWithDiscreteAngle: boolean,\n  isResizeCenterPoint: boolean,\n  shouldKeepSidesRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(\n        element,\n        pointerX,\n        pointerY,\n        isRotateWithDiscreteAngle,\n      );\n      updateBoundElements(element);\n    } else if (\n      isLinearElement(element) &&\n      element.points.length === 2 &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      reshapeSingleTwoPointElement(\n        element,\n        resizeArrowDirection,\n        isRotateWithDiscreteAngle,\n        pointerX,\n        pointerY,\n      );\n    } else if (\n      isTextElement(element) &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      resizeSingleTextElement(\n        element,\n        transformHandleType,\n        isResizeCenterPoint,\n        pointerX,\n        pointerY,\n      );\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(\n        pointerDownState.originalElements.get(element.id) as typeof element,\n        shouldKeepSidesRatio,\n        element,\n        transformHandleType,\n        isResizeCenterPoint,\n        pointerX,\n        pointerY,\n      );\n    }\n\n    // update cursor\n    // FIXME it is not very nice to have this here\n    document.documentElement.style.cursor = getCursorForResizingElement({\n      element,\n      transformHandleType,\n    });\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        pointerDownState,\n        selectedElements,\n        pointerX,\n        pointerY,\n        isRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (\n      transformHandleType === \"nw\" ||\n      transformHandleType === \"ne\" ||\n      transformHandleType === \"sw\" ||\n      transformHandleType === \"se\"\n    ) {\n      resizeMultipleElements(\n        selectedElements,\n        transformHandleType,\n        pointerX,\n        pointerY,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  pointerX: number,\n  pointerY: number,\n  isRotateWithDiscreteAngle: boolean,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle = (5 * Math.PI) / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n  if (isRotateWithDiscreteAngle) {\n    angle += SHIFT_LOCKING_ANGLE / 2;\n    angle -= angle % SHIFT_LOCKING_ANGLE;\n  }\n  angle = normalizeAngle(angle);\n  mutateElement(element, { angle });\n};\n\n// used in DEV only\nconst validateTwoPointElementNormalized = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  if (\n    element.points.length !== 2 ||\n    element.points[0][0] !== 0 ||\n    element.points[0][1] !== 0 ||\n    Math.abs(element.points[1][0]) !== element.width ||\n    Math.abs(element.points[1][1]) !== element.height\n  ) {\n    throw new Error(\"Two-point element is not normalized\");\n  }\n};\n\nconst getPerfectElementSizeWithRotation = (\n  elementType: string,\n  width: number,\n  height: number,\n  angle: number,\n): [number, number] => {\n  const size = getPerfectElementSize(\n    elementType,\n    ...rotate(width, height, 0, 0, angle),\n  );\n  return rotate(size.width, size.height, 0, 0, -angle);\n};\n\nconst reshapeSingleTwoPointElement = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  resizeArrowDirection: \"origin\" | \"end\",\n  isRotateWithDiscreteAngle: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTwoPointElementNormalized(element);\n  }\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let [width, height] =\n    resizeArrowDirection === \"end\"\n      ? [rotatedX - element.x, rotatedY - element.y]\n      : [\n          element.x + element.points[1][0] - rotatedX,\n          element.y + element.points[1][1] - rotatedY,\n        ];\n  if (isRotateWithDiscreteAngle) {\n    [width, height] = getPerfectElementSizeWithRotation(\n      element.type,\n      width,\n      height,\n      element.angle,\n    );\n  }\n  const [nextElementX, nextElementY] = adjustXYWithRotation(\n    resizeArrowDirection === \"end\"\n      ? { s: true, e: true }\n      : { n: true, w: true },\n    element.x,\n    element.y,\n    element.angle,\n    0,\n    0,\n    (element.points[1][0] - width) / 2,\n    (element.points[1][1] - height) / 2,\n  );\n  mutateElement(element, {\n    x: nextElementX,\n    y: nextElementY,\n    points: [\n      [0, 0],\n      [width, height],\n    ],\n  });\n};\n\nconst rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n) =>\n  isLinearElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points),\n        ),\n      }\n    : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWH = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  nextWidth: number,\n  nextHeight: number,\n): { size: number; baseline: number } | null => {\n  // We only use width to scale font on resize\n  const nextFontSize = element.fontSize * (nextWidth / element.width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(\n    element.text,\n    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),\n  );\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height),\n  };\n};\n\nconst getSidesForTransformHandle = (\n  transformHandleType: TransformHandleType,\n  isResizeFromCenter: boolean,\n) => {\n  return {\n    n:\n      /^(n|ne|nw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType)),\n    s:\n      /^(s|se|sw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType)),\n    w:\n      /^(w|nw|sw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType)),\n    e:\n      /^(e|ne|se)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)),\n  };\n};\n\nconst resizeSingleTextElement = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  isResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let scale: number;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const nextFont = measureFontSizeFromWH(element, nextWidth, nextHeight);\n    if (nextFont === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(\n      getSidesForTransformHandle(transformHandleType, isResizeFromCenter),\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n    mutateElement(element, {\n      fontSize: nextFont.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextFont.baseline,\n      x: nextElementX,\n      y: nextElementY,\n    });\n  }\n};\n\nconst resizeSingleElement = (\n  stateAtResizeStart: NonDeletedExcalidrawElement,\n  shouldKeepSidesRatio: boolean,\n  element: NonDeletedExcalidrawElement,\n  transformHandleDirection: TransformHandleDirection,\n  isResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    stateAtResizeStart.width,\n    stateAtResizeStart.height,\n  );\n  const startTopLeft: Point = [x1, y1];\n  const startBottomRight: Point = [x2, y2];\n  const startCenter: Point = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint(\n    [pointerX, pointerY],\n    startCenter,\n    -stateAtResizeStart.angle,\n  );\n\n  //Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    element,\n    element.width,\n    element.height,\n  );\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (isResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldKeepSidesRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  const [\n    newBoundsX1,\n    newBoundsY1,\n    newBoundsX2,\n    newBoundsY2,\n  ] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldKeepSidesRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (isResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  const rescaledPoints = rescalePointsInElement(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    ...rescaledPoints,\n  };\n\n  if (\n    resizedElement.width !== 0 &&\n    resizedElement.height !== 0 &&\n    Number.isFinite(resizedElement.x) &&\n    Number.isFinite(resizedElement.y)\n  ) {\n    updateBoundElements(element, {\n      newSize: { width: resizedElement.width, height: resizedElement.height },\n    });\n    mutateElement(element, resizedElement);\n  }\n};\n\nconst resizeMultipleElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements);\n  let scale: number;\n  let getNextXY: (\n    element: NonDeletedExcalidrawElement,\n    origCoords: readonly [number, number, number, number],\n    finalCoords: readonly [number, number, number, number],\n  ) => { x: number; y: number };\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, origY1], [finalX1, finalY1]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [, , origX2, origY2], [, , finalX2, finalY2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, , , origY2], [finalX1, , , finalY2]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [, origY1, origX2], [, finalY1, finalX2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n  }\n  if (scale > 0) {\n    const updates = elements.reduce(\n      (prev, element) => {\n        if (!prev) {\n          return prev;\n        }\n        const width = element.width * scale;\n        const height = element.height * scale;\n        let font: { fontSize?: number; baseline?: number } = {};\n        if (element.type === \"text\") {\n          const nextFont = measureFontSizeFromWH(element, width, height);\n          if (nextFont === null) {\n            return null;\n          }\n          font = { fontSize: nextFont.size, baseline: nextFont.baseline };\n        }\n        const origCoords = getElementAbsoluteCoords(element);\n        const rescaledPoints = rescalePointsInElement(element, width, height);\n        updateBoundElements(element, {\n          newSize: { width, height },\n          simultaneouslyUpdated: elements,\n        });\n        const finalCoords = getResizedElementAbsoluteCoords(\n          {\n            ...element,\n            ...rescaledPoints,\n          },\n          width,\n          height,\n        );\n        const { x, y } = getNextXY(element, origCoords, finalCoords);\n        return [...prev, { width, height, x, y, ...rescaledPoints, ...font }];\n      },\n      [] as\n        | {\n            width: number;\n            height: number;\n            x: number;\n            y: number;\n            points?: (readonly [number, number])[];\n            fontSize?: number;\n            baseline?: number;\n          }[]\n        | null,\n    );\n    if (updates) {\n      elements.forEach((element, index) => {\n        mutateElement(element, updates[index]);\n      });\n    }\n  }\n};\n\nconst rotateMultipleElements = (\n  pointerDownState: PointerDownState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  isRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (isRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n  elements.forEach((element, index) => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const origAngle =\n      pointerDownState.originalElements.get(element.id)?.angle ?? element.angle;\n    const [rotatedCX, rotatedCY] = rotate(\n      cx,\n      cy,\n      centerX,\n      centerY,\n      centerAngle + origAngle - element.angle,\n    );\n    mutateElement(element, {\n      x: element.x + (rotatedCX - cx),\n      y: element.y + (rotatedCY - cy),\n      angle: normalizeAngle(centerAngle + origAngle),\n    });\n  });\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0])\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n","import { SHAPES } from \"../shapes\";\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport Scene from \"../scene/Scene\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { PointerDownState } from \"../components/App\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  scene: Scene,\n  lockDirection: boolean = false,\n  distanceX: number = 0,\n  distanceY: number = 0,\n) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = { x: pointerX - x1, y: pointerY - y1 };\n  selectedElements.forEach((element) => {\n    let x: number;\n    let y: number;\n    if (lockDirection) {\n      const lockX = lockDirection && distanceX < distanceY;\n      const lockY = lockDirection && distanceX > distanceY;\n      const original = pointerDownState.originalElements.get(element.id);\n      x = lockX && original ? original.x : element.x + offset.x;\n      y = lockY && original ? original.y : element.y + offset.y;\n    } else {\n      x = element.x + offset.x;\n      y = element.y + offset.y;\n    }\n\n    mutateElement(element, {\n      x,\n      y,\n    });\n\n    updateBoundElements(element, {\n      simultaneouslyUpdated: selectedElements,\n    });\n  });\n};\n\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = (\n  draggingElement: NonDeletedExcalidrawElement,\n  elementType: typeof SHAPES[number][\"value\"],\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  isResizeWithSidesSameLength: boolean,\n  isResizeCenterPoint: boolean,\n) => {\n  if (isResizeWithSidesSameLength) {\n    ({ width, height } = getPerfectElementSize(\n      elementType,\n      width,\n      y < originY ? -height : height,\n    ));\n\n    if (height < 0) {\n      height = -height;\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (isResizeCenterPoint) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height,\n    });\n  }\n};\n","import { KEYS } from \"../keys\";\nimport { isWritableElement, getFontString } from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \"./typeChecks\";\nimport { CLASSES } from \"../constants\";\nimport { ExcalidrawElement } from \"./types\";\nimport { AppState } from \"../types\";\n\nconst normalizeText = (text: string) => {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, \"\\n\")\n  );\n};\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n) => {\n  const { zoom, offsetTop, offsetLeft } = appState;\n  const degree = (180 * angle) / Math.PI;\n  // offsets must be multiplied by 2 to account for the division by 2 of\n  // the whole expression afterwards\n  return `translate(${((width - offsetLeft * 2) * (zoom.value - 1)) / 2}px, ${\n    ((height - offsetTop * 2) * (zoom.value - 1)) / 2\n  }px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nexport const textWysiwyg = ({\n  id,\n  appState,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  appState: AppState;\n  onChange?: (text: string) => void;\n  onSubmit: (text: string) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawElement;\n}) => {\n  const updateWysiwygStyle = () => {\n    const updatedElement = Scene.getScene(element)?.getElement(id);\n    if (updatedElement && isTextElement(updatedElement)) {\n      const [viewportX, viewportY] = getViewportCoords(\n        updatedElement.x,\n        updatedElement.y,\n      );\n      const { textAlign, angle } = updatedElement;\n\n      editable.value = updatedElement.text;\n\n      const lines = updatedElement.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n      const lineHeight = updatedElement.height / lines.length;\n\n      Object.assign(editable.style, {\n        font: getFontString(updatedElement),\n        // must be defined *after* font \\_()_/\n        lineHeight: `${lineHeight}px`,\n        width: `${updatedElement.width}px`,\n        height: `${updatedElement.height}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          updatedElement.width,\n          updatedElement.height,\n          angle,\n          appState,\n        ),\n        textAlign,\n        color: updatedElement.strokeColor,\n        opacity: updatedElement.opacity / 100,\n        filter: \"var(--appearance-filter)\",\n      });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n\n  Object.assign(editable.style, {\n    position: \"fixed\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace: \"pre\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n  });\n\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && !event.altKey) {\n      event.stopPropagation();\n    }\n  };\n\n  const stopEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleSubmit = () => {\n    onSubmit(normalizeText(editable.value));\n    cleanup();\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", rebindBlur);\n    window.removeEventListener(\"blur\", handleSubmit);\n\n    unbindUpdate();\n\n    editable.remove();\n  };\n\n  const rebindBlur = () => {\n    window.removeEventListener(\"pointerup\", rebindBlur);\n    // deferred to guard against focus traps on various UIs that steal focus\n    // upon pointerUp\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n      // case: clicking on the same property  no change  no update  no focus\n      editable.focus();\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    if (\n      event.target instanceof HTMLElement &&\n      event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) &&\n      !isWritableElement(event.target)\n    ) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", rebindBlur);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element)!.addCallback(() => {\n    updateWysiwygStyle();\n    editable.focus();\n  });\n\n  let isDestroyed = false;\n\n  editable.onblur = handleSubmit;\n  // reposition wysiwyg in case of window resize. Happens on mobile when\n  // device keyboard is opened.\n  window.addEventListener(\"resize\", updateWysiwygStyle);\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true,\n  });\n  document\n    .querySelector(\".excalidraw-textEditorContainer\")!\n    .appendChild(editable);\n  editable.focus();\n  editable.select();\n};\n","import { measureText, getFontString } from \"../utils\";\nimport { ExcalidrawTextElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\n\nexport const redrawTextBoundingBox = (element: ExcalidrawTextElement) => {\n  const metrics = measureText(element.text, getFontString(element));\n  mutateElement(element, {\n    width: metrics.width,\n    height: metrics.height,\n    baseline: metrics.baseline,\n  });\n};\n","import { AppState } from \"../types\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { getSelectedElements } from \"../scene\";\n\nexport const showSelectedShapeActions = (\n  appState: AppState,\n  elements: readonly NonDeletedExcalidrawElement[],\n) =>\n  Boolean(\n    !appState.viewModeEnabled &&\n      (appState.editingElement ||\n        getSelectedElements(elements, appState).length ||\n        appState.elementType !== \"selection\"),\n  );\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowheadPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n} from \"./transformHandles\";\nexport {\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n} from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  getElementWithTransformHandleType,\n  getTransformHandleTypeFromCoords,\n} from \"./resizeTest\";\nexport {\n  transformElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getSyncableElements = (\n  elements: readonly ExcalidrawElement[], // There are places in Excalidraw where synthetic invisibly small elements are added and removed.\n) =>\n  // It's probably best to keep those local otherwise there might be a race condition that\n  // gets the app into an invalid state. I've never seen it happen but I'm worried about it :)\n  elements.filter((el) => el.isDeleted || !isInvisiblySmallElement(el));\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nconst _clearElements = (\n  elements: readonly ExcalidrawElement[],\n): ExcalidrawElement[] =>\n  getNonDeletedElements(elements).map((element) =>\n    isLinearElementType(element.type)\n      ? { ...element, lastCommittedPoint: null }\n      : element,\n  );\n\nexport const clearElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element\";\nimport { Zoom } from \"../types\";\nimport { ScrollBars } from \"./types\";\nimport { getGlobalCSSVariable } from \"../utils\";\nimport { getLanguage } from \"../i18n\";\n\nexport const SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport const getScrollBars = (\n  elements: readonly ExcalidrawElement[],\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: number;\n    scrollY: number;\n    zoom: Zoom;\n  },\n): ScrollBars => {\n  if (elements.length === 0) {\n    return {\n      horizontal: null,\n      vertical: null,\n    };\n  }\n  // This is the bounding box of all the elements\n  const [\n    elementsMinX,\n    elementsMinY,\n    elementsMaxX,\n    elementsMaxY,\n  ] = getCommonBounds(elements);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom.value;\n  const viewportHeightWithZoom = viewportHeight / zoom.value;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  const safeArea = {\n    top: parseInt(getGlobalCSSVariable(\"sat\")),\n    bottom: parseInt(getGlobalCSSVariable(\"sab\")),\n    left: parseInt(getGlobalCSSVariable(\"sal\")),\n    right: parseInt(getGlobalCSSVariable(\"sar\")),\n  };\n\n  const isRTL = getLanguage().rtl;\n\n  // The viewport is the rectangle currently visible for the user\n  const viewportMinX = -scrollX + viewportWidthDiff / 2 + safeArea.left;\n  const viewportMinY = -scrollY + viewportHeightDiff / 2 + safeArea.top;\n  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;\n  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;\n\n  // The scene is the bounding box of both the elements and viewport\n  const sceneMinX = Math.min(elementsMinX, viewportMinX);\n  const sceneMinY = Math.min(elementsMinY, viewportMinY);\n  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);\n  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);\n\n  // The scrollbar represents where the viewport is in relationship to the scene\n\n  return {\n    horizontal:\n      viewportMinX === sceneMinX && viewportMaxX === sceneMaxX\n        ? null\n        : {\n            x:\n              Math.max(safeArea.left, SCROLLBAR_MARGIN) +\n              ((viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth,\n            y:\n              viewportHeight -\n              SCROLLBAR_WIDTH -\n              Math.max(SCROLLBAR_MARGIN, safeArea.bottom),\n            width:\n              ((viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),\n            height: SCROLLBAR_WIDTH,\n          },\n    vertical:\n      viewportMinY === sceneMinY && viewportMaxY === sceneMaxY\n        ? null\n        : {\n            x: isRTL\n              ? Math.max(safeArea.left, SCROLLBAR_MARGIN)\n              : viewportWidth -\n                SCROLLBAR_WIDTH -\n                Math.max(safeArea.right, SCROLLBAR_MARGIN),\n            y:\n              ((viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight +\n              Math.max(safeArea.top, SCROLLBAR_MARGIN),\n            width: SCROLLBAR_WIDTH,\n            height:\n              ((viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom),\n          },\n  };\n};\n\nexport const isOverScrollBars = (\n  scrollBars: ScrollBars,\n  x: number,\n  y: number,\n): {\n  isOverEither: boolean;\n  isOverHorizontal: boolean;\n  isOverVertical: boolean;\n} => {\n  const [isOverHorizontal, isOverVertical] = [\n    scrollBars.horizontal,\n    scrollBars.vertical,\n  ].map((scrollBar) => {\n    return (\n      scrollBar != null &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n    );\n  });\n  const isOverEither = isOverHorizontal || isOverVertical;\n  return { isOverEither, isOverHorizontal, isOverVertical };\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { AppState } from \"../types\";\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n) => {\n  const [\n    selectionX1,\n    selectionY1,\n    selectionX2,\n    selectionY2,\n  ] = getElementAbsoluteCoords(selection);\n  return elements.filter((element) => {\n    const [elementX1, elementY1, elementX2, elementY2] = getElementBounds(\n      element,\n    );\n\n    return (\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n};\n\nexport const isSomeElementSelected = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n): boolean =>\n  elements.some((element) => appState.selectedElementIds[element.id]);\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = <T>(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n): T | null => {\n  const attributes = Array.from(\n    new Set(\n      getSelectedElements(elements, appState).map((element) =>\n        getAttribute(element),\n      ),\n    ),\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n};\n\nexport const getSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => elements.filter((element) => appState.selectedElementIds[element.id]);\n\nexport const getTargetElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) =>\n  appState.editingElement\n    ? [appState.editingElement]\n    : getSelectedElements(elements, appState);\n","import { AppState, PointerCoords, Zoom } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds, getClosestElementBounds } from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nconst isOutsideViewPort = (\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) => {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n  );\n  return (\n    viewportX2 - viewportX1 > appState.width ||\n    viewportY2 - viewportY1 > appState.height\n  );\n};\n\nexport const centerScrollOn = ({\n  scenePoint,\n  viewportDimensions,\n  zoom,\n}: {\n  scenePoint: PointerCoords;\n  viewportDimensions: { height: number; width: number };\n  zoom: Zoom;\n}) => {\n  return {\n    scrollX:\n      (viewportDimensions.width / 2) * (1 / zoom.value) -\n      scenePoint.x -\n      zoom.translation.x * (1 / zoom.value),\n    scrollY:\n      (viewportDimensions.height / 2) * (1 / zoom.value) -\n      scenePoint.y -\n      zoom.translation.y * (1 / zoom.value),\n  };\n};\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: number; scrollY: number } => {\n  if (!elements.length) {\n    return {\n      scrollX: 0,\n      scrollY: 0,\n    };\n  }\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return centerScrollOn({\n    scenePoint: { x: centerX, y: centerY },\n    viewportDimensions: { width: appState.width, height: appState.height },\n    zoom: appState.zoom,\n  });\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport const hasBackground = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"draw\" ||\n  type === \"line\";\n\nexport const hasStroke = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"draw\" ||\n  type === \"line\";\n\nexport const canChangeSharpness = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"arrow\" ||\n  type === \"draw\" ||\n  type === \"line\";\n\nexport const hasText = (type: string) => type === \"text\";\n\nexport const canHaveArrowheads = (type: string) => type === \"arrow\";\n\nexport const getElementAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nexport const getElementsAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(\n    (element) => !element.isDeleted && isAtPositionFn(element),\n  );\n};\n\nexport const getElementContainingPosition = (\n  elements: readonly ExcalidrawElement[],\n  x: number,\n  y: number,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n  return hitElement;\n};\n","import { NormalizedZoomValue, PointerCoords, Zoom } from \"../types\";\n\nexport const getNewZoom = (\n  newZoomValue: NormalizedZoomValue,\n  prevZoom: Zoom,\n  canvasOffset: { left: number; top: number },\n  zoomOnViewportPoint: PointerCoords = { x: 0, y: 0 },\n): Zoom => {\n  return {\n    value: newZoomValue,\n    translation: {\n      x:\n        zoomOnViewportPoint.x -\n        canvasOffset.left -\n        (zoomOnViewportPoint.x - canvasOffset.left - prevZoom.translation.x) *\n          (newZoomValue / prevZoom.value),\n      y:\n        zoomOnViewportPoint.y -\n        canvasOffset.top -\n        (zoomOnViewportPoint.y - canvasOffset.top - prevZoom.translation.y) *\n          (newZoomValue / prevZoom.value),\n    },\n  };\n};\n\nexport const getNormalizedZoom = (zoom: number): NormalizedZoomValue => {\n  const normalizedZoom = parseFloat(zoom.toFixed(2));\n  const clampedZoom = Math.max(0.1, Math.min(normalizedZoom, 10));\n  return clampedZoom as NormalizedZoomValue;\n};\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype ToolIconSize = \"s\" | \"m\";\n\ntype ToolButtonBaseProps = {\n  icon?: React.ReactNode;\n  \"aria-label\": string;\n  \"aria-keyshortcuts\"?: string;\n  \"data-testid\"?: string;\n  label?: string;\n  title?: string;\n  name?: string;\n  id?: string;\n  size?: ToolIconSize;\n  keyBindingLabel?: string;\n  showAriaLabel?: boolean;\n  hidden?: boolean;\n  visible?: boolean;\n  selected?: boolean;\n  className?: string;\n};\n\ntype ToolButtonProps =\n  | (ToolButtonBaseProps & {\n      type: \"button\";\n      children?: React.ReactNode;\n      onClick?(): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"radio\";\n\n      checked: boolean;\n      onChange?(): void;\n    });\n\nconst DEFAULT_SIZE: ToolIconSize = \"m\";\n\nexport const ToolButton = React.forwardRef((props: ToolButtonProps, ref) => {\n  const innerRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => innerRef.current);\n  const sizeCn = `ToolIcon_size_${props.size || DEFAULT_SIZE}`;\n\n  if (props.type === \"button\") {\n    return (\n      <button\n        className={clsx(\n          \"ToolIcon_type_button\",\n          sizeCn,\n          props.className,\n          props.visible && !props.hidden\n            ? \"ToolIcon_type_button--show\"\n            : \"ToolIcon_type_button--hide\",\n          {\n            ToolIcon: !props.hidden,\n            \"ToolIcon--selected\": props.selected,\n          },\n        )}\n        hidden={props.hidden}\n        title={props.title}\n        aria-label={props[\"aria-label\"]}\n        type=\"button\"\n        onClick={props.onClick}\n        ref={innerRef}\n      >\n        <div className=\"ToolIcon__icon\" aria-hidden=\"true\">\n          {props.icon || props.label}\n          {props.keyBindingLabel && (\n            <span className=\"ToolIcon__keybinding\">\n              {props.keyBindingLabel}\n            </span>\n          )}\n        </div>\n        {props.showAriaLabel && (\n          <div className=\"ToolIcon__label\">{props[\"aria-label\"]}</div>\n        )}\n        {props.children}\n      </button>\n    );\n  }\n\n  return (\n    <label className={clsx(\"ToolIcon\", props.className)} title={props.title}>\n      <input\n        className={`ToolIcon_type_radio ${sizeCn}`}\n        type=\"radio\"\n        name={props.name}\n        aria-label={props[\"aria-label\"]}\n        aria-keyshortcuts={props[\"aria-keyshortcuts\"]}\n        data-testid={props[\"data-testid\"]}\n        id={props.id}\n        onChange={props.onChange}\n        checked={props.checked}\n        ref={innerRef}\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.icon}\n        {props.keyBindingLabel && (\n          <span className=\"ToolIcon__keybinding\">{props.keyBindingLabel}</span>\n        )}\n      </div>\n    </label>\n  );\n});\n\nToolButton.defaultProps = {\n  visible: true,\n  className: \"\",\n};\n","import { Action } from \"./types\";\n\nexport let actions: readonly Action[] = [];\n\nexport const register = (action: Action): Action => {\n  actions = actions.concat(action);\n  return action;\n};\n","import { isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport React from \"react\";\nimport { trash } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst deleteSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    elements: elements.map((el) => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, { isDeleted: true });\n      }\n      return el;\n    }),\n    appState: {\n      ...appState,\n      selectedElementIds: {},\n    },\n  };\n};\n\nconst handleGroupEditingState = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n): AppState => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(\n      getNonDeletedElements(elements),\n      appState.editingGroupId!,\n    );\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: { [siblingElements[0].id]: true },\n      };\n    }\n  }\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        activePointIndex,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element) {\n        return false;\n      }\n      if (\n        // case: no point selected  delete whole element\n        activePointIndex == null ||\n        activePointIndex === -1 ||\n        // case: deleting last remaining point\n        element.points.length < 2\n      ) {\n        const nextElements = elements.filter((el) => el.id !== element.id);\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null,\n          },\n          commitToHistory: false,\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement:\n          activePointIndex === 0 ? null : startBindingElement,\n        endBindingElement:\n          activePointIndex === element.points.length - 1\n            ? null\n            : endBindingElement,\n      };\n\n      LinearElementEditor.movePoint(element, activePointIndex, \"delete\");\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            activePointIndex: activePointIndex > 0 ? activePointIndex - 1 : 0,\n          },\n        },\n        commitToHistory: true,\n      };\n    }\n\n    let {\n      elements: nextElements,\n      appState: nextAppState,\n    } = deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(\n      nextElements,\n      elements.filter(({ id }) => appState.selectedElementIds[id]),\n    );\n\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        elementType: \"selection\",\n        multiElement: null,\n      },\n      commitToHistory: isSomeElementSelected(\n        getNonDeletedElements(elements),\n        appState,\n      ),\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  keyTest: (event) => event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={trash}\n      title={t(\"labels.delete\")}\n      aria-label={t(\"labels.delete\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { getElementsInGroup } from \"./groups\";\nimport { AppState } from \"./types\";\nimport { findIndex, findLastIndex } from \"./utils\";\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  while (++index < elements.length) {\n    if (appState.selectedElementIds[elements[index].id]) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (elements[index].isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1))\n      : findIndex(elements, indexFilter, boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group  return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return candidateIndex;\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group  prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return candidateIndex;\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst shiftElements = (\n  appState: AppState,\n  elements: ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  return elements;\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElements: ExcalidrawElement[] = [];\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (indicesToMove.includes(index)) {\n      targetElements.push(elements[index]);\n    } else {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n\n  return direction === \"left\"\n    ? [\n        ...leadingElements,\n        ...targetElements,\n        ...displacedElements,\n        ...trailingElements,\n      ]\n    : [\n        ...leadingElements,\n        ...displacedElements,\n        ...targetElements,\n        ...trailingElements,\n      ];\n};\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements.slice(), \"left\");\n};\n\nexport const moveOneRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements.slice(), \"right\");\n};\n\nexport const moveAllLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"left\");\n};\n\nexport const moveAllRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"right\");\n};\n","import React from \"react\";\nimport {\n  moveOneLeft,\n  moveOneRight,\n  moveAllLeft,\n  moveAllRight,\n} from \"../zindex\";\nimport { KEYS, isDarwin, CODES } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport {\n  SendBackwardIcon,\n  BringToFrontIcon,\n  SendToBackIcon,\n  BringForwardIcon,\n} from \"../components/icons\";\n\nexport const actionSendBackward = register({\n  name: \"sendBackward\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveOneLeft(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.sendBackward\",\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendBackward\")}  ${getShortcutKey(\"CtrlOrCmd+[\")}`}\n    >\n      <SendBackwardIcon appearance={appState.appearance} />\n    </button>\n  ),\n});\n\nexport const actionBringForward = register({\n  name: \"bringForward\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveOneRight(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.bringForward\",\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.bringForward\")}  ${getShortcutKey(\"CtrlOrCmd+]\")}`}\n    >\n      <BringForwardIcon appearance={appState.appearance} />\n    </button>\n  ),\n});\n\nexport const actionSendToBack = register({\n  name: \"sendToBack\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllLeft(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.sendToBack\",\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_LEFT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendToBack\")}  ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+[\")\n      }`}\n    >\n      <SendToBackIcon appearance={appState.appearance} />\n    </button>\n  ),\n});\n\nexport const actionBringToFront = register({\n  name: \"bringToFront\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllRight(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.bringToFront\",\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_RIGHT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={(event) => updateData(null)}\n      title={`${t(\"labels.bringToFront\")}  ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+]\")\n      }`}\n    >\n      <BringToFrontIcon appearance={appState.appearance} />\n    </button>\n  ),\n});\n","import { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { selectGroupsForSelectedElements } from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\n\nexport const actionSelectAll = register({\n  name: \"selectAll\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      return false;\n    }\n    return {\n      appState: selectGroupsForSelectedElements(\n        {\n          ...appState,\n          editingGroupId: null,\n          selectedElementIds: elements.reduce((map, element) => {\n            if (!element.isDeleted) {\n              map[element.id] = true;\n            }\n            return map;\n          }, {} as any),\n        },\n        getNonDeletedElements(elements),\n      ),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.selectAll\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A,\n});\n","import React from \"react\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { clone } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport {\n  selectGroupsForSelectedElements,\n  getSelectedGroupForElement,\n  getElementsInGroup,\n} from \"../groups\";\nimport { AppState } from \"../types\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { ActionResult } from \"./types\";\nimport { GRID_SIZE } from \"../constants\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  perform: (elements, appState) => {\n    // duplicate point if selected while editing multi-point element\n    if (appState.editingLinearElement) {\n      const { activePointIndex, elementId } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element || activePointIndex === null) {\n        return false;\n      }\n      const { points } = element;\n      const selectedPoint = points[activePointIndex];\n      const nextPoint = points[activePointIndex + 1];\n      mutateElement(element, {\n        points: [\n          ...points.slice(0, activePointIndex + 1),\n          nextPoint\n            ? [\n                (selectedPoint[0] + nextPoint[0]) / 2,\n                (selectedPoint[1] + nextPoint[1]) / 2,\n              ]\n            : [selectedPoint[0] + 30, selectedPoint[1] + 30],\n          ...points.slice(activePointIndex + 1),\n        ],\n      });\n      return {\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            activePointIndex: activePointIndex + 1,\n          },\n        },\n        elements,\n        commitToHistory: true,\n      };\n    }\n\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={clone}\n      title={`${t(\"labels.duplicateSelection\")}  ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nconst duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): Partial<ActionResult> => {\n  const groupIdMap = new Map();\n  const newElements: ExcalidrawElement[] = [];\n  const oldElements: ExcalidrawElement[] = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = (element: ExcalidrawElement) => {\n    const newElement = duplicateElement(\n      appState.editingGroupId,\n      groupIdMap,\n      element,\n      {\n        x: element.x + GRID_SIZE / 2,\n        y: element.y + GRID_SIZE / 2,\n      },\n    );\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const finalElements: ExcalidrawElement[] = [];\n\n  let index = 0;\n  while (index < elements.length) {\n    const element = elements[index];\n    if (appState.selectedElementIds[element.id]) {\n      if (element.groupIds.length) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        // if group selected, duplicate it atomically\n        if (groupId) {\n          const groupElements = getElementsInGroup(elements, groupId);\n          finalElements.push(\n            ...groupElements,\n            ...groupElements.map((element) =>\n              duplicateAndOffsetElement(element),\n            ),\n          );\n          index = index + groupElements.length;\n          continue;\n        }\n      }\n      finalElements.push(element, duplicateAndOffsetElement(element));\n    } else {\n      finalElements.push(element);\n    }\n    index++;\n  }\n\n  fixBindingsAfterDuplication(finalElements, oldElements, oldIdToDuplicatedId);\n\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements(\n      {\n        ...appState,\n        selectedGroupIds: {},\n        selectedElementIds: newElements.reduce((acc, element) => {\n          acc[element.id] = true;\n          return acc;\n        }, {} as any),\n      },\n      getNonDeletedElements(finalElements),\n    ),\n  };\n};\n","import React from \"react\";\nimport clsx from \"clsx\";\n\n// TODO: It might be \"clever\" to add option.icon to the existing component <ButtonSelect />\nexport const ButtonIconSelect = <T extends Object>({\n  options,\n  value,\n  onChange,\n  group,\n}: {\n  options: { value: T; text: string; icon: JSX.Element }[];\n  value: T | null;\n  onChange: (value: T) => void;\n  group: string;\n}) => (\n  <div className=\"buttonList buttonListIcon\">\n    {options.map((option) => (\n      <label\n        key={option.text}\n        className={clsx({ active: value === option.value })}\n        title={option.text}\n      >\n        <input\n          type=\"radio\"\n          name={group}\n          onChange={() => onChange(option.value)}\n          checked={value === option.value}\n        />\n        {option.icon}\n      </label>\n    ))}\n  </div>\n);\n","import React from \"react\";\nimport clsx from \"clsx\";\n\nexport const ButtonSelect = <T extends Object>({\n  options,\n  value,\n  onChange,\n  group,\n}: {\n  options: { value: T; text: string }[];\n  value: T | null;\n  onChange: (value: T) => void;\n  group: string;\n}) => (\n  <div className=\"buttonList\">\n    {options.map((option) => (\n      <label\n        key={option.text}\n        className={clsx({ active: value === option.value })}\n      >\n        <input\n          type=\"radio\"\n          name={group}\n          onChange={() => onChange(option.value)}\n          checked={value === option.value}\n        />\n        {option.text}\n      </label>\n    ))}\n  </div>\n);\n","import React, { useLayoutEffect, useRef, useEffect } from \"react\";\nimport \"./Popover.scss\";\nimport { unstable_batchedUpdates } from \"react-dom\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(event: PointerEvent): void;\n  fitInViewport?: boolean;\n};\n\nexport const Popover = ({\n  children,\n  left,\n  top,\n  onCloseRequest,\n  fitInViewport = false,\n}: Props) => {\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  // ensure the popover doesn't overflow the viewport\n  useLayoutEffect(() => {\n    if (fitInViewport && popoverRef.current) {\n      const element = popoverRef.current;\n      const { x, y, width, height } = element.getBoundingClientRect();\n\n      const viewportWidth = window.innerWidth;\n      if (x + width > viewportWidth) {\n        element.style.left = `${viewportWidth - width}px`;\n      }\n      const viewportHeight = window.innerHeight;\n      if (y + height > viewportHeight) {\n        element.style.top = `${viewportHeight - height}px`;\n      }\n    }\n  }, [fitInViewport]);\n\n  useEffect(() => {\n    if (onCloseRequest) {\n      const handler = (event: PointerEvent) => {\n        if (!popoverRef.current?.contains(event.target as Node)) {\n          unstable_batchedUpdates(() => onCloseRequest(event));\n        }\n      };\n      document.addEventListener(\"pointerdown\", handler, false);\n      return () => document.removeEventListener(\"pointerdown\", handler, false);\n    }\n  }, [onCloseRequest]);\n\n  return (\n    <div className=\"popover\" style={{ top, left }} ref={popoverRef}>\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\n\nimport \"./ColorPicker.scss\";\nimport { isArrowKey, KEYS } from \"../keys\";\nimport { t, getLanguage } from \"../i18n\";\nimport { isWritableElement } from \"../utils\";\nimport colors from \"../colors\";\n\nconst isValidColor = (color: string) => {\n  const style = new Option().style;\n  style.color = color;\n  return !!style.color;\n};\n\nconst getColor = (color: string): string | null => {\n  if (color === \"transparent\") {\n    return color;\n  }\n\n  return isValidColor(color)\n    ? color\n    : isValidColor(`#${color}`)\n    ? `#${color}`\n    : null;\n};\n\n// This is a narrow reimplementation of the awesome react-color Twitter component\n// https://github.com/casesandberg/react-color/blob/master/src/components/twitter/Twitter.js\n\n// Unfortunately, we can't detect keyboard layout in the browser. So this will\n// only work well for QWERTY but not AZERTY or others...\nconst keyBindings = [\n  [\"1\", \"2\", \"3\", \"4\", \"5\"],\n  [\"q\", \"w\", \"e\", \"r\", \"t\"],\n  [\"a\", \"s\", \"d\", \"f\", \"g\"],\n].flat();\n\nconst Picker = ({\n  colors,\n  color,\n  onChange,\n  onClose,\n  label,\n  showInput = true,\n  type,\n}: {\n  colors: string[];\n  color: string | null;\n  onChange: (color: string) => void;\n  onClose: () => void;\n  label: string;\n  showInput: boolean;\n  type: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\";\n}) => {\n  const firstItem = React.useRef<HTMLButtonElement>();\n  const activeItem = React.useRef<HTMLButtonElement>();\n  const gallery = React.useRef<HTMLDivElement>();\n  const colorInput = React.useRef<HTMLInputElement>();\n\n  React.useEffect(() => {\n    // After the component is first mounted focus on first input\n    if (activeItem.current) {\n      activeItem.current.focus();\n    } else if (colorInput.current) {\n      colorInput.current.focus();\n    } else if (gallery.current) {\n      gallery.current.focus();\n    }\n  }, []);\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.TAB) {\n      const { activeElement } = document;\n      if (event.shiftKey) {\n        if (activeElement === firstItem.current) {\n          colorInput.current?.focus();\n          event.preventDefault();\n        }\n      } else if (activeElement === colorInput.current) {\n        firstItem.current?.focus();\n        event.preventDefault();\n      }\n    } else if (isArrowKey(event.key)) {\n      const { activeElement } = document;\n      const isRTL = getLanguage().rtl;\n      const index = Array.prototype.indexOf.call(\n        gallery!.current!.children,\n        activeElement,\n      );\n      if (index !== -1) {\n        const length = gallery!.current!.children.length - (showInput ? 1 : 0);\n        const nextIndex =\n          event.key === (isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT)\n            ? (index + 1) % length\n            : event.key === (isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT)\n            ? (length + index - 1) % length\n            : event.key === KEYS.ARROW_DOWN\n            ? (index + 5) % length\n            : event.key === KEYS.ARROW_UP\n            ? (length + index - 5) % length\n            : index;\n        (gallery!.current!.children![nextIndex] as any).focus();\n      }\n      event.preventDefault();\n    } else if (\n      keyBindings.includes(event.key.toLowerCase()) &&\n      !isWritableElement(event.target)\n    ) {\n      const index = keyBindings.indexOf(event.key.toLowerCase());\n      (gallery!.current!.children![index] as any).focus();\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n  };\n\n  return (\n    <div\n      className={`color-picker color-picker-type-${type}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={t(\"labels.colorPicker\")}\n      onKeyDown={handleKeyDown}\n    >\n      <div className=\"color-picker-triangle color-picker-triangle-shadow\"></div>\n      <div className=\"color-picker-triangle\"></div>\n      <div\n        className=\"color-picker-content\"\n        ref={(el) => {\n          if (el) {\n            gallery.current = el;\n          }\n        }}\n        tabIndex={0}\n      >\n        {colors.map((_color, i) => (\n          <button\n            className=\"color-picker-swatch\"\n            onClick={(event) => {\n              (event.currentTarget as HTMLButtonElement).focus();\n              onChange(_color);\n            }}\n            title={`${_color}  ${keyBindings[i].toUpperCase()}`}\n            aria-label={_color}\n            aria-keyshortcuts={keyBindings[i]}\n            style={{ color: _color }}\n            key={_color}\n            ref={(el) => {\n              if (el && i === 0) {\n                firstItem.current = el;\n              }\n              if (el && _color === color) {\n                activeItem.current = el;\n              }\n            }}\n            onFocus={() => {\n              onChange(_color);\n            }}\n          >\n            {_color === \"transparent\" ? (\n              <div className=\"color-picker-transparent\"></div>\n            ) : undefined}\n            <span className=\"color-picker-keybinding\">{keyBindings[i]}</span>\n          </button>\n        ))}\n        {showInput && (\n          <ColorInput\n            color={color}\n            label={label}\n            onChange={(color) => {\n              onChange(color);\n            }}\n            ref={colorInput}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst ColorInput = React.forwardRef(\n  (\n    {\n      color,\n      onChange,\n      label,\n    }: {\n      color: string | null;\n      onChange: (color: string) => void;\n      label: string;\n    },\n    ref,\n  ) => {\n    const [innerValue, setInnerValue] = React.useState(color);\n    const inputRef = React.useRef(null);\n\n    React.useEffect(() => {\n      setInnerValue(color);\n    }, [color]);\n\n    React.useImperativeHandle(ref, () => inputRef.current);\n\n    const changeColor = React.useCallback(\n      (inputValue: string) => {\n        const value = inputValue.toLowerCase();\n        const color = getColor(value);\n        if (color) {\n          onChange(color);\n        }\n        setInnerValue(value);\n      },\n      [onChange],\n    );\n\n    return (\n      <label className=\"color-input-container\">\n        <div className=\"color-picker-hash\">#</div>\n        <input\n          spellCheck={false}\n          className=\"color-picker-input\"\n          aria-label={label}\n          onChange={(event) => changeColor(event.target.value)}\n          value={(innerValue || \"\").replace(/^#/, \"\")}\n          onBlur={() => setInnerValue(color)}\n          ref={inputRef}\n        />\n      </label>\n    );\n  },\n);\n\nexport const ColorPicker = ({\n  type,\n  color,\n  onChange,\n  label,\n}: {\n  type: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\";\n  color: string | null;\n  onChange: (color: string) => void;\n  label: string;\n}) => {\n  const [isActive, setActive] = React.useState(false);\n  const pickerButton = React.useRef<HTMLButtonElement>(null);\n\n  return (\n    <div>\n      <div className=\"color-picker-control-container\">\n        <button\n          className=\"color-picker-label-swatch\"\n          aria-label={label}\n          style={color ? { \"--swatch-color\": color } : undefined}\n          onClick={() => setActive(!isActive)}\n          ref={pickerButton}\n        />\n        <ColorInput\n          color={color}\n          label={label}\n          onChange={(color) => {\n            onChange(color);\n          }}\n        />\n      </div>\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <Popover\n            onCloseRequest={(event) =>\n              event.target !== pickerButton.current && setActive(false)\n            }\n          >\n            <Picker\n              colors={colors[type]}\n              color={color || null}\n              onChange={(changedColor) => {\n                onChange(changedColor);\n              }}\n              onClose={() => {\n                setActive(false);\n                pickerButton.current?.focus();\n              }}\n              label={label}\n              showInput={false}\n              type={type}\n            />\n          </Popover>\n        ) : null}\n      </React.Suspense>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\n\nimport \"./IconPicker.scss\";\nimport { isArrowKey, KEYS } from \"../keys\";\nimport { getLanguage } from \"../i18n\";\n\nfunction Picker<T>({\n  options,\n  value,\n  label,\n  onChange,\n  onClose,\n}: {\n  label: string;\n  value: T;\n  options: { value: T; text: string; icon: JSX.Element; keyBinding: string }[];\n  onChange: (value: T) => void;\n  onClose: () => void;\n}) {\n  const rFirstItem = React.useRef<HTMLButtonElement>();\n  const rActiveItem = React.useRef<HTMLButtonElement>();\n  const rGallery = React.useRef<HTMLDivElement>(null);\n\n  React.useEffect(() => {\n    // After the component is first mounted focus on first input\n    if (rActiveItem.current) {\n      rActiveItem.current.focus();\n    } else if (rGallery.current) {\n      rGallery.current.focus();\n    }\n  }, []);\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    const pressedOption = options.find(\n      (option) => option.keyBinding === event.key.toLowerCase(),\n    )!;\n\n    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {\n      // Keybinding navigation\n      const index = options.indexOf(pressedOption);\n      (rGallery!.current!.children![index] as any).focus();\n      event.preventDefault();\n    } else if (event.key === KEYS.TAB) {\n      // Tab navigation cycle through options. If the user tabs\n      // away from the picker, close the picker. We need to use\n      // a timeout here to let the stack clear before checking.\n      setTimeout(() => {\n        const active = rActiveItem.current;\n        const docActive = document.activeElement;\n        if (active !== docActive) {\n          onClose();\n        }\n      }, 0);\n    } else if (isArrowKey(event.key)) {\n      // Arrow navigation\n      const { activeElement } = document;\n      const isRTL = getLanguage().rtl;\n      const index = Array.prototype.indexOf.call(\n        rGallery!.current!.children,\n        activeElement,\n      );\n      if (index !== -1) {\n        const length = options.length;\n        let nextIndex = index;\n\n        switch (event.key) {\n          // Select the next option\n          case isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT:\n          case KEYS.ARROW_DOWN: {\n            nextIndex = (index + 1) % length;\n            break;\n          }\n          // Select the previous option\n          case isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT:\n          case KEYS.ARROW_UP: {\n            nextIndex = (length + index - 1) % length;\n            break;\n          }\n        }\n\n        (rGallery.current!.children![nextIndex] as any).focus();\n      }\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      // Close on escape or enter\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n  };\n\n  return (\n    <div\n      className={`picker`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={label}\n      onKeyDown={handleKeyDown}\n    >\n      <div className=\"picker-content\" ref={rGallery}>\n        {options.map((option, i) => (\n          <button\n            className=\"picker-option\"\n            onClick={(event) => {\n              (event.currentTarget as HTMLButtonElement).focus();\n              onChange(option.value);\n            }}\n            title={`${option.text}  ${option.keyBinding.toUpperCase()}`}\n            aria-label={option.text || \"none\"}\n            aria-keyshortcuts={option.keyBinding}\n            key={option.text}\n            ref={(el) => {\n              if (el && i === 0) {\n                rFirstItem.current = el;\n              }\n              if (el && option.value === value) {\n                rActiveItem.current = el;\n              }\n            }}\n            onFocus={() => {\n              onChange(option.value);\n            }}\n          >\n            {option.icon}\n            <span className=\"picker-keybinding\">{option.keyBinding}</span>\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport function IconPicker<T>({\n  value,\n  label,\n  options,\n  onChange,\n  group = \"\",\n}: {\n  label: string;\n  value: T;\n  options: { value: T; text: string; icon: JSX.Element; keyBinding: string }[];\n  onChange: (value: T) => void;\n  group?: string;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  const rPickerButton = React.useRef<any>(null);\n  const isRTL = getLanguage().rtl;\n\n  return (\n    <label className={\"picker-container\"}>\n      <button\n        name={group}\n        className={isActive ? \"active\" : \"\"}\n        aria-label={label}\n        onClick={() => setActive(!isActive)}\n        ref={rPickerButton}\n      >\n        {options.find((option) => option.value === value)?.icon}\n      </button>\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <>\n            <Popover\n              onCloseRequest={(event) =>\n                event.target !== rPickerButton.current && setActive(false)\n              }\n              {...(isRTL ? { right: 5.5 } : { left: -5.5 })}\n            >\n              <Picker\n                options={options}\n                value={value}\n                label={label}\n                onChange={onChange}\n                onClose={() => {\n                  setActive(false);\n                  rPickerButton.current?.focus();\n                }}\n              />\n            </Popover>\n            <div className=\"picker-triangle\" />\n          </>\n        ) : null}\n      </React.Suspense>\n    </label>\n  );\n}\n","import React from \"react\";\nimport { AppState } from \"../../src/types\";\nimport { ButtonIconSelect } from \"../components/ButtonIconSelect\";\nimport { ButtonSelect } from \"../components/ButtonSelect\";\nimport { ColorPicker } from \"../components/ColorPicker\";\nimport { IconPicker } from \"../components/IconPicker\";\nimport {\n  ArrowheadArrowIcon,\n  ArrowheadBarIcon,\n  ArrowheadDotIcon,\n  ArrowheadNoneIcon,\n  EdgeRoundIcon,\n  EdgeSharpIcon,\n  FillCrossHatchIcon,\n  FillHachureIcon,\n  FillSolidIcon,\n  SloppinessArchitectIcon,\n  SloppinessArtistIcon,\n  SloppinessCartoonistIcon,\n  StrokeStyleDashedIcon,\n  StrokeStyleDottedIcon,\n  StrokeStyleSolidIcon,\n  StrokeWidthIcon,\n} from \"../components/icons\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE } from \"../constants\";\nimport {\n  getNonDeletedElements,\n  isTextElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isLinearElement, isLinearElementType } from \"../element/typeChecks\";\nimport {\n  Arrowhead,\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  FontFamily,\n  TextAlign,\n} from \"../element/types\";\nimport { getLanguage, t } from \"../i18n\";\nimport { randomInteger } from \"../random\";\nimport {\n  canChangeSharpness,\n  canHaveArrowheads,\n  getCommonAttributeOfSelectedElements,\n  getTargetElements,\n  isSomeElementSelected,\n} from \"../scene\";\nimport { register } from \"./register\";\n\nconst changeProperty = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  callback: (element: ExcalidrawElement) => ExcalidrawElement,\n) => {\n  return elements.map((element) => {\n    if (\n      appState.selectedElementIds[element.id] ||\n      element.id === appState.editingElement?.id\n    ) {\n      return callback(element);\n    }\n    return element;\n  });\n};\n\nconst getFormValue = function <T>(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n  defaultValue?: T,\n): T | null {\n  const editingElement = appState.editingElement;\n  const nonDeletedElements = getNonDeletedElements(elements);\n  return (\n    (editingElement && getAttribute(editingElement)) ??\n    (isSomeElementSelected(nonDeletedElements, appState)\n      ? getCommonAttributeOfSelectedElements(\n          nonDeletedElements,\n          appState,\n          getAttribute,\n        )\n      : defaultValue) ??\n    null\n  );\n};\n\nexport const actionChangeStrokeColor = register({\n  name: \"changeStrokeColor\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeColor: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeColor: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.stroke\")}</h3>\n      <ColorPicker\n        type=\"elementStroke\"\n        label={t(\"labels.stroke\")}\n        color={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeColor,\n          appState.currentItemStrokeColor,\n        )}\n        onChange={updateData}\n      />\n    </>\n  ),\n});\n\nexport const actionChangeBackgroundColor = register({\n  name: \"changeBackgroundColor\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          backgroundColor: value,\n        }),\n      ),\n      appState: { ...appState, currentItemBackgroundColor: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.background\")}</h3>\n      <ColorPicker\n        type=\"elementBackground\"\n        label={t(\"labels.background\")}\n        color={getFormValue(\n          elements,\n          appState,\n          (element) => element.backgroundColor,\n          appState.currentItemBackgroundColor,\n        )}\n        onChange={updateData}\n      />\n    </>\n  ),\n});\n\nexport const actionChangeFillStyle = register({\n  name: \"changeFillStyle\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          fillStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemFillStyle: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.fill\")}</legend>\n      <ButtonIconSelect\n        options={[\n          {\n            value: \"hachure\",\n            text: t(\"labels.hachure\"),\n            icon: <FillHachureIcon appearance={appState.appearance} />,\n          },\n          {\n            value: \"cross-hatch\",\n            text: t(\"labels.crossHatch\"),\n            icon: <FillCrossHatchIcon appearance={appState.appearance} />,\n          },\n          {\n            value: \"solid\",\n            text: t(\"labels.solid\"),\n            icon: <FillSolidIcon appearance={appState.appearance} />,\n          },\n        ]}\n        group=\"fill\"\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.fillStyle,\n          appState.currentItemFillStyle,\n        )}\n        onChange={(value) => {\n          updateData(value);\n        }}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeWidth = register({\n  name: \"changeStrokeWidth\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeWidth: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeWidth: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeWidth\")}</legend>\n      <ButtonIconSelect\n        group=\"stroke-width\"\n        options={[\n          {\n            value: 1,\n            text: t(\"labels.thin\"),\n            icon: (\n              <StrokeWidthIcon\n                appearance={appState.appearance}\n                strokeWidth={2}\n              />\n            ),\n          },\n          {\n            value: 2,\n            text: t(\"labels.bold\"),\n            icon: (\n              <StrokeWidthIcon\n                appearance={appState.appearance}\n                strokeWidth={6}\n              />\n            ),\n          },\n          {\n            value: 4,\n            text: t(\"labels.extraBold\"),\n            icon: (\n              <StrokeWidthIcon\n                appearance={appState.appearance}\n                strokeWidth={10}\n              />\n            ),\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeWidth,\n          appState.currentItemStrokeWidth,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSloppiness = register({\n  name: \"changeSloppiness\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          seed: randomInteger(),\n          roughness: value,\n        }),\n      ),\n      appState: { ...appState, currentItemRoughness: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.sloppiness\")}</legend>\n      <ButtonIconSelect\n        group=\"sloppiness\"\n        options={[\n          {\n            value: 0,\n            text: t(\"labels.architect\"),\n            icon: <SloppinessArchitectIcon appearance={appState.appearance} />,\n          },\n          {\n            value: 1,\n            text: t(\"labels.artist\"),\n            icon: <SloppinessArtistIcon appearance={appState.appearance} />,\n          },\n          {\n            value: 2,\n            text: t(\"labels.cartoonist\"),\n            icon: <SloppinessCartoonistIcon appearance={appState.appearance} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.roughness,\n          appState.currentItemRoughness,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeStyle = register({\n  name: \"changeStrokeStyle\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeStyle: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeStyle\")}</legend>\n      <ButtonIconSelect\n        group=\"strokeStyle\"\n        options={[\n          {\n            value: \"solid\",\n            text: t(\"labels.strokeStyle_solid\"),\n            icon: <StrokeStyleSolidIcon appearance={appState.appearance} />,\n          },\n          {\n            value: \"dashed\",\n            text: t(\"labels.strokeStyle_dashed\"),\n            icon: <StrokeStyleDashedIcon appearance={appState.appearance} />,\n          },\n          {\n            value: \"dotted\",\n            text: t(\"labels.strokeStyle_dotted\"),\n            icon: <StrokeStyleDottedIcon appearance={appState.appearance} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeStyle,\n          appState.currentItemStrokeStyle,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeOpacity = register({\n  name: \"changeOpacity\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          opacity: value,\n        }),\n      ),\n      appState: { ...appState, currentItemOpacity: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <label className=\"control-label\">\n      {t(\"labels.opacity\")}\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"100\"\n        step=\"10\"\n        onChange={(event) => updateData(+event.target.value)}\n        onWheel={(event) => {\n          event.stopPropagation();\n          const target = event.target as HTMLInputElement;\n          const STEP = 10;\n          const MAX = 100;\n          const MIN = 0;\n          const value = +target.value;\n\n          if (event.deltaY < 0 && value < MAX) {\n            updateData(value + STEP);\n          } else if (event.deltaY > 0 && value > MIN) {\n            updateData(value - STEP);\n          }\n        }}\n        value={\n          getFormValue(\n            elements,\n            appState,\n            (element) => element.opacity,\n            appState.currentItemOpacity,\n          ) ?? undefined\n        }\n      />\n    </label>\n  ),\n});\n\nexport const actionChangeFontSize = register({\n  name: \"changeFontSize\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            fontSize: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemFontSize: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.fontSize\")}</legend>\n      <ButtonSelect\n        group=\"font-size\"\n        options={[\n          { value: 16, text: t(\"labels.small\") },\n          { value: 20, text: t(\"labels.medium\") },\n          { value: 28, text: t(\"labels.large\") },\n          { value: 36, text: t(\"labels.veryLarge\") },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => isTextElement(element) && element.fontSize,\n          appState.currentItemFontSize || DEFAULT_FONT_SIZE,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeFontFamily = register({\n  name: \"changeFontFamily\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            fontFamily: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemFontFamily: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const options: { value: FontFamily; text: string }[] = [\n      { value: 1, text: t(\"labels.handDrawn\") },\n      { value: 2, text: t(\"labels.normal\") },\n      { value: 3, text: t(\"labels.code\") },\n      { value: 4, text: t(\"labels.handChinese\") },\n    ];\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.fontFamily\")}</legend>\n        <ButtonSelect<FontFamily | false>\n          group=\"font-family\"\n          options={options}\n          value={getFormValue(\n            elements,\n            appState,\n            (element) => isTextElement(element) && element.fontFamily,\n            appState.currentItemFontFamily || DEFAULT_FONT_FAMILY,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeTextAlign = register({\n  name: \"changeTextAlign\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            textAlign: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemTextAlign: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.textAlign\")}</legend>\n      <ButtonSelect<TextAlign | false>\n        group=\"text-align\"\n        options={[\n          { value: \"left\", text: t(\"labels.left\") },\n          { value: \"center\", text: t(\"labels.center\") },\n          { value: \"right\", text: t(\"labels.right\") },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => isTextElement(element) && element.textAlign,\n          appState.currentItemTextAlign,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSharpness = register({\n  name: \"changeSharpness\",\n  perform: (elements, appState, value) => {\n    const targetElements = getTargetElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    const shouldUpdateForNonLinearElements = targetElements.length\n      ? targetElements.every((el) => !isLinearElement(el))\n      : !isLinearElementType(appState.elementType);\n    const shouldUpdateForLinearElements = targetElements.length\n      ? targetElements.every(isLinearElement)\n      : isLinearElementType(appState.elementType);\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeSharpness: value,\n        }),\n      ),\n      appState: {\n        ...appState,\n        currentItemStrokeSharpness: shouldUpdateForNonLinearElements\n          ? value\n          : appState.currentItemStrokeSharpness,\n        currentItemLinearStrokeSharpness: shouldUpdateForLinearElements\n          ? value\n          : appState.currentItemLinearStrokeSharpness,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.edges\")}</legend>\n      <ButtonIconSelect\n        group=\"edges\"\n        options={[\n          {\n            value: \"sharp\",\n            text: t(\"labels.sharp\"),\n            icon: <EdgeSharpIcon appearance={appState.appearance} />,\n          },\n          {\n            value: \"round\",\n            text: t(\"labels.round\"),\n            icon: <EdgeRoundIcon appearance={appState.appearance} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeSharpness,\n          (canChangeSharpness(appState.elementType) &&\n            (isLinearElementType(appState.elementType)\n              ? appState.currentItemLinearStrokeSharpness\n              : appState.currentItemStrokeSharpness)) ||\n            null,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeArrowhead = register({\n  name: \"changeArrowhead\",\n  perform: (\n    elements,\n    appState,\n    value: { position: \"start\" | \"end\"; type: Arrowhead },\n  ) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isLinearElement(el)) {\n          const { position, type } = value;\n\n          if (position === \"start\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              startArrowhead: type,\n            });\n            return element;\n          } else if (position === \"end\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              endArrowhead: type,\n            });\n            return element;\n          }\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        [value.position === \"start\"\n          ? \"currentItemStartArrowhead\"\n          : \"currentItemEndArrowhead\"]: value.type,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const isRTL = getLanguage().rtl;\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.arrowheads\")}</legend>\n        <div className=\"iconSelectList\">\n          <IconPicker\n            label=\"arrowhead_start\"\n            options={[\n              {\n                value: null,\n                text: t(\"labels.arrowhead_none\"),\n                icon: <ArrowheadNoneIcon appearance={appState.appearance} />,\n                keyBinding: \"q\",\n              },\n              {\n                value: \"arrow\",\n                text: t(\"labels.arrowhead_arrow\"),\n                icon: (\n                  <ArrowheadArrowIcon\n                    appearance={appState.appearance}\n                    flip={!isRTL}\n                  />\n                ),\n                keyBinding: \"w\",\n              },\n              {\n                value: \"bar\",\n                text: t(\"labels.arrowhead_bar\"),\n                icon: (\n                  <ArrowheadBarIcon\n                    appearance={appState.appearance}\n                    flip={!isRTL}\n                  />\n                ),\n                keyBinding: \"e\",\n              },\n              {\n                value: \"dot\",\n                text: t(\"labels.arrowhead_dot\"),\n                icon: (\n                  <ArrowheadDotIcon\n                    appearance={appState.appearance}\n                    flip={!isRTL}\n                  />\n                ),\n                keyBinding: \"r\",\n              },\n            ]}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              appState,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.startArrowhead\n                  : appState.currentItemStartArrowhead,\n              appState.currentItemStartArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"start\", type: value })}\n          />\n          <IconPicker\n            label=\"arrowhead_end\"\n            group=\"arrowheads\"\n            options={[\n              {\n                value: null,\n                text: t(\"labels.arrowhead_none\"),\n                keyBinding: \"q\",\n                icon: <ArrowheadNoneIcon appearance={appState.appearance} />,\n              },\n              {\n                value: \"arrow\",\n                text: t(\"labels.arrowhead_arrow\"),\n                keyBinding: \"w\",\n                icon: (\n                  <ArrowheadArrowIcon\n                    appearance={appState.appearance}\n                    flip={isRTL}\n                  />\n                ),\n              },\n              {\n                value: \"bar\",\n                text: t(\"labels.arrowhead_bar\"),\n                keyBinding: \"e\",\n                icon: (\n                  <ArrowheadBarIcon\n                    appearance={appState.appearance}\n                    flip={isRTL}\n                  />\n                ),\n              },\n              {\n                value: \"dot\",\n                text: t(\"labels.arrowhead_dot\"),\n                keyBinding: \"r\",\n                icon: (\n                  <ArrowheadDotIcon\n                    appearance={appState.appearance}\n                    flip={isRTL}\n                  />\n                ),\n              },\n            ]}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              appState,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.endArrowhead\n                  : appState.currentItemEndArrowhead,\n              appState.currentItemEndArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"end\", type: value })}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n","import React from \"react\";\nimport { getDefaultAppState } from \"../appState\";\nimport { ColorPicker } from \"../components/ColorPicker\";\nimport { resetZoom, trash, zoomIn, zoomOut } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { ZOOM_STEP } from \"../constants\";\nimport { getCommonBounds, getNonDeletedElements } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { CODES, KEYS } from \"../keys\";\nimport { getNormalizedZoom, getSelectedElements } from \"../scene\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nexport const actionChangeViewBackgroundColor = register({\n  name: \"changeViewBackgroundColor\",\n  perform: (_, appState, value) => {\n    return {\n      appState: { ...appState, viewBackgroundColor: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => {\n    return (\n      <div style={{ position: \"relative\" }}>\n        <ColorPicker\n          label={t(\"labels.canvasBackground\")}\n          type=\"canvasBackground\"\n          color={appState.viewBackgroundColor}\n          onChange={(color) => updateData(color)}\n        />\n      </div>\n    );\n  },\n});\n\nexport const actionClearCanvas = register({\n  name: \"clearCanvas\",\n  perform: (elements, appState: AppState) => {\n    return {\n      elements: elements.map((element) =>\n        newElementWith(element, { isDeleted: true }),\n      ),\n      appState: {\n        ...getDefaultAppState(),\n        appearance: appState.appearance,\n        elementLocked: appState.elementLocked,\n        exportBackground: appState.exportBackground,\n        exportEmbedScene: appState.exportEmbedScene,\n        gridSize: appState.gridSize,\n        shouldAddWatermark: appState.shouldAddWatermark,\n        showStats: appState.showStats,\n        pasteDialog: appState.pasteDialog,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={trash}\n      title={t(\"buttons.clearReset\")}\n      aria-label={t(\"buttons.clearReset\")}\n      showAriaLabel={useIsMobile()}\n      onClick={() => {\n        if (window.confirm(t(\"alerts.clearReset\"))) {\n          updateData(null);\n        }\n      }}\n    />\n  ),\n});\n\nexport const actionZoomIn = register({\n  name: \"zoomIn\",\n  perform: (_elements, appState) => {\n    const zoom = getNewZoom(\n      getNormalizedZoom(appState.zoom.value + ZOOM_STEP),\n      appState.zoom,\n      { left: appState.offsetLeft, top: appState.offsetTop },\n      { x: appState.width / 2, y: appState.height / 2 },\n    );\n    return {\n      appState: {\n        ...appState,\n        zoom,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={zoomIn}\n      title={`${t(\"buttons.zoomIn\")}  ${getShortcutKey(\"CtrlOrCmd++\")}`}\n      aria-label={t(\"buttons.zoomIn\")}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionZoomOut = register({\n  name: \"zoomOut\",\n  perform: (_elements, appState) => {\n    const zoom = getNewZoom(\n      getNormalizedZoom(appState.zoom.value - ZOOM_STEP),\n      appState.zoom,\n      { left: appState.offsetLeft, top: appState.offsetTop },\n      { x: appState.width / 2, y: appState.height / 2 },\n    );\n\n    return {\n      appState: {\n        ...appState,\n        zoom,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={zoomOut}\n      title={`${t(\"buttons.zoomOut\")}  ${getShortcutKey(\"CtrlOrCmd+-\")}`}\n      aria-label={t(\"buttons.zoomOut\")}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionResetZoom = register({\n  name: \"resetZoom\",\n  perform: (_elements, appState) => {\n    return {\n      appState: {\n        ...appState,\n        zoom: getNewZoom(\n          1 as NormalizedZoomValue,\n          appState.zoom,\n          { left: appState.offsetLeft, top: appState.offsetTop },\n          {\n            x: appState.width / 2,\n            y: appState.height / 2,\n          },\n        ),\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={resetZoom}\n      title={t(\"buttons.resetZoom\")}\n      aria-label={t(\"buttons.resetZoom\")}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nconst zoomValueToFitBoundsOnViewport = (\n  bounds: [number, number, number, number],\n  viewportDimensions: { width: number; height: number },\n) => {\n  const [x1, y1, x2, y2] = bounds;\n  const commonBoundsWidth = x2 - x1;\n  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;\n  const commonBoundsHeight = y2 - y1;\n  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;\n  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);\n  const zoomAdjustedToSteps =\n    Math.floor(smallestZoomValue / ZOOM_STEP) * ZOOM_STEP;\n  const clampedZoomValueToFitElements = Math.min(\n    Math.max(zoomAdjustedToSteps, ZOOM_STEP),\n    1,\n  );\n  return clampedZoomValueToFitElements as NormalizedZoomValue;\n};\n\nconst zoomToFitElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  zoomToSelection: boolean,\n) => {\n  const nonDeletedElements = getNonDeletedElements(elements);\n  const selectedElements = getSelectedElements(nonDeletedElements, appState);\n\n  const commonBounds =\n    zoomToSelection && selectedElements.length > 0\n      ? getCommonBounds(selectedElements)\n      : getCommonBounds(nonDeletedElements);\n\n  const zoomValue = zoomValueToFitBoundsOnViewport(commonBounds, {\n    width: appState.width,\n    height: appState.height,\n  });\n  const newZoom = getNewZoom(zoomValue, appState.zoom, {\n    left: appState.offsetLeft,\n    top: appState.offsetTop,\n  });\n\n  const [x1, y1, x2, y2] = commonBounds;\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n  return {\n    appState: {\n      ...appState,\n      ...centerScrollOn({\n        scenePoint: { x: centerX, y: centerY },\n        viewportDimensions: {\n          width: appState.width,\n          height: appState.height,\n        },\n        zoom: newZoom,\n      }),\n      zoom: newZoom,\n    },\n    commitToHistory: false,\n  };\n};\n\nexport const actionZoomToSelected = register({\n  name: \"zoomToSelection\",\n  perform: (elements, appState) => zoomToFitElements(elements, appState, true),\n  keyTest: (event) =>\n    event.code === CODES.TWO &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionZoomToFit = register({\n  name: \"zoomToFit\",\n  perform: (elements, appState) => zoomToFitElements(elements, appState, false),\n  keyTest: (event) =>\n    event.code === CODES.ONE &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n","import { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { resetCursor } from \"../utils\";\nimport React from \"react\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport {\n  maybeBindLinearElement,\n  bindOrUnbindLinearElement,\n} from \"../element/binding\";\nimport { isBindingElement } from \"../element/typeChecks\";\n\nexport const actionFinalize = register({\n  name: \"finalize\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(\n            element,\n            startBindingElement,\n            endBindingElement,\n          );\n        }\n        return {\n          elements:\n            element.points.length < 2 || isInvisiblySmallElement(element)\n              ? elements.filter((el) => el.id !== element.id)\n              : undefined,\n          appState: {\n            ...appState,\n            editingLinearElement: null,\n          },\n          commitToHistory: true,\n        };\n      }\n    }\n\n    let newElements = elements;\n    if (window.document.activeElement instanceof HTMLElement) {\n      window.document.activeElement.blur();\n    }\n\n    const multiPointElement = appState.multiElement\n      ? appState.multiElement\n      : appState.editingElement?.type === \"draw\"\n      ? appState.editingElement\n      : null;\n\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (\n        multiPointElement.type !== \"draw\" &&\n        appState.lastPointerDownWith !== \"touch\"\n      ) {\n        const { points, lastCommittedPoint } = multiPointElement;\n        if (\n          !lastCommittedPoint ||\n          points[points.length - 1] !== lastCommittedPoint\n        ) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1),\n          });\n        }\n      }\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      }\n\n      // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n      const isLoop = isPathALoop(multiPointElement.points);\n      if (\n        multiPointElement.type === \"line\" ||\n        multiPointElement.type === \"draw\"\n      ) {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) =>\n              index === linePoints.length - 1\n                ? ([firstPoint[0], firstPoint[1]] as const)\n                : point,\n            ),\n          });\n        }\n      }\n\n      if (\n        isBindingElement(multiPointElement) &&\n        !isLoop &&\n        multiPointElement.points.length > 1\n      ) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          multiPointElement,\n          -1,\n        );\n        maybeBindLinearElement(\n          multiPointElement,\n          appState,\n          Scene.getScene(multiPointElement)!,\n          { x, y },\n        );\n      }\n\n      if (!appState.elementLocked && appState.elementType !== \"draw\") {\n        appState.selectedElementIds[multiPointElement.id] = true;\n      }\n    }\n    if (\n      (!appState.elementLocked && appState.elementType !== \"draw\") ||\n      !multiPointElement\n    ) {\n      resetCursor();\n    }\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        elementType:\n          (appState.elementLocked || appState.elementType === \"draw\") &&\n          multiPointElement\n            ? appState.elementType\n            : \"selection\",\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds:\n          multiPointElement &&\n          !appState.elementLocked &&\n          appState.elementType !== \"draw\"\n            ? {\n                ...appState.selectedElementIds,\n                [multiPointElement.id]: true,\n              }\n            : appState.selectedElementIds,\n      },\n      commitToHistory: appState.elementType === \"draw\",\n    };\n  },\n  keyTest: (event, appState) =>\n    (event.key === KEYS.ESCAPE &&\n      (appState.editingLinearElement !== null ||\n        (!appState.draggingElement && appState.multiElement === null))) ||\n    ((event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n      appState.multiElement !== null),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={done}\n      title={t(\"buttons.done\")}\n      aria-label={t(\"buttons.done\")}\n      onClick={updateData}\n      visible={appState.multiElement != null}\n    />\n  ),\n});\n","import \"./TextInput.scss\";\n\nimport React, { Component } from \"react\";\nimport { selectNode, removeSelection } from \"../utils\";\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n  label: string;\n};\n\nexport class ProjectName extends Component<Props> {\n  private handleFocus = (event: React.FocusEvent<HTMLElement>) => {\n    selectNode(event.currentTarget);\n  };\n\n  private handleBlur = (event: React.FocusEvent<HTMLElement>) => {\n    const value = event.currentTarget.innerText.trim();\n    if (value !== this.props.value) {\n      this.props.onChange(value);\n    }\n    removeSelection();\n  };\n\n  private handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n      if (event.nativeEvent.isComposing || event.keyCode === 229) {\n        return;\n      }\n      event.currentTarget.blur();\n    }\n  };\n  private makeEditable = (editable: HTMLSpanElement | null) => {\n    if (!editable) {\n      return;\n    }\n    try {\n      editable.contentEditable = \"plaintext-only\";\n    } catch {\n      editable.contentEditable = \"true\";\n    }\n  };\n\n  public render() {\n    return (\n      <span\n        suppressContentEditableWarning\n        ref={this.makeEditable}\n        data-type=\"wysiwyg\"\n        className=\"TextInput\"\n        role=\"textbox\"\n        aria-label={this.props.label}\n        onBlur={this.handleBlur}\n        onKeyDown={this.handleKeyDown}\n        onFocus={this.handleFocus}\n      >\n        {this.props.value}\n      </span>\n    );\n  }\n}\n","import \"./Tooltip.scss\";\n\nimport React from \"react\";\n\ntype TooltipProps = {\n  children: React.ReactNode;\n  label: string;\n  position?: \"above\" | \"below\";\n  long?: boolean;\n};\n\nexport const Tooltip = ({\n  children,\n  label,\n  position = \"below\",\n  long = false,\n}: TooltipProps) => (\n  <div className=\"Tooltip\">\n    <span\n      className={\n        position === \"above\"\n          ? \"Tooltip__label Tooltip__label--above\"\n          : \"Tooltip__label Tooltip__label--below\"\n      }\n      style={{ width: long ? \"50ch\" : \"10ch\" }}\n    >\n      {label}\n    </span>\n    {children}\n  </div>\n);\n","/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport const roundRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height,\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  context.stroke();\n};\n","import colors from \"./colors\";\nimport { AppState } from \"./types\";\n\nexport const getClientColors = (clientId: string, appState: AppState) => {\n  if (appState?.collaborators) {\n    const currentUser = appState.collaborators.get(clientId);\n    if (currentUser?.color) {\n      return currentUser.color;\n    }\n  }\n  // Naive way of getting an integer out of the clientId\n  const sum = clientId.split(\"\").reduce((a, str) => a + str.charCodeAt(0), 0);\n\n  // Skip transparent background.\n  const backgrounds = colors.elementBackground.slice(1);\n  const strokes = colors.elementStroke.slice(1);\n  return {\n    background: backgrounds[sum % backgrounds.length],\n    stroke: strokes[sum % strokes.length],\n  };\n};\n\nexport const getClientInitials = (username?: string | null) => {\n  if (!username) {\n    return \"?\";\n  }\n  const names = username.trim().split(\" \");\n\n  if (names.length < 2) {\n    return names[0].substring(0, 2).toUpperCase();\n  }\n\n  const firstName = names[0];\n  const lastName = names[names.length - 1];\n\n  return (firstName[0] + lastName[0]).toUpperCase();\n};\n","export enum UserIdleState {\n  ACTIVE = \"active\",\n  AWAY = \"away\",\n  IDLE = \"idle\",\n}\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { AppState, Zoom } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n  ExcalidrawBindableElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n} from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport {\n  SuggestedBinding,\n  SuggestedPointBinding,\n  isBindingEnabled,\n} from \"../element/binding\";\nimport {\n  TransformHandles,\n  TransformHandleType,\n} from \"../element/transformHandles\";\nimport { viewportCoordsToSceneCoords, supportsEmoji } from \"../utils\";\nimport { UserIdleState } from \"../excalidraw-app/collab/types\";\n\nconst hasEmojiSupport = supportsEmoji();\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill: boolean = false,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeDiamondWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeEllipseWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (\n  context: CanvasRenderingContext2D,\n  cx: number,\n  cy: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  const origStrokeStyle = context.strokeStyle;\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.strokeStyle = origStrokeStyle;\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  sceneState: SceneState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const origStrokeStyle = context.strokeStyle;\n  const lineWidth = context.lineWidth;\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach(\n    (point, idx) => {\n      context.strokeStyle = \"red\";\n      context.setLineDash([]);\n      context.fillStyle =\n        appState.editingLinearElement?.activePointIndex === idx\n          ? \"rgba(255, 127, 127, 0.9)\"\n          : \"rgba(255, 255, 255, 0.9)\";\n      const { POINT_HANDLE_SIZE } = LinearElementEditor;\n      fillCircle(\n        context,\n        point[0],\n        point[1],\n        POINT_HANDLE_SIZE / 2 / sceneState.zoom.value,\n      );\n    },\n  );\n  context.setLineDash([]);\n  context.lineWidth = lineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  context.strokeStyle = origStrokeStyle;\n};\n\nexport const renderScene = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    // doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n    renderGrid = true,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n    renderGrid?: boolean;\n  } = {},\n) => {\n  if (!canvas) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 || // #RGBA\n      sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n      /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = sceneState.zoom.translation.x;\n  const zoomTranslationY = sceneState.zoom.translation.y;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom.value, sceneState.zoom.value);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(\n      context,\n      appState.gridSize,\n      -Math.ceil(zoomTranslationX / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollX % appState.gridSize),\n      -Math.ceil(zoomTranslationY / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollY % appState.gridSize),\n      normalizedCanvasWidth / sceneState.zoom.value,\n      normalizedCanvasHeight / sceneState.zoom.value,\n    );\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n      zoom: sceneState.zoom,\n      offsetLeft: appState.offsetLeft,\n      offsetTop: appState.offsetTop,\n      scrollX: sceneState.scrollX,\n      scrollY: sceneState.scrollY,\n    }),\n  );\n\n  visibleElements.forEach((element) => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(\n      appState.editingLinearElement.elementId,\n    );\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  }\n\n  // Paint selection element\n  if (selectionElement) {\n    renderElement(\n      selectionElement,\n      rc,\n      context,\n      renderOptimizations,\n      sceneState,\n    );\n  }\n\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings\n      .filter((binding) => binding != null)\n      .forEach((suggestedBinding) => {\n        renderBindingHighlight(context, sceneState, suggestedBinding!);\n      });\n  }\n\n  // Paint selected elements\n  if (\n    renderSelection &&\n    !appState.multiElement &&\n    !appState.editingLinearElement\n  ) {\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (\n        appState.selectedElementIds[element.id] &&\n        !isSelectedViaGroup(appState, element)\n      ) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = getClientColors(socketId, appState);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        const [\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n        ] = getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors,\n        });\n      }\n      return acc;\n    }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[] }[]);\n\n    const addSelectionForGroupId = (groupId: GroupId) => {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(\n        groupElements,\n      );\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black],\n      });\n    };\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach((selection) =>\n      renderSelectionBorder(context, sceneState, selection),\n    );\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize transformHandles\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n        \"mouse\", // when we render we don't know which pointer type so use mouse\n      );\n      if (!appState.viewModeEnabled) {\n        renderTransformHandles(\n          context,\n          sceneState,\n          transformHandles,\n          locallySelectedElements[0].angle,\n        );\n      }\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords(\n        [x1, y1, x2, y2],\n        0,\n        sceneState.zoom,\n        \"mouse\",\n        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n      );\n      renderTransformHandles(context, sceneState, transformHandles, 0);\n    }\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  }\n\n  // Reset zoom\n  context.scale(1 / sceneState.zoom.value, 1 / sceneState.zoom.value);\n  context.translate(-zoomTranslationX, -zoomTranslationY);\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n\n    x -= appState.offsetLeft;\n    y -= appState.offsetTop;\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = getClientColors(clientId, appState);\n\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n\n    const userState = sceneState.remotePointerUserStates[clientId];\n    if (isOutOfBounds || userState === UserIdleState.AWAY) {\n      context.globalAlpha = 0.48;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    const username = sceneState.remotePointerUsernames[clientId];\n    let usernameAndIdleState;\n    if (hasEmojiSupport) {\n      usernameAndIdleState = `${username ? `${username} ` : \"\"}${\n        userState === UserIdleState.AWAY\n          ? \"\"\n          : userState === UserIdleState.IDLE\n          ? \"\"\n          : \"\"\n      }`;\n    } else {\n      usernameAndIdleState = `${username ? `${username}` : \"\"}${\n        userState === UserIdleState.AWAY\n          ? ` (${UserIdleState.AWAY})`\n          : userState === UserIdleState.IDLE\n          ? ` (${UserIdleState.IDLE})`\n          : \"\"\n      }`;\n    }\n\n    if (!isOutOfBounds && usernameAndIdleState) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(usernameAndIdleState);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n\n      context.fillText(\n        usernameAndIdleState,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      if (key === \"rotation\") {\n        fillCircle(\n          context,\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          transformHandle[2] / 2,\n        );\n      } else {\n        strokeRectWithRotation(\n          context,\n          transformHandle[0],\n          transformHandle[1],\n          transformHandle[2],\n          transformHandle[3],\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.lineWidth = lineWidth;\n    }\n  });\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  elementProperties: {\n    angle: number;\n    elementX1: number;\n    elementY1: number;\n    elementX2: number;\n    elementY2: number;\n    selectionColors: string[];\n  },\n) => {\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors,\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const initialLineDash = context.getLineDash();\n  const lineWidth = context.lineWidth;\n  const lineDashOffset = context.lineDashOffset;\n  const strokeStyle = context.strokeStyle;\n\n  const dashedLinePadding = 4 / sceneState.zoom.value;\n  const dashWidth = 8 / sceneState.zoom.value;\n  const spaceWidth = 4 / sceneState.zoom.value;\n\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    context.setLineDash([\n      dashWidth,\n      spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n    ]);\n    context.lineDashOffset = (dashWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      elementX1 - dashedLinePadding,\n      elementY1 - dashedLinePadding,\n      elementWidth + dashedLinePadding * 2,\n      elementHeight + dashedLinePadding * 2,\n      elementX1 + elementWidth / 2,\n      elementY1 + elementHeight / 2,\n      angle,\n    );\n  }\n  context.lineDashOffset = lineDashOffset;\n  context.strokeStyle = strokeStyle;\n  context.lineWidth = lineWidth;\n  context.setLineDash(initialLineDash);\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  suggestedBinding: SuggestedBinding,\n) => {\n  // preserve context settings to restore later\n  const originalStrokeStyle = context.strokeStyle;\n  const originalLineWidth = context.lineWidth;\n\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  renderHighlight(context, suggestedBinding as any);\n\n  // restore context settings\n  context.strokeStyle = originalStrokeStyle;\n  context.lineWidth = originalLineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      strokeRectWithRotation(\n        context,\n        x1 - padding,\n        y1 - padding,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = (padding * side) / height;\n      const hPadding = (padding * side) / width;\n      strokeDiamondWithRotation(\n        context,\n        width + wPadding * 2,\n        height + hPadding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(\n        context,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n    );\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nconst isVisibleElement = (\n  element: ExcalidrawElement,\n  canvasWidth: number,\n  canvasHeight: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + canvasWidth,\n      clientY: viewTransformations.offsetTop + canvasHeight,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      renderElementToSvg(\n        element,\n        rsvg,\n        svgRoot,\n        element.x + offsetX,\n        element.y + offsetY,\n      );\n    }\n  });\n};\n","import rough from \"roughjs/bin/rough\";\nimport oc from \"open-color\";\nimport { newTextElement } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, SVG_NS } from \"../utils\";\nimport { AppState } from \"../types\";\nimport { t } from \"../i18n\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_VERTICAL_ALIGN } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\nconst WATERMARK_HEIGHT = 16;\n\nexport const exportToCanvas = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n  },\n  createCanvas: (\n    width: number,\n    height: number,\n  ) => { canvas: HTMLCanvasElement; scale: number } = (width, height) => {\n    const tempCanvas = document.createElement(\"canvas\");\n    tempCanvas.width = width * scale;\n    tempCanvas.height = height * scale;\n    return { canvas: tempCanvas, scale };\n  },\n) => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [minX, minY, width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  );\n\n  const { canvas: tempCanvas, scale: newScale = scale } = createCanvas(\n    width,\n    height,\n  );\n\n  renderScene(\n    sceneElements,\n    appState,\n    null,\n    newScale,\n    rough.canvas(tempCanvas),\n    tempCanvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: -minX + exportPadding,\n      scrollY: -minY + exportPadding,\n      zoom: getDefaultAppState().zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n      remotePointerUserStates: {},\n    },\n    {\n      renderScrollbars: false,\n      renderSelection: false,\n      renderOptimizations: false,\n      renderGrid: false,\n    },\n  );\n\n  return tempCanvas;\n};\n\nexport const exportToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    scale = 1,\n    shouldAddWatermark,\n    metadata = \"\",\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    scale?: number;\n    viewBackgroundColor: string;\n    shouldAddWatermark: boolean;\n    metadata?: string;\n  },\n): SVGSVGElement => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [minX, minY, width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  );\n\n  // initialze SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * scale}`);\n  svgRoot.setAttribute(\"height\", `${height * scale}`);\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/FG_Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `;\n\n  // render background rect\n  if (exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(sceneElements, rsvg, svgRoot, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding,\n  });\n\n  return svgRoot;\n};\n\nconst getElementsAndWatermark = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  shouldAddWatermark: boolean,\n): readonly NonDeletedExcalidrawElement[] => {\n  let _elements = [...elements];\n\n  if (shouldAddWatermark) {\n    const [, , maxX, maxY] = getCommonBounds(elements);\n    _elements = [..._elements, getWatermarkElement(maxX, maxY)];\n  }\n\n  return _elements;\n};\n\nconst getWatermarkElement = (maxX: number, maxY: number) => {\n  return newTextElement({\n    text: t(\"labels.madeWithExcalidraw\"),\n    fontSize: WATERMARK_HEIGHT,\n    fontFamily: DEFAULT_FONT_FAMILY,\n    textAlign: \"right\",\n    verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    x: maxX,\n    y: maxY + WATERMARK_HEIGHT,\n    strokeColor: oc.gray[5],\n    backgroundColor: \"transparent\",\n    fillStyle: \"hachure\",\n    strokeWidth: 1,\n    strokeStyle: \"solid\",\n    roughness: 1,\n    opacity: 100,\n    strokeSharpness: \"sharp\",\n  });\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  shouldAddWatermark: boolean,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height =\n    distance(minY, maxY) +\n    exportPadding +\n    (shouldAddWatermark ? 0 : exportPadding);\n\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  shouldAddWatermark: boolean,\n  scale: number,\n): [number, number] => {\n  const sceneElements = getElementsAndWatermark(elements, shouldAddWatermark);\n\n  const [, , width, height] = getCanvasSize(\n    sceneElements,\n    exportPadding,\n    shouldAddWatermark,\n  ).map((dimension) => Math.trunc(dimension * scale));\n\n  return [width, height];\n};\n","import colors from \"./colors\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, ENV } from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { NonDeletedExcalidrawElement } from \"./element/types\";\nimport { randomId } from \"./random\";\n\nexport type ChartElements = readonly NonDeletedExcalidrawElement[];\n\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\n\nexport interface Spreadsheet {\n  title: string | null;\n  labels: string[] | null;\n  values: number[];\n}\n\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\ntype ParseSpreadsheetResult =\n  | { type: typeof NOT_SPREADSHEET; reason: string }\n  | { type: typeof VALID_SPREADSHEET; spreadsheet: Spreadsheet };\n\nconst tryParseNumber = (s: string): number | null => {\n  const match = /^[$]?([0-9,]+(\\.[0-9]+)?)$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(match[1].replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines: string[][], columnIndex: number) =>\n  lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);\n\nconst tryParseCells = (cells: string[][]): ParseSpreadsheetResult => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return { type: NOT_SPREADSHEET, reason: \"More than 2 columns\" };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map((line) =>\n      tryParseNumber(line[0]),\n    );\n\n    if (values.length < 2) {\n      return { type: NOT_SPREADSHEET, reason: \"Less than two rows\" };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values as number[],\n      },\n    };\n  }\n\n  const valueColumnIndex = isNumericColumn(cells, 0) ? 0 : 1;\n\n  if (!isNumericColumn(cells, valueColumnIndex)) {\n    return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n  }\n\n  const labelColumnIndex = (valueColumnIndex + 1) % 2;\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return { type: NOT_SPREADSHEET, reason: \"Less than 2 rows\" };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map((row) => row[labelColumnIndex]),\n      values: rows.map((row) => tryParseNumber(row[valueColumnIndex])!),\n    },\n  };\n};\n\nconst transposeCells = (cells: string[][]) => {\n  const nextCells: string[][] = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow: string[] = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = (text: string): ParseSpreadsheetResult => {\n  // Copy/paste from excel, spreadhseets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text\n    .trim()\n    .split(\"\\n\")\n    .map((line) => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return { type: NOT_SPREADSHEET, reason: \"No values\" };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\",\n    };\n  }\n\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\n\nconst bgColors = colors.elementBackground.slice(\n  2,\n  colors.elementBackground.length,\n);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: colors.elementStroke[0],\n  strokeSharpness: \"sharp\",\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: \"middle\",\n} as const;\n\nconst getChartDimentions = (spreadsheet: Spreadsheet) => {\n  const chartWidth =\n    (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return { chartWidth, chartHeight };\n};\n\nconst chartXLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  return (\n    spreadsheet.labels?.map((label, index) => {\n      return newTextElement({\n        groupIds: [groupId],\n        backgroundColor,\n        ...commonProps,\n        text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n        x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n        y: y + BAR_GAP / 2,\n        width: BAR_WIDTH,\n        angle: 5.87,\n        fontSize: 16,\n        textAlign: \"center\",\n        verticalAlign: \"top\",\n      });\n    }) || []\n  );\n};\n\nconst chartYLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\",\n  });\n\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\",\n  });\n\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [\n      [0, 0],\n      [0, -chartHeight],\n    ],\n  });\n\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n  debug?: boolean,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n\n  const title = spreadsheet.title\n    ? newTextElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        text: spreadsheet.title,\n        x: x + chartWidth / 2,\n        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n        strokeSharpness: \"sharp\",\n        strokeStyle: \"solid\",\n        textAlign: \"center\",\n      })\n    : null;\n\n  const debugRect = debug\n    ? newElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        type: \"rectangle\",\n        x,\n        y: y - chartHeight,\n        width: chartWidth,\n        height: chartHeight,\n        strokeColor: colors.elementStroke[0],\n        fillStyle: \"solid\",\n        opacity: 6,\n      })\n    : null;\n\n  return [\n    ...(debugRect ? [debugRect] : []),\n    ...(title ? [title] : []),\n    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartLines(spreadsheet, x, y, groupId, backgroundColor),\n  ];\n};\n\nconst chartTypeBar = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = (value / max) * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight,\n    });\n  });\n\n  return [\n    ...bars,\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n  ];\n};\n\nconst chartTypeLine = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map((element) => element[0]));\n  const maxY = Math.max(...points.map((element) => element[1]));\n  const minX = Math.min(...points.map((element) => element[0]));\n  const minY = Math.min(...points.map((element) => element[1]));\n\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points as any,\n  });\n\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP,\n    });\n  });\n\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = (value / max) * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [\n        [0, 0],\n        [0, cy],\n      ],\n    });\n  });\n\n  return [\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n    line,\n    ...lines,\n    ...dots,\n  ];\n};\n\nexport const renderSpreadsheet = (\n  chartType: string,\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};\n","type CANVAS_ERROR_NAMES = \"CANVAS_ERROR\" | \"CANVAS_POSSIBLY_TOO_BIG\";\nexport class CanvasError extends Error {\n  constructor(\n    message: string = \"Couldn't export canvas.\",\n    name: CANVAS_ERROR_NAMES = \"CANVAS_ERROR\",\n  ) {\n    super();\n    this.name = name;\n    this.message = message;\n  }\n}\n","import {\n  ExcalidrawElement,\n  FontFamily,\n  ExcalidrawSelectionElement,\n} from \"../element/types\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { DataState, ImportedDataState } from \"./types\";\nimport { isInvisiblySmallElement, getNormalizedDimensions } from \"../element\";\nimport { isLinearElementType } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport {\n  FONT_FAMILY,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamily => {\n  for (const [id, fontFamilyString] of Object.entries(FONT_FAMILY)) {\n    if (fontFamilyString.includes(fontFamilyName)) {\n      return parseInt(id) as FontFamily;\n    }\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = <T extends ExcalidrawElement>(\n  element: Required<T>,\n  extra: Omit<Required<T>, keyof ExcalidrawElement>,\n): T => {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: element.isDeleted ?? false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: element.x || 0,\n    y: element.y || 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds ?? [],\n    strokeSharpness:\n      element.strokeSharpness ??\n      (isLinearElementType(element.type) ? \"round\" : \"sharp\"),\n    boundElementIds: element.boundElementIds ?? [],\n  };\n\n  return ({\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as unknown) as T;\n};\n\nconst restoreElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [\n          string,\n          string,\n        ] = (element as any).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"draw\":\n    case \"line\":\n    case \"arrow\": {\n      const {\n        startArrowhead = null,\n        endArrowhead = element.type === \"arrow\" ? \"arrow\" : null,\n      } = element;\n\n      return restoreElementWithProperties(element, {\n        startBinding: element.startBinding,\n        endBinding: element.endBinding,\n        points:\n          // migrate old arrow model to new one\n          !Array.isArray(element.points) || element.points.length < 2\n            ? [\n                [0, 0],\n                [element.width, element.height],\n              ]\n            : element.points,\n        lastCommittedPoint: null,\n        startArrowhead,\n        endArrowhead,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\nexport const restoreElements = (\n  elements: ImportedDataState[\"elements\"],\n): ExcalidrawElement[] => {\n  return (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      const migratedElement = restoreElement(element);\n      if (migratedElement) {\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n};\n\nconst restoreAppState = (\n  appState: ImportedDataState[\"appState\"],\n  localAppState: Partial<AppState> | null,\n): AppState => {\n  appState = appState || {};\n\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {} as typeof defaultAppState;\n\n  for (const [key, val] of Object.entries(defaultAppState) as [\n    keyof typeof defaultAppState,\n    any,\n  ][]) {\n    const restoredValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    (nextAppState as any)[key] =\n      restoredValue !== undefined\n        ? restoredValue\n        : localValue !== undefined\n        ? localValue\n        : val;\n  }\n\n  return {\n    ...nextAppState,\n    offsetLeft: appState.offsetLeft || 0,\n    offsetTop: appState.offsetTop || 0,\n    // Migrates from previous version where appState.zoom was a number\n    zoom:\n      typeof appState.zoom === \"number\"\n        ? {\n            value: appState.zoom as NormalizedZoomValue,\n            translation: defaultAppState.zoom.translation,\n          }\n        : appState.zoom || defaultAppState.zoom,\n  };\n};\n\nexport const restore = (\n  data: ImportedDataState | null,\n  /**\n   * Local AppState (`this.state` or initial state from localStorage) so that we\n   * don't overwrite local state with default values (when values not\n   * explicitly specified).\n   * Supply `null` if you can't get access to it.\n   */\n  localAppState: Partial<AppState> | null | undefined,\n): DataState => {\n  return {\n    elements: restoreElements(data?.elements),\n    appState: restoreAppState(data?.appState, localAppState || null),\n  };\n};\n","import { cleanAppStateForExport } from \"../appState\";\nimport { MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { restore } from \"./restore\";\nimport { ImportedDataState, LibraryData } from \"./types\";\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n\n  if (blob.type === \"image/png\") {\n    try {\n      return await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).decodePngMetadata(blob);\n    } catch (error) {\n      if (error.message === \"INVALID\") {\n        throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n      } else {\n        throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result as string);\n          }\n        };\n      });\n    }\n    if (blob.type === \"image/svg+xml\") {\n      try {\n        return await (\n          await import(/* webpackChunkName: \"image\" */ \"./image\")\n        ).decodeSvgMetadata({\n          svg: contents,\n        });\n      } catch (error) {\n        if (error.message === \"INVALID\") {\n          throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n        } else {\n          throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n        }\n      }\n    }\n  }\n  return contents;\n};\n\nexport const getMimeType = (blob: Blob | string): string => {\n  let name: string;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return \"application/json\";\n  } else if (/\\.png$/.test(name)) {\n    return \"image/png\";\n  } else if (/\\.jpe?g$/.test(name)) {\n    return \"image/jpeg\";\n  } else if (/\\.svg$/.test(name)) {\n    return \"image/svg+xml\";\n  }\n  return \"\";\n};\n\nexport const loadFromBlob = async (\n  blob: Blob,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data: ImportedDataState = JSON.parse(contents);\n    if (data.type !== \"excalidraw\") {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore(\n      {\n        elements: clearElementsForExport(data.elements || []),\n        appState: {\n          appearance: localAppState?.appearance,\n          fileHandle:\n            blob.handle &&\n            [\"application/json\", MIME_TYPES.excalidraw].includes(\n              getMimeType(blob),\n            )\n              ? blob.handle\n              : null,\n          ...cleanAppStateForExport(data.appState || {}),\n          ...(localAppState\n            ? calculateScrollCenter(data.elements || [], localAppState, null)\n            : {}),\n        },\n      },\n      localAppState,\n    );\n\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: LibraryData = JSON.parse(contents);\n  if (data.type !== \"excalidrawlib\") {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n\nexport const canvasToBlob = async (\n  canvas: HTMLCanvasElement,\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          return reject(\n            new CanvasError(\n              t(\"canvasError.canvasTooBig\"),\n              \"CANVAS_POSSIBLY_TOO_BIG\",\n            ),\n          );\n        }\n        resolve(blob);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, Spreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { canvasToBlob } from \"./data/blob\";\n\nconst TYPE_ELEMENTS = \"excalidraw/elements\";\n\ntype ElementsClipboard = {\n  type: typeof TYPE_ELEMENTS;\n  created: number;\n  elements: ExcalidrawElement[];\n};\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst isElementsClipboard = (contents: any): contents is ElementsClipboard => {\n  if (contents?.type === TYPE_ELEMENTS) {\n    return true;\n  }\n  return false;\n};\n\nexport const copyToClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  const contents: ElementsClipboard = {\n    type: TYPE_ELEMENTS,\n    created: Date.now(),\n    elements: getSelectedElements(elements, appState),\n  };\n  const json = JSON.stringify(contents);\n  CLIPBOARD = json;\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\n\nconst getAppClipboard = (): Partial<ElementsClipboard> => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error) {\n    console.error(error);\n    return {};\n  }\n};\n\nconst parsePotentialSpreadsheet = (\n  text: string,\n): { spreadsheet: Spreadsheet } | { errorMessage: string } | null => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return { spreadsheet: result.spreadsheet };\n  }\n  return null;\n};\n\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\nconst getSystemClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<string> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    return text || \"\";\n  } catch {\n    return \"\";\n  }\n};\n\n/**\n * Attemps to parse clipboard. Prefers system clipboard.\n */\nexport const parseClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<{\n  spreadsheet?: Spreadsheet;\n  elements?: readonly ExcalidrawElement[];\n  text?: string;\n  errorMessage?: string;\n}> => {\n  const systemClipboard = await getSystemClipboard(event);\n\n  // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n  if (!systemClipboard || systemClipboard.includes(SVG_EXPORT_TAG)) {\n    return getAppClipboard();\n  }\n\n  // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n  const spreadsheetResult = parsePotentialSpreadsheet(systemClipboard);\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n\n  const appClipboardData = getAppClipboard();\n\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard);\n    // system clipboard elements are newer than in-app clipboard\n    if (\n      isElementsClipboard(systemClipboardData) &&\n      (!appClipboardData?.created ||\n        appClipboardData.created < systemClipboardData.created)\n    ) {\n      return { elements: systemClipboardData.elements };\n    }\n    // in-app clipboard is newer than system clipboard\n    return appClipboardData;\n  } catch {\n    // system clipboard doesn't contain excalidraw elements  return plaintext\n    // unless we set a flag to prefer in-app clipboard because browser didn't\n    // support storing to system clipboard on copy\n    return PREFER_APP_CLIPBOARD && appClipboardData.elements\n      ? appClipboardData\n      : { text: systemClipboard };\n  }\n};\n\nexport const copyCanvasToClipboardAsPng = async (canvas: HTMLCanvasElement) => {\n  const blob = await canvasToBlob(canvas);\n  await navigator.clipboard.write([\n    new window.ClipboardItem({ \"image/png\": blob }),\n  ]);\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n","import { loadLibraryFromBlob } from \"./blob\";\nimport { LibraryItems, LibraryItem } from \"../types\";\nimport { restoreElements } from \"./restore\";\nimport { STORAGE_KEYS } from \"../constants\";\nimport { getNonDeletedElements } from \"../element\";\nimport { NonDeleted, ExcalidrawElement } from \"../element/types\";\n\nexport class Library {\n  private static libraryCache: LibraryItems | null = null;\n\n  static resetLibrary = () => {\n    Library.libraryCache = null;\n    localStorage.removeItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n  };\n\n  /** imports library (currently merges, removing duplicates) */\n  static async importLibrary(blob: Blob) {\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      return;\n    }\n\n    /**\n     * checks if library item does not exist already in current library\n     */\n    const isUniqueitem = (\n      existingLibraryItems: LibraryItems,\n      targetLibraryItem: LibraryItem,\n    ) => {\n      return !existingLibraryItems.find((libraryItem) => {\n        if (libraryItem.length !== targetLibraryItem.length) {\n          return false;\n        }\n\n        // detect z-index difference by checking the excalidraw elements\n        // are in order\n        return libraryItem.every((libItemExcalidrawItem, idx) => {\n          return (\n            libItemExcalidrawItem.id === targetLibraryItem[idx].id &&\n            libItemExcalidrawItem.versionNonce ===\n              targetLibraryItem[idx].versionNonce\n          );\n        });\n      });\n    };\n\n    const existingLibraryItems = await Library.loadLibrary();\n\n    const filtered = libraryFile.library!.reduce((acc, libraryItem) => {\n      const restored = getNonDeletedElements(restoreElements(libraryItem));\n      if (isUniqueitem(existingLibraryItems, restored)) {\n        acc.push(restored);\n      }\n      return acc;\n    }, [] as (readonly NonDeleted<ExcalidrawElement>[])[]);\n\n    Library.saveLibrary([...existingLibraryItems, ...filtered]);\n  }\n\n  static loadLibrary = (): Promise<LibraryItems> => {\n    return new Promise(async (resolve) => {\n      if (Library.libraryCache) {\n        return resolve(JSON.parse(JSON.stringify(Library.libraryCache)));\n      }\n\n      try {\n        const data = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n        if (!data) {\n          return resolve([]);\n        }\n\n        const items = (JSON.parse(data) as LibraryItems).map((elements) =>\n          restoreElements(elements),\n        ) as Mutable<LibraryItems>;\n\n        // clone to ensure we don't mutate the cached library elements in the app\n        Library.libraryCache = JSON.parse(JSON.stringify(items));\n\n        resolve(items);\n      } catch (error) {\n        console.error(error);\n        resolve([]);\n      }\n    });\n  };\n\n  static saveLibrary = (items: LibraryItems) => {\n    const prevLibraryItems = Library.libraryCache;\n    try {\n      const serializedItems = JSON.stringify(items);\n      // cache optimistically so that consumers have access to the latest\n      // immediately\n      Library.libraryCache = JSON.parse(serializedItems);\n      localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY, serializedItems);\n    } catch (error) {\n      Library.libraryCache = prevLibraryItems;\n      console.error(error);\n    }\n  };\n}\n","import { fileOpen, fileSave } from \"browser-fs-access\";\nimport { cleanAppStateForExport } from \"../appState\";\nimport { MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { loadFromBlob } from \"./blob\";\nimport { Library } from \"./library\";\n\nexport const serializeAsJSON = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): string =>\n  JSON.stringify(\n    {\n      type: \"excalidraw\",\n      version: 2,\n      source: window.location.origin,\n      elements: clearElementsForExport(elements),\n      appState: cleanAppStateForExport(appState),\n    },\n    null,\n    2,\n  );\n\nexport const saveAsJSON = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const serialized = serializeAsJSON(elements, appState);\n  const blob = new Blob([serialized], {\n    type: \"application/json\",\n  });\n\n  const fileHandle = await fileSave(\n    blob,\n    {\n      fileName: appState.name,\n      description: \"Excalidraw file\",\n      extensions: [\".excalidraw\"],\n    },\n    appState.fileHandle,\n  );\n  return { fileHandle };\n};\n\nexport const loadFromJSON = async (localAppState: AppState) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n    extensions: [\".json\", \".excalidraw\", \".png\", \".svg\"],\n    mimeTypes: [\"application/json\", \"image/png\", \"image/svg+xml\"],\n  });\n  return loadFromBlob(blob, localAppState);\n};\n\nexport const isValidLibrary = (json: any) => {\n  return (\n    typeof json === \"object\" &&\n    json &&\n    json.type === \"excalidrawlib\" &&\n    json.version === 1\n  );\n};\n\nexport const saveLibraryAsJSON = async () => {\n  const library = await Library.loadLibrary();\n  const serialized = JSON.stringify(\n    {\n      type: \"excalidrawlib\",\n      version: 1,\n      library,\n    },\n    null,\n    2,\n  );\n  const fileName = \"library.excalidrawlib\";\n  const blob = new Blob([serialized], {\n    type: MIME_TYPES.excalidrawlib,\n  });\n  await fileSave(blob, {\n    fileName,\n    description: \"Excalidraw library file\",\n    extensions: [\".excalidrawlib\"],\n  });\n};\n\nexport const importLibraryFromJSON = async () => {\n  const blob = await fileOpen({\n    description: \"Excalidraw library files\",\n    extensions: [\".json\", \".excalidrawlib\"],\n    mimeTypes: [\"application/json\"],\n  });\n  Library.importLibrary(blob);\n};\n","import { fileSave } from \"browser-fs-access\";\nimport {\n  copyCanvasToClipboardAsPng,\n  copyTextToSystemClipboard,\n} from \"../clipboard\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { ExportType } from \"../scene/types\";\nimport { AppState } from \"../types\";\nimport { canvasToBlob } from \"./blob\";\nimport { serializeAsJSON } from \"./json\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { loadFromJSON, saveAsJSON } from \"./json\";\n\nexport const exportCanvas = async (\n  type: ExportType,\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    name,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    name: string;\n    scale?: number;\n    shouldAddWatermark: boolean;\n  },\n) => {\n  if (elements.length === 0) {\n    throw new Error(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = exportToSvg(elements, {\n      exportBackground,\n      viewBackgroundColor,\n      exportPadding,\n      scale,\n      shouldAddWatermark,\n      metadata:\n        appState.exportEmbedScene && type === \"svg\"\n          ? await (\n              await import(/* webpackChunkName: \"image\" */ \"./image\")\n            ).encodeSvgMetadata({\n              text: serializeAsJSON(elements, appState),\n            })\n          : undefined,\n    });\n    if (type === \"svg\") {\n      await fileSave(new Blob([tempSvg.outerHTML], { type: \"image/svg+xml\" }), {\n        fileName: `${name}.svg`,\n        extensions: [\".svg\"],\n      });\n      return;\n    } else if (type === \"clipboard-svg\") {\n      copyTextToSystemClipboard(tempSvg.outerHTML);\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n    scale,\n    shouldAddWatermark,\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n\n  if (type === \"png\") {\n    const fileName = `${name}.png`;\n    let blob = await canvasToBlob(tempCanvas);\n    if (appState.exportEmbedScene) {\n      blob = await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).encodePngMetadata({\n        blob,\n        metadata: serializeAsJSON(elements, appState),\n      });\n    }\n\n    await fileSave(blob, {\n      fileName,\n      extensions: [\".png\"],\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      await copyCanvasToClipboardAsPng(tempCanvas);\n    } catch (error) {\n      if (error.name === \"CANVAS_POSSIBLY_TOO_BIG\") {\n        throw error;\n      }\n      throw new Error(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  }\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) {\n    tempCanvas.remove();\n  }\n};\n","import React from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { load, questionCircle, save, saveAs } from \"../components/icons\";\nimport { ProjectName } from \"../components/ProjectName\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport \"../components/ToolIcon.scss\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { loadFromJSON, saveAsJSON } from \"../data\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\n\nexport const actionChangeProjectName = register({\n  name: \"changeProjectName\",\n  perform: (_elements, appState, value) => {\n    trackEvent(\"change\", \"title\");\n    return { appState: { ...appState, name: value }, commitToHistory: false };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <ProjectName\n      label={t(\"labels.fileTitle\")}\n      value={appState.name || \"Unnamed\"}\n      onChange={(name: string) => updateData(name)}\n    />\n  ),\n});\n\nexport const actionChangeExportBackground = register({\n  name: \"changeExportBackground\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportBackground: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <label>\n      <input\n        type=\"checkbox\"\n        checked={appState.exportBackground}\n        onChange={(event) => updateData(event.target.checked)}\n      />{\" \"}\n      {t(\"labels.withBackground\")}\n    </label>\n  ),\n});\n\nexport const actionChangeExportEmbedScene = register({\n  name: \"changeExportEmbedScene\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportEmbedScene: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <label style={{ display: \"flex\" }}>\n      <input\n        type=\"checkbox\"\n        checked={appState.exportEmbedScene}\n        onChange={(event) => updateData(event.target.checked)}\n      />{\" \"}\n      {t(\"labels.exportEmbedScene\")}\n      <Tooltip\n        label={t(\"labels.exportEmbedScene_details\")}\n        position=\"above\"\n        long={true}\n      >\n        <div className=\"TooltipIcon\">{questionCircle}</div>\n      </Tooltip>\n    </label>\n  ),\n});\n\nexport const actionChangeShouldAddWatermark = register({\n  name: \"changeShouldAddWatermark\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, shouldAddWatermark: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <label>\n      <input\n        type=\"checkbox\"\n        checked={appState.shouldAddWatermark}\n        onChange={(event) => updateData(event.target.checked)}\n      />{\" \"}\n      {t(\"labels.addWatermark\")}\n    </label>\n  ),\n});\n\nexport const actionSaveScene = register({\n  name: \"saveScene\",\n  perform: async (elements, appState, value) => {\n    const fileHandleExists = !!appState.fileHandle;\n    try {\n      const { fileHandle } = await saveAsJSON(elements, appState);\n      return {\n        commitToHistory: false,\n        appState: {\n          ...appState,\n          fileHandle,\n          toastMessage: fileHandleExists\n            ? fileHandle.name\n              ? t(\"toast.fileSavedToFilename\").replace(\n                  \"{filename}\",\n                  `\"${fileHandle.name}\"`,\n                )\n              : t(\"toast.fileSaved\")\n            : null,\n        },\n      };\n    } catch (error) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      }\n      return { commitToHistory: false };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey,\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={save}\n      title={t(\"buttons.save\")}\n      aria-label={t(\"buttons.save\")}\n      showAriaLabel={useIsMobile()}\n      onClick={() => updateData(null)}\n    />\n  ),\n});\n\nexport const actionSaveAsScene = register({\n  name: \"saveAsScene\",\n  perform: async (elements, appState, value) => {\n    try {\n      const { fileHandle } = await saveAsJSON(elements, {\n        ...appState,\n        fileHandle: null,\n      });\n      return { commitToHistory: false, appState: { ...appState, fileHandle } };\n    } catch (error) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      }\n      return { commitToHistory: false };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={saveAs}\n      title={t(\"buttons.saveAs\")}\n      aria-label={t(\"buttons.saveAs\")}\n      showAriaLabel={useIsMobile()}\n      hidden={\n        !(\"chooseFileSystemEntries\" in window || \"showOpenFilePicker\" in window)\n      }\n      onClick={() => updateData(null)}\n    />\n  ),\n});\n\nexport const actionLoadScene = register({\n  name: \"loadScene\",\n  perform: async (elements, appState) => {\n    try {\n      const {\n        elements: loadedElements,\n        appState: loadedAppState,\n      } = await loadFromJSON(appState);\n      return {\n        elements: loadedElements,\n        appState: loadedAppState,\n        commitToHistory: true,\n      };\n    } catch (error) {\n      if (error?.name === \"AbortError\") {\n        return false;\n      }\n      return {\n        elements,\n        appState: { ...appState, errorMessage: error.message },\n        commitToHistory: false,\n      };\n    }\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O,\n  PanelComponent: ({ updateData, appState }) => (\n    <ToolButton\n      type=\"button\"\n      icon={load}\n      title={t(\"buttons.load\")}\n      aria-label={t(\"buttons.load\")}\n      showAriaLabel={useIsMobile()}\n      onClick={updateData}\n    />\n  ),\n});\n","import {\n  isTextElement,\n  isExcalidrawElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n} from \"../constants\";\n\n// `copiedStyles` is exported only for tests.\nexport let copiedStyles: string = \"{}\";\n\nexport const actionCopyStyles = register({\n  name: \"copyStyles\",\n  perform: (elements, appState) => {\n    const element = elements.find((el) => appState.selectedElementIds[el.id]);\n    if (element) {\n      copiedStyles = JSON.stringify(element);\n    }\n    return {\n      appState: {\n        ...appState,\n        toastMessage: t(\"toast.copyStyles\"),\n      },\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copyStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C,\n});\n\nexport const actionPasteStyles = register({\n  name: \"pasteStyles\",\n  perform: (elements, appState) => {\n    const pastedElement = JSON.parse(copiedStyles);\n    if (!isExcalidrawElement(pastedElement)) {\n      return { elements, commitToHistory: false };\n    }\n    return {\n      elements: elements.map((element) => {\n        if (appState.selectedElementIds[element.id]) {\n          const newElement = newElementWith(element, {\n            backgroundColor: pastedElement?.backgroundColor,\n            strokeWidth: pastedElement?.strokeWidth,\n            strokeColor: pastedElement?.strokeColor,\n            strokeStyle: pastedElement?.strokeStyle,\n            fillStyle: pastedElement?.fillStyle,\n            opacity: pastedElement?.opacity,\n            roughness: pastedElement?.roughness,\n          });\n          if (isTextElement(newElement)) {\n            mutateElement(newElement, {\n              fontSize: pastedElement?.fontSize || DEFAULT_FONT_SIZE,\n              fontFamily: pastedElement?.fontFamily || DEFAULT_FONT_FAMILY,\n              textAlign: pastedElement?.textAlign || DEFAULT_TEXT_ALIGN,\n            });\n            redrawTextBoundingBox(newElement);\n          }\n          return newElement;\n        }\n        return element;\n      }),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.pasteStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,\n});\n","import React from \"react\";\nimport { questionCircle } from \"../components/icons\";\n\ntype HelpIconProps = {\n  title?: string;\n  name?: string;\n  id?: string;\n  onClick?(): void;\n};\n\nexport const HelpIcon = (props: HelpIconProps) => (\n  <label title={`${props.title}  ?`} className=\"help-icon\">\n    <div onClick={props.onClick}>{questionCircle}</div>\n  </label>\n);\n","import React from \"react\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport { UngroupIcon, GroupIcon } from \"../components/icons\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport {\n  getSelectedGroupIds,\n  selectGroup,\n  selectGroupsForSelectedElements,\n  getElementsInGroup,\n  addToGroup,\n  removeFromSelectedGroups,\n  isElementInGroup,\n} from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\nimport { randomId } from \"../random\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\n\nconst allElementsInSameGroup = (elements: readonly ExcalidrawElement[]) => {\n  if (elements.length >= 2) {\n    const groupIds = elements[0].groupIds;\n    for (const groupId of groupIds) {\n      if (\n        elements.reduce(\n          (acc, element) => acc && isElementInGroup(element, groupId),\n          true,\n        )\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return (\n    selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements)\n  );\n};\n\nexport const actionGroup = register({\n  name: \"group\",\n  perform: (elements, appState) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    if (selectedElements.length < 2) {\n      // nothing to group\n      return { appState, elements, commitToHistory: false };\n    }\n    // if everything is already grouped into 1 group, there is nothing to do\n    const selectedGroupIds = getSelectedGroupIds(appState);\n    if (selectedGroupIds.length === 1) {\n      const selectedGroupId = selectedGroupIds[0];\n      const elementIdsInGroup = new Set(\n        getElementsInGroup(elements, selectedGroupId).map(\n          (element) => element.id,\n        ),\n      );\n      const selectedElementIds = new Set(\n        selectedElements.map((element) => element.id),\n      );\n      const combinedSet = new Set([\n        ...Array.from(elementIdsInGroup),\n        ...Array.from(selectedElementIds),\n      ]);\n      if (combinedSet.size === elementIdsInGroup.size) {\n        // no incremental ids in the selected ids\n        return { appState, elements, commitToHistory: false };\n      }\n    }\n    const newGroupId = randomId();\n    const updatedElements = elements.map((element) => {\n      if (!appState.selectedElementIds[element.id]) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: addToGroup(\n          element.groupIds,\n          newGroupId,\n          appState.editingGroupId,\n        ),\n      });\n    });\n    // keep the z order within the group the same, but move them\n    // to the z order of the highest element in the layer stack\n    const elementsInGroup = getElementsInGroup(updatedElements, newGroupId);\n    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];\n    const lastGroupElementIndex = updatedElements.lastIndexOf(\n      lastElementInGroup,\n    );\n    const elementsAfterGroup = updatedElements.slice(lastGroupElementIndex + 1);\n    const elementsBeforeGroup = updatedElements\n      .slice(0, lastGroupElementIndex)\n      .filter(\n        (updatedElement) => !isElementInGroup(updatedElement, newGroupId),\n      );\n    const updatedElementsInOrder = [\n      ...elementsBeforeGroup,\n      ...elementsInGroup,\n      ...elementsAfterGroup,\n    ];\n\n    return {\n      appState: selectGroup(\n        newGroupId,\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(updatedElementsInOrder),\n      ),\n      elements: updatedElementsInOrder,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.group\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionGroup(elements, appState),\n  keyTest: (event) =>\n    !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<GroupIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.group\")}  ${getShortcutKey(\"CtrlOrCmd+G\")}`}\n      aria-label={t(\"labels.group\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n\nexport const actionUngroup = register({\n  name: \"ungroup\",\n  perform: (elements, appState) => {\n    const groupIds = getSelectedGroupIds(appState);\n    if (groupIds.length === 0) {\n      return { appState, elements, commitToHistory: false };\n    }\n    const nextElements = elements.map((element) => {\n      const nextGroupIds = removeFromSelectedGroups(\n        element.groupIds,\n        appState.selectedGroupIds,\n      );\n      if (nextGroupIds.length === element.groupIds.length) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: nextGroupIds,\n      });\n    });\n    return {\n      appState: selectGroupsForSelectedElements(\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(nextElements),\n      ),\n      elements: nextElements,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  contextItemLabel: \"labels.ungroup\",\n  contextItemPredicate: (elements, appState) =>\n    getSelectedGroupIds(appState).length > 0,\n\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      hidden={getSelectedGroupIds(appState).length === 0}\n      icon={<UngroupIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.ungroup\")}  ${getShortcutKey(\"CtrlOrCmd+Shift+G\")}`}\n      aria-label={t(\"labels.ungroup\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n","import React from \"react\";\nimport { menu, palette } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { showSelectedShapeActions, getNonDeletedElements } from \"../element\";\nimport { register } from \"./register\";\nimport { allowFullScreen, exitFullScreen, isFullScreen } from \"../utils\";\nimport { CODES, KEYS } from \"../keys\";\nimport { HelpIcon } from \"../components/HelpIcon\";\n\nexport const actionToggleCanvasMenu = register({\n  name: \"toggleCanvasMenu\",\n  perform: (_, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"canvas\" ? null : \"canvas\",\n    },\n    commitToHistory: false,\n  }),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={menu}\n      aria-label={t(\"buttons.menu\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"canvas\"}\n    />\n  ),\n});\n\nexport const actionToggleEditMenu = register({\n  name: \"toggleEditMenu\",\n  perform: (_elements, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"shape\" ? null : \"shape\",\n    },\n    commitToHistory: false,\n  }),\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      visible={showSelectedShapeActions(\n        appState,\n        getNonDeletedElements(elements),\n      )}\n      type=\"button\"\n      icon={palette}\n      aria-label={t(\"buttons.edit\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"shape\"}\n    />\n  ),\n});\n\nexport const actionFullScreen = register({\n  name: \"toggleFullScreen\",\n  perform: () => {\n    if (!isFullScreen()) {\n      allowFullScreen();\n    }\n    if (isFullScreen()) {\n      exitFullScreen();\n    }\n    return {\n      commitToHistory: false,\n    };\n  },\n  keyTest: (event) => event.code === CODES.F && !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionShortcuts = register({\n  name: \"toggleShortcuts\",\n  perform: (_elements, appState) => {\n    return {\n      appState: {\n        ...appState,\n        showHelpDialog: !appState.showHelpDialog,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <HelpIcon title={t(\"helpDialog.title\")} onClick={updateData} />\n  ),\n  keyTest: (event) => event.key === KEYS.QUESTION_MARK,\n});\n","import \"./Avatar.scss\";\n\nimport React from \"react\";\n\ntype AvatarProps = {\n  children: string;\n  onClick: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\n  color: string;\n  border: string;\n};\n\nexport const Avatar = ({ children, color, border, onClick }: AvatarProps) => (\n  <div\n    className=\"Avatar\"\n    style={{ background: color, border: `1px solid ${border}` }}\n    onClick={onClick}\n  >\n    {children}\n  </div>\n);\n","import { register } from \"./register\";\nimport { getSelectedElements } from \"../scene\";\nimport { getNonDeletedElements } from \"../element\";\nimport { deepCopyElement } from \"../element/newElement\";\nimport { Library } from \"../data/library\";\n\nexport const actionAddToLibrary = register({\n  name: \"addToLibrary\",\n  perform: (elements, appState) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n\n    Library.loadLibrary().then((items) => {\n      Library.saveLibrary([...items, selectedElements.map(deepCopyElement)]);\n    });\n    return false;\n  },\n  contextItemLabel: \"labels.addToLibrary\",\n});\n","import React from \"react\";\nimport { getClientColors, getClientInitials } from \"../clients\";\nimport { Avatar } from \"../components/Avatar\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { Collaborator } from \"../types\";\nimport { register } from \"./register\";\n\nexport const actionGoToCollaborator = register({\n  name: \"goToCollaborator\",\n  perform: (_elements, appState, value) => {\n    const point = value as Collaborator[\"pointer\"];\n    if (!point) {\n      return { appState, commitToHistory: false };\n    }\n\n    return {\n      appState: {\n        ...appState,\n        ...centerScrollOn({\n          scenePoint: point,\n          viewportDimensions: {\n            width: appState.width,\n            height: appState.height,\n          },\n          zoom: appState.zoom,\n        }),\n        // Close mobile menu\n        openMenu: appState.openMenu === \"canvas\" ? null : appState.openMenu,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData, id }) => {\n    const clientId = id;\n    if (!clientId) {\n      return null;\n    }\n\n    const collaborator = appState.collaborators.get(clientId);\n\n    if (!collaborator) {\n      return null;\n    }\n\n    const { background, stroke } = getClientColors(clientId, appState);\n    const shortName = getClientInitials(collaborator.username);\n\n    return (\n      <Avatar\n        color={background}\n        border={stroke}\n        onClick={() => updateData(collaborator.pointer)}\n      >\n        {shortName}\n      </Avatar>\n    );\n  },\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n}\n\nexport interface Alignment {\n  position: \"start\" | \"center\" | \"end\";\n  axis: \"x\" | \"y\";\n}\n\nexport const alignElements = (\n  selectedElements: ExcalidrawElement[],\n  alignment: Alignment,\n): ExcalidrawElement[] => {\n  const groups: ExcalidrawElement[][] = getMaximumGroups(selectedElements);\n\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n\n  return groups.flatMap((group) => {\n    const translation = calculateTranslation(\n      group,\n      selectionBoundingBox,\n      alignment,\n    );\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst calculateTranslation = (\n  group: ExcalidrawElement[],\n  selectionBoundingBox: Box,\n  { axis, position }: Alignment,\n): { x: number; y: number } => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n\n  const [min, max]: [\"minX\" | \"minY\", \"maxX\" | \"maxY\"] =\n    axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n\n  const noTranslation = { x: 0, y: 0 };\n  if (position === \"start\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min],\n    };\n  } else if (position === \"end\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max],\n    };\n  } // else if (position === \"center\") {\n  return {\n    ...noTranslation,\n    [axis]:\n      (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 -\n      (groupBoundingBox[min] + groupBoundingBox[max]) / 2,\n  };\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return { minX, minY, maxX, maxY };\n};\n","import React from \"react\";\nimport { alignElements, Alignment } from \"../align\";\nimport {\n  AlignBottomIcon,\n  AlignLeftIcon,\n  AlignRightIcon,\n  AlignTopIcon,\n  CenterHorizontallyIcon,\n  CenterVerticallyIcon,\n} from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { KEYS } from \"../keys\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => getSelectedElements(getNonDeletedElements(elements), appState).length > 1;\n\nconst alignSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  alignment: Alignment,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  const updatedElements = alignElements(selectedElements, alignment);\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nexport const actionAlignTop = register({\n  name: \"alignTop\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"start\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignTopIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignTop\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Up\",\n      )}`}\n      aria-label={t(\"labels.alignTop\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignBottom = register({\n  name: \"alignBottom\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"end\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignBottomIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignBottom\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Down\",\n      )}`}\n      aria-label={t(\"labels.alignBottom\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignLeft = register({\n  name: \"alignLeft\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"start\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignLeftIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignLeft\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Left\",\n      )}`}\n      aria-label={t(\"labels.alignLeft\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignRight = register({\n  name: \"alignRight\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"end\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignRightIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignRight\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Right\",\n      )}`}\n      aria-label={t(\"labels.alignRight\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignVerticallyCentered = register({\n  name: \"alignVerticallyCentered\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"center\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<CenterVerticallyIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerVertically\")}\n      aria-label={t(\"labels.centerVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignHorizontallyCentered = register({\n  name: \"alignHorizontallyCentered\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"center\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<CenterHorizontallyIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerHorizontally\")}\n      aria-label={t(\"labels.centerHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  distribution: Distribution,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements)\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) =>\n        newElementWith(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        }),\n      );\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n","import React from \"react\";\nimport {\n  DistributeHorizontallyIcon,\n  DistributeVerticallyIcon,\n} from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { distributeElements, Distribution } from \"../disitrubte\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { CODES } from \"../keys\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => getSelectedElements(getNonDeletedElements(elements), appState).length > 1;\n\nconst distributeSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  distribution: Distribution,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  const updatedElements = distributeElements(selectedElements, distribution);\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nexport const distributeHorizontally = register({\n  name: \"distributeHorizontally\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, {\n        space: \"between\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.altKey && event.code === CODES.H,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<DistributeHorizontallyIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeHorizontally\")}  ${getShortcutKey(\n        \"Alt+H\",\n      )}`}\n      aria-label={t(\"labels.distributeHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const distributeVertically = register({\n  name: \"distributeVertically\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, {\n        space: \"between\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.altKey && event.code === CODES.V,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<DistributeVerticallyIcon appearance={appState.appearance} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeVertically\")}  ${getShortcutKey(\"Alt+V\")}`}\n      aria-label={t(\"labels.distributeVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { copyToClipboard } from \"../clipboard\";\nimport { actionDeleteSelected } from \"./actionDeleteSelected\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { exportCanvas } from \"../data/index\";\nimport { getNonDeletedElements } from \"../element\";\nimport { t } from \"../i18n\";\n\nexport const actionCopy = register({\n  name: \"copy\",\n  perform: (elements, appState) => {\n    copyToClipboard(getNonDeletedElements(elements), appState);\n\n    return {\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copy\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.C,\n});\n\nexport const actionCut = register({\n  name: \"cut\",\n  perform: (elements, appState, data, app) => {\n    actionCopy.perform(elements, appState, data, app);\n    return actionDeleteSelected.perform(elements, appState, data, app);\n  },\n  contextItemLabel: \"labels.cut\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.X,\n});\n\nexport const actionCopyAsSvg = register({\n  name: \"copyAsSvg\",\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        app.canvas,\n        appState,\n      );\n      return {\n        commitToHistory: false,\n      };\n    } catch (error) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  contextItemLabel: \"labels.copyAsSvg\",\n});\n\nexport const actionCopyAsPng = register({\n  name: \"copyAsPng\",\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        app.canvas,\n        appState,\n      );\n      return {\n        appState: {\n          ...appState,\n          toastMessage: t(\"toast.copyToClipboardAsPng\"),\n        },\n        commitToHistory: false,\n      };\n    } catch (error) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  contextItemLabel: \"labels.copyAsPng\",\n  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { GRID_SIZE } from \"../constants\";\nimport { AppState } from \"../types\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleGridMode = register({\n  name: \"gridMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"grid\");\n    return {\n      appState: {\n        ...appState,\n        gridSize: this.checked!(appState) ? null : GRID_SIZE,\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState: AppState) => appState.gridSize !== null,\n  contextItemLabel: \"labels.showGrid\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE,\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleZenMode = register({\n  name: \"zenMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"zen\");\n\n    return {\n      appState: {\n        ...appState,\n        zenModeEnabled: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.zenModeEnabled,\n  contextItemLabel: \"buttons.zenMode\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z,\n});\n","import { register } from \"./register\";\n\nexport const actionToggleStats = register({\n  name: \"stats\",\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        showStats: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.showStats,\n  contextItemLabel: \"stats.title\",\n});\n","import { Action, ActionResult } from \"./types\";\nimport React from \"react\";\nimport { undo, redo } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { SceneHistory, HistoryEntry } from \"../history\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { isWindows, KEYS } from \"../keys\";\nimport { getElementMap } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst writeData = (\n  prevElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  updater: () => HistoryEntry | null,\n): ActionResult => {\n  const commitToHistory = false;\n  if (\n    !appState.multiElement &&\n    !appState.resizingElement &&\n    !appState.editingElement &&\n    !appState.draggingElement\n  ) {\n    const data = updater();\n    if (data === null) {\n      return { commitToHistory };\n    }\n\n    const prevElementMap = getElementMap(prevElements);\n    const nextElements = data.elements;\n    const nextElementMap = getElementMap(nextElements);\n\n    const deletedElements = prevElements.filter(\n      (prevElement) => !nextElementMap.hasOwnProperty(prevElement.id),\n    );\n    const elements = nextElements\n      .map((nextElement) =>\n        newElementWith(\n          prevElementMap[nextElement.id] || nextElement,\n          nextElement,\n        ),\n      )\n      .concat(\n        deletedElements.map((prevElement) =>\n          newElementWith(prevElement, { isDeleted: true }),\n        ),\n      );\n    fixBindingsAfterDeletion(elements, deletedElements);\n\n    return {\n      elements,\n      appState: { ...appState, ...data.appState },\n      commitToHistory,\n      syncHistory: true,\n    };\n  }\n  return { commitToHistory };\n};\n\ntype ActionCreator = (history: SceneHistory) => Action;\n\nexport const createUndoAction: ActionCreator = (history) => ({\n  name: \"undo\",\n  perform: (elements, appState) =>\n    writeData(elements, appState, () => history.undoOnce()),\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    event.key.toLowerCase() === KEYS.Z &&\n    !event.shiftKey,\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={undo}\n      aria-label={t(\"buttons.undo\")}\n      onClick={updateData}\n    />\n  ),\n  commitToHistory: () => false,\n});\n\nexport const createRedoAction: ActionCreator = (history) => ({\n  name: \"redo\",\n  perform: (elements, appState) =>\n    writeData(elements, appState, () => history.redoOnce()),\n  keyTest: (event) =>\n    (event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      event.key.toLowerCase() === KEYS.Z) ||\n    (isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y),\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={redo}\n      aria-label={t(\"buttons.redo\")}\n      onClick={updateData}\n    />\n  ),\n  commitToHistory: () => false,\n});\n","import React from \"react\";\nimport {\n  Action,\n  ActionsManagerInterface,\n  UpdaterFn,\n  ActionName,\n  ActionResult,\n} from \"./types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState, ExcalidrawProps } from \"../types\";\n\n// This is the <App> component, but for now we don't care about anything but its\n// `canvas` state.\ntype App = { canvas: HTMLCanvasElement | null; props: ExcalidrawProps };\n\nexport class ActionManager implements ActionsManagerInterface {\n  actions = {} as ActionsManagerInterface[\"actions\"];\n\n  updater: (actionResult: ActionResult | Promise<ActionResult>) => void;\n\n  getAppState: () => Readonly<AppState>;\n  getElementsIncludingDeleted: () => readonly ExcalidrawElement[];\n  app: App;\n\n  constructor(\n    updater: UpdaterFn,\n    getAppState: () => AppState,\n    getElementsIncludingDeleted: () => readonly ExcalidrawElement[],\n    app: App,\n  ) {\n    this.updater = (actionResult) => {\n      if (actionResult && \"then\" in actionResult) {\n        actionResult.then((actionResult) => {\n          return updater(actionResult);\n        });\n      } else {\n        return updater(actionResult);\n      }\n    };\n    this.getAppState = getAppState;\n    this.getElementsIncludingDeleted = getElementsIncludingDeleted;\n    this.app = app;\n  }\n\n  registerAction(action: Action) {\n    this.actions[action.name] = action;\n  }\n\n  registerAll(actions: readonly Action[]) {\n    actions.forEach((action) => this.registerAction(action));\n  }\n\n  handleKeyDown(event: KeyboardEvent) {\n    const data = Object.values(this.actions)\n      .sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0))\n      .filter(\n        (action) =>\n          action.keyTest &&\n          action.keyTest(\n            event,\n            this.getAppState(),\n            this.getElementsIncludingDeleted(),\n          ),\n      );\n\n    if (data.length === 0) {\n      return false;\n    }\n    const { viewModeEnabled } = this.getAppState();\n    if (viewModeEnabled) {\n      if (data[0].name !== \"viewMode\") {\n        return false;\n      }\n    }\n\n    event.preventDefault();\n    this.updater(\n      data[0].perform(\n        this.getElementsIncludingDeleted(),\n        this.getAppState(),\n        null,\n        this.app,\n      ),\n    );\n    return true;\n  }\n\n  executeAction(action: Action) {\n    this.updater(\n      action.perform(\n        this.getElementsIncludingDeleted(),\n        this.getAppState(),\n        null,\n        this.app,\n      ),\n    );\n  }\n\n  // Id is an attribute that we can use to pass in data like keys.\n  // This is needed for dynamically generated action components\n  // like the user list. We can use this key to extract more\n  // data from app state. This is an alternative to generic prop hell!\n  renderAction = (name: ActionName, id?: string) => {\n    if (this.actions[name] && \"PanelComponent\" in this.actions[name]) {\n      const action = this.actions[name];\n      const PanelComponent = action.PanelComponent!;\n      const updateData = (formState?: any) => {\n        this.updater(\n          action.perform(\n            this.getElementsIncludingDeleted(),\n            this.getAppState(),\n            formState,\n            this.app,\n          ),\n        );\n      };\n\n      return (\n        <PanelComponent\n          elements={this.getElementsIncludingDeleted()}\n          appState={this.getAppState()}\n          updateData={updateData}\n          id={id}\n        />\n      );\n    }\n\n    return null;\n  };\n}\n","import { PointerCoords } from \"./types\";\n\nexport const getCenter = (pointers: Map<number, PointerCoords>) => {\n  const allCoords = Array.from(pointers.values());\n  return {\n    x: sum(allCoords, (coords) => coords.x) / allCoords.length,\n    y: sum(allCoords, (coords) => coords.y) / allCoords.length,\n  };\n};\n\nexport const getDistance = ([a, b]: readonly PointerCoords[]) =>\n  Math.hypot(a.x - b.x, a.y - b.y);\n\nconst sum = <T>(array: readonly T[], mapper: (item: T) => number): number =>\n  array.reduce((acc, item) => acc + mapper(item), 0);\n","import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\n\nexport interface HistoryEntry {\n  appState: ReturnType<typeof clearAppStatePropertiesForHistory>;\n  elements: ExcalidrawElement[];\n}\n\ninterface DehydratedExcalidrawElement {\n  id: string;\n  versionNonce: number;\n}\n\ninterface DehydratedHistoryEntry {\n  appState: string;\n  elements: DehydratedExcalidrawElement[];\n}\n\nconst clearAppStatePropertiesForHistory = (appState: AppState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nexport class SceneHistory {\n  private elementCache = new Map<string, Map<number, ExcalidrawElement>>();\n  private recording: boolean = true;\n  private stateHistory: DehydratedHistoryEntry[] = [];\n  private redoStack: DehydratedHistoryEntry[] = [];\n  private lastEntry: HistoryEntry | null = null;\n\n  private hydrateHistoryEntry({\n    appState,\n    elements,\n  }: DehydratedHistoryEntry): HistoryEntry {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`,\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  private dehydrateHistoryEntry({\n    appState,\n    elements,\n  }: HistoryEntry): DehydratedHistoryEntry {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element: ExcalidrawElement) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id)!;\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n      redoStack: this.redoStack.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  private generateEntry = (\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ): DehydratedHistoryEntry =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points:\n              element.lastCommittedPoint !==\n              element.points[element.points.length - 1]\n                ? element.points.slice(0, -1)\n                : element.points,\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n\n  shouldCreateEntry(nextEntry: HistoryEntry): boolean {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key: keyof typeof nextEntry.appState;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry: HistoryEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): HistoryEntry | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): HistoryEntry | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements),\n    );\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport const createHistory: () => { history: SceneHistory } = () => {\n  const history = new SceneHistory();\n  return { history };\n};\n","import React from \"react\";\nimport { KEYS } from \"./keys\";\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nexport const SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\" className=\"\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\",\n    key: [KEYS.V, KEYS.S],\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\",\n    key: KEYS.R,\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 223.646 223.646\">\n        <path d=\"M111.823 0L16.622 111.823 111.823 223.646 207.025 111.823z\" />\n      </svg>\n    ),\n    value: \"diamond\",\n    key: KEYS.D,\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\",\n    key: KEYS.E,\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\" className=\"rtl-mirror\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\",\n    key: KEYS.A,\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 6 6\">\n        <line\n          x1=\"0\"\n          y1=\"3\"\n          x2=\"6\"\n          y2=\"3\"\n          stroke=\"currentColor\"\n          strokeLinecap=\"round\"\n        />\n      </svg>\n    ),\n    value: \"line\",\n    key: [KEYS.P, KEYS.L],\n  },\n  {\n    icon: (\n      // fa-pencil\n      <svg viewBox=\"0 0 512 512\">\n        <path\n          fill=\"currentColor\"\n          d=\"M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z\"\n        ></path>\n      </svg>\n    ),\n    value: \"draw\",\n    key: KEYS.X,\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\",\n    key: KEYS.T,\n  },\n] as const;\n\nexport const findShapeByKey = (key: string) => {\n  const shape = SHAPES.find((shape, index) => {\n    return (\n      key === (index + 1).toString() ||\n      (typeof shape.key === \"string\"\n        ? shape.key === key\n        : (shape.key as readonly string[]).includes(key))\n    );\n  });\n  return shape?.value || null;\n};\n","import { t } from \"../i18n\";\nimport { isDarwin } from \"../keys\";\nimport { getShortcutKey } from \"../utils\";\n\nexport type ShortcutName =\n  | \"cut\"\n  | \"copy\"\n  | \"paste\"\n  | \"copyStyles\"\n  | \"pasteStyles\"\n  | \"selectAll\"\n  | \"deleteSelectedElements\"\n  | \"duplicateSelection\"\n  | \"sendBackward\"\n  | \"bringForward\"\n  | \"sendToBack\"\n  | \"bringToFront\"\n  | \"copyAsPng\"\n  | \"copyAsSvg\"\n  | \"group\"\n  | \"ungroup\"\n  | \"gridMode\"\n  | \"zenMode\"\n  | \"stats\"\n  | \"addToLibrary\"\n  | \"viewMode\";\n\nconst shortcutMap: Record<ShortcutName, string[]> = {\n  cut: [getShortcutKey(\"CtrlOrCmd+X\")],\n  copy: [getShortcutKey(\"CtrlOrCmd+C\")],\n  paste: [getShortcutKey(\"CtrlOrCmd+V\")],\n  copyStyles: [getShortcutKey(\"CtrlOrCmd+Alt+C\")],\n  pasteStyles: [getShortcutKey(\"CtrlOrCmd+Alt+V\")],\n  selectAll: [getShortcutKey(\"CtrlOrCmd+A\")],\n  deleteSelectedElements: [getShortcutKey(\"Del\")],\n  duplicateSelection: [\n    getShortcutKey(\"CtrlOrCmd+D\"),\n    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n  ],\n  sendBackward: [getShortcutKey(\"CtrlOrCmd+[\")],\n  bringForward: [getShortcutKey(\"CtrlOrCmd+]\")],\n  sendToBack: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n  ],\n  bringToFront: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n  ],\n  copyAsPng: [getShortcutKey(\"Shift+Alt+C\")],\n  copyAsSvg: [],\n  group: [getShortcutKey(\"CtrlOrCmd+G\")],\n  ungroup: [getShortcutKey(\"CtrlOrCmd+Shift+G\")],\n  gridMode: [getShortcutKey(\"CtrlOrCmd+'\")],\n  zenMode: [getShortcutKey(\"Alt+Z\")],\n  stats: [],\n  addToLibrary: [],\n  viewMode: [getShortcutKey(\"Alt+R\")],\n};\n\nexport const getShortcutFromShortcutName = (name: ShortcutName) => {\n  const shortcuts = shortcutMap[name];\n  // if multiple shortcuts availiable, take the first one\n  return shortcuts && shortcuts.length > 0 ? shortcuts[0] : \"\";\n};\n","import React from \"react\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\nimport clsx from \"clsx\";\nimport { Popover } from \"./Popover\";\nimport { t } from \"../i18n\";\n\nimport \"./ContextMenu.scss\";\nimport {\n  getShortcutFromShortcutName,\n  ShortcutName,\n} from \"../actions/shortcuts\";\nimport { Action } from \"../actions/types\";\nimport { ActionManager } from \"../actions/manager\";\nimport { AppState } from \"../types\";\n\nexport type ContextMenuOption = \"separator\" | Action;\n\ntype ContextMenuProps = {\n  options: ContextMenuOption[];\n  onCloseRequest?(): void;\n  top: number;\n  left: number;\n  actionManager: ActionManager;\n  appState: Readonly<AppState>;\n};\n\nconst ContextMenu = ({\n  options,\n  onCloseRequest,\n  top,\n  left,\n  actionManager,\n  appState,\n}: ContextMenuProps) => {\n  const isDarkTheme = !!document\n    .querySelector(\".excalidraw\")\n    ?.classList.contains(\"Appearance_dark\");\n  return (\n    <div\n      className={clsx(\"excalidraw\", {\n        \"Appearance_dark Appearance_dark-background-none\": isDarkTheme,\n      })}\n    >\n      <Popover\n        onCloseRequest={onCloseRequest}\n        top={top}\n        left={left}\n        fitInViewport={true}\n      >\n        <ul\n          className=\"context-menu\"\n          onContextMenu={(event) => event.preventDefault()}\n        >\n          {options.map((option, idx) => {\n            if (option === \"separator\") {\n              return <hr key={idx} className=\"context-menu-option-separator\" />;\n            }\n\n            const actionName = option.name;\n            const label = option.contextItemLabel\n              ? t(option.contextItemLabel)\n              : \"\";\n            return (\n              <li key={idx} data-testid={actionName} onClick={onCloseRequest}>\n                <button\n                  className={clsx(\"context-menu-option\", {\n                    dangerous: actionName === \"deleteSelectedElements\",\n                    checkmark: option.checked?.(appState),\n                  })}\n                  onClick={() => actionManager.executeAction(option)}\n                >\n                  <div className=\"context-menu-option__label\">{label}</div>\n                  <kbd className=\"context-menu-option__shortcut\">\n                    {actionName\n                      ? getShortcutFromShortcutName(actionName as ShortcutName)\n                      : \"\"}\n                  </kbd>\n                </button>\n              </li>\n            );\n          })}\n        </ul>\n      </Popover>\n    </div>\n  );\n};\n\nlet contextMenuNode: HTMLDivElement;\nconst getContextMenuNode = (): HTMLDivElement => {\n  if (contextMenuNode) {\n    return contextMenuNode;\n  }\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n  return (contextMenuNode = div);\n};\n\ntype ContextMenuParams = {\n  options: (ContextMenuOption | false | null | undefined)[];\n  top: ContextMenuProps[\"top\"];\n  left: ContextMenuProps[\"left\"];\n  actionManager: ContextMenuProps[\"actionManager\"];\n  appState: Readonly<AppState>;\n};\n\nconst handleClose = () => {\n  unmountComponentAtNode(getContextMenuNode());\n};\n\nexport default {\n  push(params: ContextMenuParams) {\n    const options = Array.of<ContextMenuOption>();\n    params.options.forEach((option) => {\n      if (option) {\n        options.push(option);\n      }\n    });\n    if (options.length) {\n      render(\n        <ContextMenu\n          top={params.top}\n          left={params.left}\n          options={options}\n          onCloseRequest={handleClose}\n          actionManager={params.actionManager}\n          appState={params.appState}\n        />,\n        getContextMenuNode(),\n      );\n    }\n  },\n};\n","import \"./Stack.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype StackProps = {\n  children: React.ReactNode;\n  gap?: number;\n  align?: \"start\" | \"center\" | \"end\" | \"baseline\";\n  justifyContent?: \"center\" | \"space-around\" | \"space-between\";\n  className?: string | boolean;\n  style?: React.CSSProperties;\n};\n\nconst RowStack = ({\n  children,\n  gap,\n  align,\n  justifyContent,\n  className,\n  style,\n}: StackProps) => {\n  return (\n    <div\n      className={clsx(\"Stack Stack_horizontal\", className)}\n      style={{\n        \"--gap\": gap,\n        alignItems: align,\n        justifyContent,\n        ...style,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nconst ColStack = ({\n  children,\n  gap,\n  align,\n  justifyContent,\n  className,\n}: StackProps) => {\n  return (\n    <div\n      className={clsx(\"Stack Stack_vertical\", className)}\n      style={{\n        \"--gap\": gap,\n        justifyItems: align,\n        justifyContent,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport default {\n  Row: RowStack,\n  Col: ColStack,\n};\n","import React from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport {\n  canChangeSharpness,\n  canHaveArrowheads,\n  getTargetElements,\n  hasBackground,\n  hasStroke,\n  hasText,\n} from \"../scene\";\nimport { SHAPES } from \"../shapes\";\nimport { AppState, Zoom } from \"../types\";\nimport { capitalizeString, isTransparent, setCursorForShape } from \"../utils\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\n\nexport const SelectedShapeActions = ({\n  appState,\n  elements,\n  renderAction,\n  elementType,\n}: {\n  appState: AppState;\n  elements: readonly ExcalidrawElement[];\n  renderAction: ActionManager[\"renderAction\"];\n  elementType: ExcalidrawElement[\"type\"];\n}) => {\n  const targetElements = getTargetElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  const isEditing = Boolean(appState.editingElement);\n  const isMobile = useIsMobile();\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const showFillIcons =\n    hasBackground(elementType) ||\n    targetElements.some(\n      (element) =>\n        hasBackground(element.type) && !isTransparent(element.backgroundColor),\n    );\n  const showChangeBackgroundIcons =\n    hasBackground(elementType) ||\n    targetElements.some((element) => hasBackground(element.type));\n\n  return (\n    <div className=\"panelColumn\">\n      {renderAction(\"changeStrokeColor\")}\n      {showChangeBackgroundIcons && renderAction(\"changeBackgroundColor\")}\n      {showFillIcons && renderAction(\"changeFillStyle\")}\n\n      {(hasStroke(elementType) ||\n        targetElements.some((element) => hasStroke(element.type))) && (\n        <>\n          {renderAction(\"changeStrokeWidth\")}\n          {renderAction(\"changeStrokeStyle\")}\n          {renderAction(\"changeSloppiness\")}\n        </>\n      )}\n\n      {(canChangeSharpness(elementType) ||\n        targetElements.some((element) => canChangeSharpness(element.type))) && (\n        <>{renderAction(\"changeSharpness\")}</>\n      )}\n\n      {(hasText(elementType) ||\n        targetElements.some((element) => hasText(element.type))) && (\n        <>\n          {renderAction(\"changeFontSize\")}\n\n          {renderAction(\"changeFontFamily\")}\n\n          {renderAction(\"changeTextAlign\")}\n        </>\n      )}\n\n      {(canHaveArrowheads(elementType) ||\n        targetElements.some((element) => canHaveArrowheads(element.type))) && (\n        <>{renderAction(\"changeArrowhead\")}</>\n      )}\n\n      {renderAction(\"changeOpacity\")}\n\n      <fieldset>\n        <legend>{t(\"labels.layers\")}</legend>\n        <div className=\"buttonList\">\n          {renderAction(\"sendToBack\")}\n          {renderAction(\"sendBackward\")}\n          {renderAction(\"bringToFront\")}\n          {renderAction(\"bringForward\")}\n        </div>\n      </fieldset>\n\n      {targetElements.length > 1 && (\n        <fieldset>\n          <legend>{t(\"labels.align\")}</legend>\n          <div className=\"buttonList\">\n            {\n              // swap this order for RTL so the button positions always match their action\n              // (i.e. the leftmost button aligns left)\n            }\n            {isRTL ? (\n              <>\n                {renderAction(\"alignRight\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignLeft\")}\n              </>\n            ) : (\n              <>\n                {renderAction(\"alignLeft\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignRight\")}\n              </>\n            )}\n            {targetElements.length > 2 &&\n              renderAction(\"distributeHorizontally\")}\n            <div className=\"iconRow\">\n              {renderAction(\"alignTop\")}\n              {renderAction(\"alignVerticallyCentered\")}\n              {renderAction(\"alignBottom\")}\n              {targetElements.length > 2 &&\n                renderAction(\"distributeVertically\")}\n            </div>\n          </div>\n        </fieldset>\n      )}\n      {!isMobile && !isEditing && targetElements.length > 0 && (\n        <fieldset>\n          <legend>{t(\"labels.actions\")}</legend>\n          <div className=\"buttonList\">\n            {renderAction(\"duplicateSelection\")}\n            {renderAction(\"deleteSelectedElements\")}\n            {renderAction(\"group\")}\n            {renderAction(\"ungroup\")}\n          </div>\n        </fieldset>\n      )}\n    </div>\n  );\n};\n\nconst LIBRARY_ICON = (\n  // fa-th-large\n  <svg viewBox=\"0 0 512 512\">\n    <path d=\"M296 32h192c13.255 0 24 10.745 24 24v160c0 13.255-10.745 24-24 24H296c-13.255 0-24-10.745-24-24V56c0-13.255 10.745-24 24-24zm-80 0H24C10.745 32 0 42.745 0 56v160c0 13.255 10.745 24 24 24h192c13.255 0 24-10.745 24-24V56c0-13.255-10.745-24-24-24zM0 296v160c0 13.255 10.745 24 24 24h192c13.255 0 24-10.745 24-24V296c0-13.255-10.745-24-24-24H24c-13.255 0-24 10.745-24 24zm296 184h192c13.255 0 24-10.745 24-24V296c0-13.255-10.745-24-24-24H296c-13.255 0-24 10.745-24 24v160c0 13.255 10.745 24 24 24z\" />\n  </svg>\n);\n\nexport const ShapesSwitcher = ({\n  elementType,\n  setAppState,\n  isLibraryOpen,\n}: {\n  elementType: ExcalidrawElement[\"type\"];\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  isLibraryOpen: boolean;\n}) => (\n  <>\n    {SHAPES.map(({ value, icon, key }, index) => {\n      const label = t(`toolBar.${value}`);\n      const letter = typeof key === \"string\" ? key : key[0];\n      const shortcut = `${capitalizeString(letter)} ${t(\"helpDialog.or\")} ${\n        index + 1\n      }`;\n      return (\n        <ToolButton\n          className=\"Shape\"\n          key={value}\n          type=\"radio\"\n          icon={icon}\n          checked={elementType === value}\n          name=\"editor-current-shape\"\n          title={`${capitalizeString(label)}  ${shortcut}`}\n          keyBindingLabel={`${index + 1}`}\n          aria-label={capitalizeString(label)}\n          aria-keyshortcuts={shortcut}\n          data-testid={value}\n          onChange={() => {\n            setAppState({\n              elementType: value,\n              multiElement: null,\n              selectedElementIds: {},\n            });\n            setCursorForShape(value);\n            setAppState({});\n          }}\n        />\n      );\n    })}\n    <ToolButton\n      className=\"Shape ToolIcon_type_button__library\"\n      type=\"button\"\n      icon={LIBRARY_ICON}\n      name=\"editor-library\"\n      keyBindingLabel=\"9\"\n      aria-keyshortcuts=\"9\"\n      title={`${capitalizeString(t(\"toolBar.library\"))}  9`}\n      aria-label={capitalizeString(t(\"toolBar.library\"))}\n      onClick={() => {\n        setAppState({ isLibraryOpen: !isLibraryOpen });\n      }}\n    />\n  </>\n);\n\nexport const ZoomActions = ({\n  renderAction,\n  zoom,\n}: {\n  renderAction: ActionManager[\"renderAction\"];\n  zoom: Zoom;\n}) => (\n  <Stack.Col gap={1}>\n    <Stack.Row gap={1} align=\"center\">\n      {renderAction(\"zoomIn\")}\n      {renderAction(\"zoomOut\")}\n      {renderAction(\"resetZoom\")}\n      <div style={{ marginInlineStart: 4 }}>\n        {(zoom.value * 100).toFixed(0)}%\n      </div>\n    </Stack.Row>\n  </Stack.Col>\n);\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport { t } from \"../i18n\";\n\nexport type Appearence = \"light\" | \"dark\";\n\n// We chose to use only explicit toggle and not a third option for system value,\n// but this could be added in the future.\nexport const DarkModeToggle = (props: {\n  value: Appearence;\n  onChange: (value: Appearence) => void;\n}) => {\n  return (\n    <label\n      className={`ToolIcon ToolIcon_type_floating ToolIcon_size_M`}\n      title={\n        props.value === \"dark\" ? t(\"buttons.lightMode\") : t(\"buttons.darkMode\")\n      }\n    >\n      <input\n        className=\"ToolIcon_type_checkbox ToolIcon_toggle_opaque\"\n        type=\"checkbox\"\n        onChange={(event) =>\n          props.onChange(event.target.checked ? \"dark\" : \"light\")\n        }\n        checked={props.value === \"dark\"}\n        aria-label={\n          props.value === \"dark\"\n            ? t(\"buttons.lightMode\")\n            : t(\"buttons.darkMode\")\n        }\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.value === \"light\" ? ICONS.MOON : ICONS.SUN}\n      </div>\n    </label>\n  );\n};\n\nconst ICONS = {\n  SUN: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z\"\n      ></path>\n    </svg>\n  ),\n  MOON: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z\"\n      ></path>\n    </svg>\n  ),\n};\n","import React from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { AppState } from \"../types\";\nimport { DarkModeToggle } from \"./DarkModeToggle\";\n\nexport const BackgroundPickerAndDarkModeToggle = ({\n  appState,\n  setAppState,\n  actionManager,\n}: {\n  actionManager: ActionManager;\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}) => (\n  <div style={{ display: \"flex\" }}>\n    {actionManager.renderAction(\"changeViewBackgroundColor\")}\n    <div style={{ marginInlineStart: \"0.25rem\" }}>\n      <DarkModeToggle\n        value={appState.appearance}\n        onChange={(appearance) => {\n          setAppState({ appearance });\n        }}\n      />\n    </div>\n  </div>\n);\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { ToolButton } from \"./ToolButton\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { users } from \"./icons\";\n\nimport \"./CollabButton.scss\";\n\nconst CollabButton = ({\n  isCollaborating,\n  collaboratorCount,\n  onClick,\n}: {\n  isCollaborating: boolean;\n  collaboratorCount: number;\n  onClick: () => void;\n}) => {\n  return (\n    <>\n      <ToolButton\n        className={clsx(\"CollabButton\", {\n          \"is-collaborating\": isCollaborating,\n        })}\n        onClick={onClick}\n        icon={users}\n        type=\"button\"\n        title={t(\"buttons.roomDialog\")}\n        aria-label={t(\"buttons.roomDialog\")}\n        showAriaLabel={useIsMobile()}\n      >\n        {collaboratorCount > 0 && (\n          <div className=\"CollabButton-collaborators\">{collaboratorCount}</div>\n        )}\n      </ToolButton>\n    </>\n  );\n};\n\nexport default CollabButton;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\nimport { ActionsManagerInterface } from \"../actions/types\";\nimport { probablySupportsClipboardBlob } from \"../clipboard\";\nimport { canvasToBlob } from \"../data/blob\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { exportToCanvas, getExportSize } from \"../scene/export\";\nimport { AppState } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport \"./ExportDialog.scss\";\nimport { clipboard, exportFile, link } from \"./icons\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\n\nconst scales = [1, 2, 3];\nconst defaultScale = scales.includes(devicePixelRatio) ? devicePixelRatio : 1;\n\nexport const ErrorCanvasPreview = () => {\n  return (\n    <div>\n      <h3>{t(\"canvasError.cannotShowPreview\")}</h3>\n      <p>\n        <span>{t(\"canvasError.canvasTooBig\")}</span>\n      </p>\n      <em>({t(\"canvasError.canvasTooBigTip\")})</em>\n    </div>\n  );\n};\n\nconst renderPreview = (\n  content: HTMLCanvasElement | Error,\n  previewNode: HTMLDivElement,\n) => {\n  unmountComponentAtNode(previewNode);\n  previewNode.innerHTML = \"\";\n  if (content instanceof HTMLCanvasElement) {\n    previewNode.appendChild(content);\n  } else {\n    render(<ErrorCanvasPreview />, previewNode);\n  }\n};\n\nexport type ExportCB = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  scale?: number,\n) => void;\n\nconst ExportModal = ({\n  elements,\n  appState,\n  exportPadding = 10,\n  actionManager,\n  onExportToPng,\n  onExportToSvg,\n  onExportToClipboard,\n  onExportToBackend,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  exportPadding?: number;\n  actionManager: ActionsManagerInterface;\n  onExportToPng: ExportCB;\n  onExportToSvg: ExportCB;\n  onExportToClipboard: ExportCB;\n  onExportToBackend?: ExportCB;\n  onCloseRequest: () => void;\n}) => {\n  const someElementIsSelected = isSomeElementSelected(elements, appState);\n  const [scale, setScale] = useState(defaultScale);\n  const [exportSelected, setExportSelected] = useState(someElementIsSelected);\n  const previewRef = useRef<HTMLDivElement>(null);\n  const {\n    exportBackground,\n    viewBackgroundColor,\n    shouldAddWatermark,\n  } = appState;\n\n  const exportedElements = exportSelected\n    ? getSelectedElements(elements, appState)\n    : elements;\n\n  useEffect(() => {\n    setExportSelected(someElementIsSelected);\n  }, [someElementIsSelected]);\n\n  useEffect(() => {\n    const previewNode = previewRef.current;\n    if (!previewNode) {\n      return;\n    }\n    try {\n      const canvas = exportToCanvas(exportedElements, appState, {\n        exportBackground,\n        viewBackgroundColor,\n        exportPadding,\n        scale,\n        shouldAddWatermark,\n      });\n\n      // if converting to blob fails, there's some problem that will\n      // likely prevent preview and export (e.g. canvas too big)\n      canvasToBlob(canvas)\n        .then(() => {\n          renderPreview(canvas, previewNode);\n        })\n        .catch((error) => {\n          console.error(error);\n          renderPreview(new CanvasError(), previewNode);\n        });\n    } catch (error) {\n      console.error(error);\n      renderPreview(new CanvasError(), previewNode);\n    }\n  }, [\n    appState,\n    exportedElements,\n    exportBackground,\n    exportPadding,\n    viewBackgroundColor,\n    scale,\n    shouldAddWatermark,\n  ]);\n\n  return (\n    <div className=\"ExportDialog\">\n      <div className=\"ExportDialog__preview\" ref={previewRef} />\n      <Stack.Col gap={2} align=\"center\">\n        <div className=\"ExportDialog__actions\">\n          <Stack.Row gap={2}>\n            <ToolButton\n              type=\"button\"\n              label=\"PNG\"\n              title={t(\"buttons.exportToPng\")}\n              aria-label={t(\"buttons.exportToPng\")}\n              onClick={() => onExportToPng(exportedElements, scale)}\n            />\n            <ToolButton\n              type=\"button\"\n              label=\"SVG\"\n              title={t(\"buttons.exportToSvg\")}\n              aria-label={t(\"buttons.exportToSvg\")}\n              onClick={() => onExportToSvg(exportedElements, scale)}\n            />\n            {probablySupportsClipboardBlob && (\n              <ToolButton\n                type=\"button\"\n                icon={clipboard}\n                title={t(\"buttons.copyPngToClipboard\")}\n                aria-label={t(\"buttons.copyPngToClipboard\")}\n                onClick={() => onExportToClipboard(exportedElements, scale)}\n              />\n            )}\n            {onExportToBackend && (\n              <ToolButton\n                type=\"button\"\n                icon={link}\n                title={t(\"buttons.getShareableLink\")}\n                aria-label={t(\"buttons.getShareableLink\")}\n                onClick={() => onExportToBackend(exportedElements)}\n              />\n            )}\n          </Stack.Row>\n          <div className=\"ExportDialog__name\">\n            {actionManager.renderAction(\"changeProjectName\")}\n          </div>\n          <Stack.Row gap={2}>\n            {scales.map((s) => {\n              const [width, height] = getExportSize(\n                exportedElements,\n                exportPadding,\n                shouldAddWatermark,\n                s,\n              );\n\n              const scaleButtonTitle = `${t(\n                \"buttons.scale\",\n              )} ${s}x (${width}x${height})`;\n\n              return (\n                <ToolButton\n                  key={s}\n                  size=\"s\"\n                  type=\"radio\"\n                  icon={`${s}x`}\n                  name=\"export-canvas-scale\"\n                  title={scaleButtonTitle}\n                  aria-label={scaleButtonTitle}\n                  id=\"export-canvas-scale\"\n                  checked={s === scale}\n                  onChange={() => setScale(s)}\n                />\n              );\n            })}\n          </Stack.Row>\n        </div>\n        {actionManager.renderAction(\"changeExportBackground\")}\n        {someElementIsSelected && (\n          <div>\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={exportSelected}\n                onChange={(event) =>\n                  setExportSelected(event.currentTarget.checked)\n                }\n              />{\" \"}\n              {t(\"labels.onlySelected\")}\n            </label>\n          </div>\n        )}\n        {actionManager.renderAction(\"changeExportEmbedScene\")}\n        {actionManager.renderAction(\"changeShouldAddWatermark\")}\n      </Stack.Col>\n    </div>\n  );\n};\n\nexport const ExportDialog = ({\n  elements,\n  appState,\n  exportPadding = 10,\n  actionManager,\n  onExportToPng,\n  onExportToSvg,\n  onExportToClipboard,\n  onExportToBackend,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  exportPadding?: number;\n  actionManager: ActionsManagerInterface;\n  onExportToPng: ExportCB;\n  onExportToSvg: ExportCB;\n  onExportToClipboard: ExportCB;\n  onExportToBackend?: ExportCB;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(false);\n  const triggerButton = useRef<HTMLButtonElement>(null);\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n    triggerButton.current?.focus();\n  }, []);\n\n  return (\n    <>\n      <ToolButton\n        onClick={() => {\n          setModalIsShown(true);\n        }}\n        icon={exportFile}\n        type=\"button\"\n        aria-label={t(\"buttons.export\")}\n        showAriaLabel={useIsMobile()}\n        title={t(\"buttons.export\")}\n        ref={triggerButton}\n      />\n      {modalIsShown && (\n        <Dialog onCloseRequest={handleClose} title={t(\"buttons.export\")}>\n          <ExportModal\n            elements={elements}\n            appState={appState}\n            exportPadding={exportPadding}\n            actionManager={actionManager}\n            onExportToPng={onExportToPng}\n            onExportToSvg={onExportToSvg}\n            onExportToClipboard={onExportToClipboard}\n            onExportToBackend={onExportToBackend}\n            onCloseRequest={handleClose}\n          />\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import \"./FixedSideContainer.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype FixedSideContainerProps = {\n  children: React.ReactNode;\n  side: \"top\" | \"left\" | \"right\";\n  className?: string;\n};\n\nexport const FixedSideContainer = ({\n  children,\n  side,\n  className,\n}: FixedSideContainerProps) => (\n  <div\n    className={clsx(\n      \"FixedSideContainer\",\n      `FixedSideContainer_side_${side}`,\n      className,\n    )}\n  >\n    {children}\n  </div>\n);\n","import oc from \"open-color\";\nimport React from \"react\";\n\n// https://github.com/tholman/github-corners\nexport const GitHubCorner = React.memo(\n  ({ appearance }: { appearance: \"light\" | \"dark\" }) => (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"40\"\n      height=\"40\"\n      viewBox=\"0 0 250 250\"\n      className=\"github-corner rtl-mirror\"\n    >\n      <a\n        href=\"https://github.com/excalidraw/excalidraw\"\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        aria-label=\"GitHub repository\"\n      >\n        <path\n          d=\"M0 0l115 115h15l12 27 108 108V0z\"\n          fill={appearance === \"light\" ? oc.gray[6] : oc.gray[8]}\n        />\n        <path\n          className=\"octo-arm\"\n          d=\"M128 109c-15-9-9-19-9-19 3-7 2-11 2-11-1-7 3-2 3-2 4 5 2 11 2 11-3 10 5 15 9 16\"\n          style={{ transformOrigin: \"130px 106px\" }}\n          fill={appearance === \"light\" ? oc.white : oc.black}\n        />\n        <path\n          className=\"octo-body\"\n          d=\"M115 115s4 2 5 0l14-14c3-2 6-3 8-3-8-11-15-24 2-41 5-5 10-7 16-7 1-2 3-7 12-11 0 0 5 3 7 16 4 2 8 5 12 9s7 8 9 12c14 3 17 7 17 7-4 8-9 11-11 11 0 6-2 11-7 16-16 16-30 10-41 2 0 3-1 7-5 11l-12 11c-1 1 1 5 1 5z\"\n          fill={appearance === \"light\" ? oc.white : oc.black}\n        />\n      </a>\n    </svg>\n  ),\n);\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getSelectedElements } from \"../scene\";\n\nimport \"./HintViewer.scss\";\nimport { AppState } from \"../types\";\nimport { isLinearElement } from \"../element/typeChecks\";\nimport { getShortcutKey } from \"../utils\";\n\ninterface Hint {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n}\n\nconst getHints = ({ appState, elements }: Hint) => {\n  const { elementType, isResizing, isRotating, lastPointerDownWith } = appState;\n  const multiMode = appState.multiElement !== null;\n  if (elementType === \"arrow\" || elementType === \"line\") {\n    if (!multiMode) {\n      return t(\"hints.linearElement\");\n    }\n    return t(\"hints.linearElementMulti\");\n  }\n\n  if (elementType === \"draw\") {\n    return t(\"hints.freeDraw\");\n  }\n\n  if (elementType === \"text\") {\n    return t(\"hints.text\");\n  }\n\n  const selectedElements = getSelectedElements(elements, appState);\n  if (\n    isResizing &&\n    lastPointerDownWith === \"mouse\" &&\n    selectedElements.length === 1\n  ) {\n    const targetElement = selectedElements[0];\n    if (isLinearElement(targetElement) && targetElement.points.length === 2) {\n      return t(\"hints.lockAngle\");\n    }\n    return t(\"hints.resize\");\n  }\n\n  if (isRotating && lastPointerDownWith === \"mouse\") {\n    return t(\"hints.rotate\");\n  }\n\n  if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n    if (appState.editingLinearElement) {\n      return appState.editingLinearElement.activePointIndex\n        ? t(\"hints.lineEditor_pointSelected\")\n        : t(\"hints.lineEditor_nothingSelected\");\n    }\n    return t(\"hints.lineEditor_info\");\n  }\n\n  return null;\n};\n\nexport const HintViewer = ({ appState, elements }: Hint) => {\n  let hint = getHints({\n    appState,\n    elements,\n  });\n  if (!hint) {\n    return null;\n  }\n\n  hint = getShortcutKey(hint);\n\n  return (\n    <div className=\"HintViewer\">\n      <span>{hint}</span>\n    </div>\n  );\n};\n","import clsx from \"clsx\";\nimport oc from \"open-color\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { close } from \"../components/icons\";\nimport { MIME_TYPES } from \"../constants\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { exportToSvg } from \"../scene/export\";\nimport { LibraryItem } from \"../types\";\nimport \"./LibraryUnit.scss\";\n\n// fa-plus\nconst PLUS_ICON = (\n  <svg viewBox=\"0 0 1792 1792\">\n    <path\n      fill=\"currentColor\"\n      d=\"M1600 736v192q0 40-28 68t-68 28h-416v416q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-416h-416q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h416v-416q0-40 28-68t68-28h192q40 0 68 28t28 68v416h416q40 0 68 28t28 68z\"\n    />\n  </svg>\n);\n\nexport const LibraryUnit = ({\n  elements,\n  pendingElements,\n  onRemoveFromLibrary,\n  onClick,\n}: {\n  elements?: LibraryItem;\n  pendingElements?: LibraryItem;\n  onRemoveFromLibrary: () => void;\n  onClick: () => void;\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useEffect(() => {\n    const elementsToRender = elements || pendingElements;\n    if (!elementsToRender) {\n      return;\n    }\n    const svg = exportToSvg(elementsToRender, {\n      exportBackground: false,\n      viewBackgroundColor: oc.white,\n      shouldAddWatermark: false,\n    });\n    for (const child of ref.current!.children) {\n      if (child.tagName !== \"svg\") {\n        continue;\n      }\n      ref.current!.removeChild(child);\n    }\n    ref.current!.appendChild(svg);\n\n    const current = ref.current!;\n    return () => {\n      current.removeChild(svg);\n    };\n  }, [elements, pendingElements]);\n\n  const [isHovered, setIsHovered] = useState(false);\n  const isMobile = useIsMobile();\n\n  const adder = (isHovered || isMobile) && pendingElements && (\n    <div className=\"library-unit__adder\">{PLUS_ICON}</div>\n  );\n\n  return (\n    <div\n      className={clsx(\"library-unit\", {\n        \"library-unit__active\": elements || pendingElements,\n      })}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n    >\n      <div\n        className={clsx(\"library-unit__dragger\", {\n          \"library-unit__pulse\": !!pendingElements,\n        })}\n        ref={ref}\n        draggable={!!elements}\n        onClick={!!elements || !!pendingElements ? onClick : undefined}\n        onDragStart={(event) => {\n          setIsHovered(false);\n          event.dataTransfer.setData(\n            MIME_TYPES.excalidrawlib,\n            JSON.stringify(elements),\n          );\n        }}\n      />\n      {adder}\n      {elements && (isHovered || isMobile) && (\n        <button\n          className=\"library-unit__removeFromLibrary\"\n          aria-label={t(\"labels.removeFromLibrary\")}\n          onClick={onRemoveFromLibrary}\n        >\n          {close}\n        </button>\n      )}\n    </div>\n  );\n};\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype LockIconSize = \"s\" | \"m\";\n\ntype LockIconProps = {\n  title?: string;\n  name?: string;\n  id?: string;\n  checked: boolean;\n  onChange?(): void;\n  size?: LockIconSize;\n  zenModeEnabled?: boolean;\n};\n\nconst DEFAULT_SIZE: LockIconSize = \"m\";\n\nconst ICONS = {\n  CHECKED: (\n    <svg\n      width=\"1792\"\n      height=\"1792\"\n      viewBox=\"0 0 1792 1792\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path d=\"M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z\" />\n    </svg>\n  ),\n  UNCHECKED: (\n    <svg\n      width=\"1792\"\n      height=\"1792\"\n      viewBox=\"0 0 1792 1792\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className=\"unlocked-icon rtl-mirror\"\n    >\n      <path d=\"M1728 576v256q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45v-256q0-106-75-181t-181-75-181 75-75 181v192h96q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h672v-192q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5z\" />\n    </svg>\n  ),\n};\n\nexport const LockIcon = (props: LockIconProps) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__lock ToolIcon_type_floating zen-mode-visibility\",\n        `ToolIcon_size_${props.size || DEFAULT_SIZE}`,\n        {\n          \"zen-mode-visibility--hidden\": props.zenModeEnabled,\n        },\n      )}\n      title={`${props.title}  Q`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        id={props.id}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.checked ? ICONS.CHECKED : ICONS.UNCHECKED}\n      </div>\n    </label>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\n\ninterface SectionProps extends React.HTMLProps<HTMLElement> {\n  heading: string;\n  children: React.ReactNode | ((header: React.ReactNode) => React.ReactNode);\n}\n\nexport const Section = ({ heading, children, ...props }: SectionProps) => {\n  const header = (\n    <h2 className=\"visually-hidden\" id={`${heading}-title`}>\n      {t(`headings.${heading}`)}\n    </h2>\n  );\n  return (\n    <section {...props} aria-labelledby={`${heading}-title`}>\n      {typeof children === \"function\" ? (\n        children(header)\n      ) : (\n        <>\n          {header}\n          {children}\n        </>\n      )}\n    </section>\n  );\n};\n","import \"./UserList.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype UserListProps = {\n  children: React.ReactNode;\n  className?: string;\n  mobile?: boolean;\n};\n\nexport const UserList = ({ children, className, mobile }: UserListProps) => {\n  return (\n    <div className={clsx(\"UserList\", className, { UserList_mobile: mobile })}>\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport { AppState } from \"../types\";\nimport { ActionManager } from \"../actions/manager\";\nimport { t } from \"../i18n\";\nimport Stack from \"./Stack\";\nimport { showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { Island } from \"./Island\";\nimport { HintViewer } from \"./HintViewer\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { SelectedShapeActions, ShapesSwitcher } from \"./Actions\";\nimport { Section } from \"./Section\";\nimport CollabButton from \"./CollabButton\";\nimport { SCROLLBAR_WIDTH, SCROLLBAR_MARGIN } from \"../scene/scrollbars\";\nimport { LockIcon } from \"./LockIcon\";\nimport { UserList } from \"./UserList\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\n\ntype MobileMenuProps = {\n  appState: AppState;\n  actionManager: ActionManager;\n  exportButton: React.ReactNode;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  libraryMenu: JSX.Element | null;\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  canvas: HTMLCanvasElement | null;\n  isCollaborating: boolean;\n  renderCustomFooter?: (isMobile: boolean) => JSX.Element;\n  viewModeEnabled: boolean;\n};\n\nexport const MobileMenu = ({\n  appState,\n  elements,\n  libraryMenu,\n  actionManager,\n  exportButton,\n  setAppState,\n  onCollabButtonClick,\n  onLockToggle,\n  canvas,\n  isCollaborating,\n  renderCustomFooter,\n  viewModeEnabled,\n}: MobileMenuProps) => {\n  const renderToolbar = () => {\n    return (\n      <FixedSideContainer side=\"top\" className=\"App-top-bar\">\n        <Section heading=\"shapes\">\n          {(heading) => (\n            <Stack.Col gap={4} align=\"center\">\n              <Stack.Row gap={1}>\n                <Island padding={1}>\n                  {heading}\n                  <Stack.Row gap={1}>\n                    <ShapesSwitcher\n                      elementType={appState.elementType}\n                      setAppState={setAppState}\n                      isLibraryOpen={appState.isLibraryOpen}\n                    />\n                  </Stack.Row>\n                </Island>\n                <LockIcon\n                  checked={appState.elementLocked}\n                  onChange={onLockToggle}\n                  title={t(\"toolBar.lock\")}\n                />\n              </Stack.Row>\n              {libraryMenu}\n            </Stack.Col>\n          )}\n        </Section>\n        <HintViewer appState={appState} elements={elements} />\n      </FixedSideContainer>\n    );\n  };\n\n  const renderAppToolbar = () => {\n    if (viewModeEnabled) {\n      return (\n        <div className=\"App-toolbar-content\">\n          {actionManager.renderAction(\"toggleCanvasMenu\")}\n        </div>\n      );\n    }\n    return (\n      <div className=\"App-toolbar-content\">\n        {actionManager.renderAction(\"toggleCanvasMenu\")}\n        {actionManager.renderAction(\"toggleEditMenu\")}\n        {actionManager.renderAction(\"undo\")}\n        {actionManager.renderAction(\"redo\")}\n        {actionManager.renderAction(\n          appState.multiElement ? \"finalize\" : \"duplicateSelection\",\n        )}\n        {actionManager.renderAction(\"deleteSelectedElements\")}\n      </div>\n    );\n  };\n\n  const renderCanvasActions = () => {\n    if (viewModeEnabled) {\n      return (\n        <>\n          {actionManager.renderAction(\"saveScene\")}\n          {actionManager.renderAction(\"saveAsScene\")}\n          {exportButton}\n        </>\n      );\n    }\n    return (\n      <>\n        {actionManager.renderAction(\"loadScene\")}\n        {actionManager.renderAction(\"saveScene\")}\n        {actionManager.renderAction(\"saveAsScene\")}\n        {exportButton}\n        {actionManager.renderAction(\"clearCanvas\")}\n        {onCollabButtonClick && (\n          <CollabButton\n            isCollaborating={isCollaborating}\n            collaboratorCount={appState.collaborators.size}\n            onClick={onCollabButtonClick}\n          />\n        )}\n        {\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n          />\n        }\n      </>\n    );\n  };\n  return (\n    <>\n      {!viewModeEnabled && renderToolbar()}\n      <div\n        className=\"App-bottom-bar\"\n        style={{\n          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n        }}\n      >\n        <Island padding={0}>\n          {appState.openMenu === \"canvas\" ? (\n            <Section className=\"App-mobile-menu\" heading=\"canvasActions\">\n              <div className=\"panelColumn\">\n                <Stack.Col gap={4}>\n                  {renderCanvasActions()}\n                  {renderCustomFooter?.(true)}\n                  {appState.collaborators.size > 0 && (\n                    <fieldset>\n                      <legend>{t(\"labels.collaborators\")}</legend>\n                      <UserList mobile>\n                        {Array.from(appState.collaborators)\n                          // Collaborator is either not initialized or is actually the current user.\n                          .filter(\n                            ([_, client]) => Object.keys(client).length !== 0,\n                          )\n                          .map(([clientId, client]) => (\n                            <React.Fragment key={clientId}>\n                              {actionManager.renderAction(\n                                \"goToCollaborator\",\n                                clientId,\n                              )}\n                            </React.Fragment>\n                          ))}\n                      </UserList>\n                    </fieldset>\n                  )}\n                </Stack.Col>\n              </div>\n            </Section>\n          ) : appState.openMenu === \"shape\" &&\n            !viewModeEnabled &&\n            showSelectedShapeActions(appState, elements) ? (\n            <Section className=\"App-mobile-menu\" heading=\"selectedShapeActions\">\n              <SelectedShapeActions\n                appState={appState}\n                elements={elements}\n                renderAction={actionManager.renderAction}\n                elementType={appState.elementType}\n              />\n            </Section>\n          ) : null}\n          <footer className=\"App-toolbar\">\n            {renderAppToolbar()}\n            {appState.scrolledOutside && !appState.openMenu && (\n              <button\n                className=\"scroll-back-to-content\"\n                onClick={() => {\n                  setAppState({\n                    ...calculateScrollCenter(elements, appState, canvas),\n                  });\n                }}\n              >\n                {t(\"buttons.scrollBackToContent\")}\n              </button>\n            )}\n          </footer>\n        </Island>\n      </div>\n    </>\n  );\n};\n","import oc from \"open-color\";\nimport React, { useLayoutEffect, useRef, useState } from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { ChartElements, renderSpreadsheet, Spreadsheet } from \"../charts\";\nimport { ChartType } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { exportToSvg } from \"../scene/export\";\nimport { AppState, LibraryItem } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport \"./PasteChartDialog.scss\";\n\ntype OnInsertChart = (chartType: ChartType, elements: ChartElements) => void;\n\nconst ChartPreviewBtn = (props: {\n  spreadsheet: Spreadsheet | null;\n  chartType: ChartType;\n  selected: boolean;\n  onClick: OnInsertChart;\n}) => {\n  const previewRef = useRef<HTMLDivElement | null>(null);\n  const [chartElements, setChartElements] = useState<ChartElements | null>(\n    null,\n  );\n\n  useLayoutEffect(() => {\n    if (!props.spreadsheet) {\n      return;\n    }\n\n    const elements = renderSpreadsheet(\n      props.chartType,\n      props.spreadsheet,\n      0,\n      0,\n    );\n    setChartElements(elements);\n\n    const svg = exportToSvg(elements, {\n      exportBackground: false,\n      viewBackgroundColor: oc.white,\n      shouldAddWatermark: false,\n    });\n\n    const previewNode = previewRef.current!;\n\n    previewNode.appendChild(svg);\n\n    if (props.selected) {\n      (previewNode.parentNode as HTMLDivElement).focus();\n    }\n\n    return () => {\n      previewNode.removeChild(svg);\n    };\n  }, [props.spreadsheet, props.chartType, props.selected]);\n\n  return (\n    <button\n      className=\"ChartPreview\"\n      onClick={() => {\n        if (chartElements) {\n          props.onClick(props.chartType, chartElements);\n        }\n      }}\n    >\n      <div ref={previewRef} />\n    </button>\n  );\n};\n\nexport const PasteChartDialog = ({\n  setAppState,\n  appState,\n  onClose,\n  onInsertChart,\n}: {\n  appState: AppState;\n  onClose: () => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  onInsertChart: (elements: LibraryItem) => void;\n}) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  const handleChartClick = (chartType: ChartType, elements: ChartElements) => {\n    onInsertChart(elements);\n    trackEvent(\"magic\", \"chart\", chartType);\n    setAppState({\n      currentChartType: chartType,\n      pasteDialog: {\n        shown: false,\n        data: null,\n      },\n    });\n  };\n\n  return (\n    <Dialog\n      small\n      onCloseRequest={handleClose}\n      title={t(\"labels.pasteCharts\")}\n      className={\"PasteChartDialog\"}\n      autofocus={false}\n    >\n      <div className={\"container\"}>\n        <ChartPreviewBtn\n          chartType=\"bar\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"bar\"}\n          onClick={handleChartClick}\n        />\n        <ChartPreviewBtn\n          chartType=\"line\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"line\"}\n          onClick={handleChartClick}\n        />\n      </div>\n    </Dialog>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { isDarwin, isWindows } from \"../keys\";\nimport { Dialog } from \"./Dialog\";\nimport { getShortcutKey } from \"../utils\";\nimport \"./HelpDialog.scss\";\n\nconst Header = () => (\n  <div className=\"HelpDialog--header\">\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://github.com/excalidraw/excalidraw#documentation\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.documentation\")}\n    </a>\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://blog.excalidraw.com\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.blog\")}\n    </a>\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://github.com/excalidraw/excalidraw/issues\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.github\")}\n    </a>\n  </div>\n);\n\nconst Section = (props: { title: string; children: React.ReactNode }) => (\n  <>\n    <h3>{props.title}</h3>\n    {props.children}\n  </>\n);\n\nconst Columns = (props: { children: React.ReactNode }) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n    }}\n  >\n    {props.children}\n  </div>\n);\n\nconst Column = (props: { children: React.ReactNode }) => (\n  <div style={{ width: \"49%\" }}>{props.children}</div>\n);\n\nconst ShortcutIsland = (props: {\n  caption: string;\n  children: React.ReactNode;\n}) => (\n  <div className=\"HelpDialog--island\">\n    <h3 className=\"HelpDialog--island-title\">{props.caption}</h3>\n    {props.children}\n  </div>\n);\n\nconst Shortcut = (props: {\n  label: string;\n  shortcuts: string[];\n  isOr: boolean;\n}) => {\n  return (\n    <div className=\"HelpDialog--shortcut\">\n      <div\n        style={{\n          display: \"flex\",\n          margin: \"0\",\n          padding: \"4px 8px\",\n          alignItems: \"center\",\n        }}\n      >\n        <div\n          style={{\n            lineHeight: 1.4,\n          }}\n        >\n          {props.label}\n        </div>\n        <div\n          style={{\n            display: \"flex\",\n            flex: \"0 0 auto\",\n            justifyContent: \"flex-end\",\n            marginInlineStart: \"auto\",\n            minWidth: \"30%\",\n          }}\n        >\n          {props.shortcuts.map((shortcut, index) => (\n            <React.Fragment key={index}>\n              <ShortcutKey>{shortcut}</ShortcutKey>\n              {props.isOr &&\n                index !== props.shortcuts.length - 1 &&\n                t(\"helpDialog.or\")}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nShortcut.defaultProps = {\n  isOr: true,\n};\n\nconst ShortcutKey = (props: { children: React.ReactNode }) => (\n  <kbd className=\"HelpDialog--key\" {...props} />\n);\n\nexport const HelpDialog = ({ onClose }: { onClose?: () => void }) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  return (\n    <>\n      <Dialog\n        onCloseRequest={handleClose}\n        title={t(\"helpDialog.title\")}\n        className={\"HelpDialog\"}\n      >\n        <Header />\n        <Section title={t(\"helpDialog.shortcuts\")}>\n          <Columns>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.shapes\")}>\n                <Shortcut\n                  label={t(\"toolBar.selection\")}\n                  shortcuts={[\"V\", \"1\"]}\n                />\n                <Shortcut\n                  label={t(\"toolBar.rectangle\")}\n                  shortcuts={[\"R\", \"2\"]}\n                />\n                <Shortcut label={t(\"toolBar.diamond\")} shortcuts={[\"D\", \"3\"]} />\n                <Shortcut label={t(\"toolBar.ellipse\")} shortcuts={[\"E\", \"4\"]} />\n                <Shortcut label={t(\"toolBar.arrow\")} shortcuts={[\"A\", \"5\"]} />\n                <Shortcut label={t(\"toolBar.line\")} shortcuts={[\"P\", \"6\"]} />\n                <Shortcut\n                  label={t(\"toolBar.draw\")}\n                  shortcuts={[\"Shift+P\", \"7\"]}\n                />\n                <Shortcut label={t(\"toolBar.text\")} shortcuts={[\"T\", \"8\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.textNewLine\")}\n                  shortcuts={[\n                    getShortcutKey(\"Enter\"),\n                    getShortcutKey(\"Shift+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.textFinish\")}\n                  shortcuts={[\n                    getShortcutKey(\"Esc\"),\n                    getShortcutKey(\"CtrlOrCmd+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedArrow\")}\n                  shortcuts={[\n                    \"A\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedLine\")}\n                  shortcuts={[\n                    \"L\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut label={t(\"toolBar.lock\")} shortcuts={[\"Q\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.preventBinding\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd\")]}\n                />\n              </ShortcutIsland>\n              <ShortcutIsland caption={t(\"helpDialog.view\")}>\n                <Shortcut\n                  label={t(\"buttons.zoomIn\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd++\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.zoomOut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+-\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.resetZoom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+0\")]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToFit\")}\n                  shortcuts={[\"Shift+1\"]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToSelection\")}\n                  shortcuts={[\"Shift+2\"]}\n                />\n                <Shortcut label={t(\"buttons.fullScreen\")} shortcuts={[\"F\"]} />\n                <Shortcut\n                  label={t(\"buttons.zenMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showGrid\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+'\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.viewMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+R\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.editor\")}>\n                <Shortcut\n                  label={t(\"labels.selectAll\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+A\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.multiSelect\")}\n                  shortcuts={[getShortcutKey(`Shift+${t(\"helpDialog.click\")}`)]}\n                />\n                <Shortcut\n                  label={t(\"labels.moveCanvas\")}\n                  shortcuts={[\n                    getShortcutKey(`Space+${t(\"helpDialog.drag\")}`),\n                    getShortcutKey(`Wheel+${t(\"helpDialog.drag\")}`),\n                  ]}\n                  isOr={true}\n                />\n                <Shortcut\n                  label={t(\"labels.cut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+X\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copy\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.paste\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyAsPng\")}\n                  shortcuts={[getShortcutKey(\"Shift+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.pasteStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.delete\")}\n                  shortcuts={[getShortcutKey(\"Del\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendToBack\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringToFront\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendBackward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+[\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringForward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+]\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignTop\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Up\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignBottom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Down\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignLeft\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Left\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignRight\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Right\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.duplicateSelection\")}\n                  shortcuts={[\n                    getShortcutKey(\"CtrlOrCmd+D\"),\n                    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"buttons.undo\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.redo\")}\n                  shortcuts={\n                    isWindows\n                      ? [\n                          getShortcutKey(\"CtrlOrCmd+Y\"),\n                          getShortcutKey(\"CtrlOrCmd+Shift+Z\"),\n                        ]\n                      : [getShortcutKey(\"CtrlOrCmd+Shift+Z\")]\n                  }\n                />\n                <Shortcut\n                  label={t(\"labels.group\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+G\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.ungroup\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+G\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n          </Columns>\n        </Section>\n      </Dialog>\n    </>\n  );\n};\n","import clsx from \"clsx\";\nimport React, {\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { CLASSES } from \"../constants\";\nimport { exportCanvas } from \"../data\";\nimport { importLibraryFromJSON, saveLibraryAsJSON } from \"../data/json\";\nimport { Library } from \"../data/library\";\nimport { isTextElement, showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { Language, t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { calculateScrollCenter, getSelectedElements } from \"../scene\";\nimport { ExportType } from \"../scene/types\";\nimport { AppState, LibraryItem, LibraryItems } from \"../types\";\nimport { muteFSAbortError } from \"../utils\";\nimport { SelectedShapeActions, ShapesSwitcher, ZoomActions } from \"./Actions\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\nimport CollabButton from \"./CollabButton\";\nimport { ErrorDialog } from \"./ErrorDialog\";\nimport { ExportCB, ExportDialog } from \"./ExportDialog\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { GitHubCorner } from \"./GitHubCorner\";\nimport { HintViewer } from \"./HintViewer\";\nimport { exportFile, load, shield } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./LayerUI.scss\";\nimport { LibraryUnit } from \"./LibraryUnit\";\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { LockIcon } from \"./LockIcon\";\nimport { MobileMenu } from \"./MobileMenu\";\nimport { PasteChartDialog } from \"./PasteChartDialog\";\nimport { Section } from \"./Section\";\nimport { HelpDialog } from \"./HelpDialog\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport { Tooltip } from \"./Tooltip\";\nimport { UserList } from \"./UserList\";\n\ninterface LayerUIProps {\n  actionManager: ActionManager;\n  appState: AppState;\n  canvas: HTMLCanvasElement | null;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  onInsertElements: (elements: readonly NonDeletedExcalidrawElement[]) => void;\n  zenModeEnabled: boolean;\n  showExitZenModeBtn: boolean;\n  toggleZenMode: () => void;\n  langCode: Language[\"code\"];\n  isCollaborating: boolean;\n  onExportToBackend?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => void;\n  renderCustomFooter?: (isMobile: boolean) => JSX.Element;\n  viewModeEnabled: boolean;\n}\n\nconst useOnClickOutside = (\n  ref: RefObject<HTMLElement>,\n  cb: (event: MouseEvent) => void,\n) => {\n  useEffect(() => {\n    const listener = (event: MouseEvent) => {\n      if (!ref.current) {\n        return;\n      }\n\n      if (\n        event.target instanceof Element &&\n        (ref.current.contains(event.target) ||\n          !document.body.contains(event.target))\n      ) {\n        return;\n      }\n\n      cb(event);\n    };\n    document.addEventListener(\"pointerdown\", listener, false);\n\n    return () => {\n      document.removeEventListener(\"pointerdown\", listener);\n    };\n  }, [ref, cb]);\n};\n\nconst LibraryMenuItems = ({\n  library,\n  onRemoveFromLibrary,\n  onAddToLibrary,\n  onInsertShape,\n  pendingElements,\n  setAppState,\n}: {\n  library: LibraryItems;\n  pendingElements: LibraryItem;\n  onRemoveFromLibrary: (index: number) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: (elements: LibraryItem) => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}) => {\n  const isMobile = useIsMobile();\n  const numCells = library.length + (pendingElements.length > 0 ? 1 : 0);\n  const CELLS_PER_ROW = isMobile ? 4 : 6;\n  const numRows = Math.max(1, Math.ceil(numCells / CELLS_PER_ROW));\n  const rows = [];\n  let addedPendingElements = false;\n\n  rows.push(\n    <div className=\"layer-ui__library-header\">\n      <ToolButton\n        key=\"import\"\n        type=\"button\"\n        title={t(\"buttons.load\")}\n        aria-label={t(\"buttons.load\")}\n        icon={load}\n        onClick={() => {\n          importLibraryFromJSON()\n            .then(() => {\n              // Maybe we should close and open the menu so that the items get updated.\n              // But for now we just close the menu.\n              setAppState({ isLibraryOpen: false });\n            })\n            .catch(muteFSAbortError)\n            .catch((error) => {\n              setAppState({ errorMessage: error.message });\n            });\n        }}\n      />\n      <ToolButton\n        key=\"export\"\n        type=\"button\"\n        title={t(\"buttons.export\")}\n        aria-label={t(\"buttons.export\")}\n        icon={exportFile}\n        onClick={() => {\n          saveLibraryAsJSON()\n            .catch(muteFSAbortError)\n            .catch((error) => {\n              setAppState({ errorMessage: error.message });\n            });\n        }}\n      />\n\n      <a href=\"https://libraries.excalidraw.com\" target=\"_excalidraw_libraries\">\n        {t(\"labels.libraries\")}\n      </a>\n    </div>,\n  );\n\n  for (let row = 0; row < numRows; row++) {\n    const y = CELLS_PER_ROW * row;\n    const children = [];\n    for (let x = 0; x < CELLS_PER_ROW; x++) {\n      const shouldAddPendingElements: boolean =\n        pendingElements.length > 0 &&\n        !addedPendingElements &&\n        y + x >= library.length;\n      addedPendingElements = addedPendingElements || shouldAddPendingElements;\n\n      children.push(\n        <Stack.Col key={x}>\n          <LibraryUnit\n            elements={library[y + x]}\n            pendingElements={\n              shouldAddPendingElements ? pendingElements : undefined\n            }\n            onRemoveFromLibrary={onRemoveFromLibrary.bind(null, y + x)}\n            onClick={\n              shouldAddPendingElements\n                ? onAddToLibrary.bind(null, pendingElements)\n                : onInsertShape.bind(null, library[y + x])\n            }\n          />\n        </Stack.Col>,\n      );\n    }\n    rows.push(\n      <Stack.Row align=\"center\" gap={1} key={row}>\n        {children}\n      </Stack.Row>,\n    );\n  }\n\n  return (\n    <Stack.Col align=\"start\" gap={1} className=\"layer-ui__library-items\">\n      {rows}\n    </Stack.Col>\n  );\n};\n\nconst LibraryMenu = ({\n  onClickOutside,\n  onInsertShape,\n  pendingElements,\n  onAddToLibrary,\n  setAppState,\n}: {\n  pendingElements: LibraryItem;\n  onClickOutside: (event: MouseEvent) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: () => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useOnClickOutside(ref, (event) => {\n    // If click on the library icon, do nothing.\n    if ((event.target as Element).closest(\".ToolIcon_type_button__library\")) {\n      return;\n    }\n    onClickOutside(event);\n  });\n\n  const [libraryItems, setLibraryItems] = useState<LibraryItems>([]);\n\n  const [loadingState, setIsLoading] = useState<\n    \"preloading\" | \"loading\" | \"ready\"\n  >(\"preloading\");\n\n  const loadingTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    Promise.race([\n      new Promise((resolve) => {\n        loadingTimerRef.current = setTimeout(() => {\n          resolve(\"loading\");\n        }, 100);\n      }),\n      Library.loadLibrary().then((items) => {\n        setLibraryItems(items);\n        setIsLoading(\"ready\");\n      }),\n    ]).then((data) => {\n      if (data === \"loading\") {\n        setIsLoading(\"loading\");\n      }\n    });\n    return () => {\n      clearTimeout(loadingTimerRef.current!);\n    };\n  }, []);\n\n  const removeFromLibrary = useCallback(async (indexToRemove) => {\n    const items = await Library.loadLibrary();\n    const nextItems = items.filter((_, index) => index !== indexToRemove);\n    Library.saveLibrary(nextItems);\n    setLibraryItems(nextItems);\n  }, []);\n\n  const addToLibrary = useCallback(\n    async (elements: LibraryItem) => {\n      const items = await Library.loadLibrary();\n      const nextItems = [...items, elements];\n      onAddToLibrary();\n      Library.saveLibrary(nextItems);\n      setLibraryItems(nextItems);\n    },\n    [onAddToLibrary],\n  );\n\n  return loadingState === \"preloading\" ? null : (\n    <Island padding={1} ref={ref} className=\"layer-ui__library\">\n      {loadingState === \"loading\" ? (\n        <div className=\"layer-ui__library-message\">\n          {t(\"labels.libraryLoadingMessage\")}\n        </div>\n      ) : (\n        <LibraryMenuItems\n          library={libraryItems}\n          onRemoveFromLibrary={removeFromLibrary}\n          onAddToLibrary={addToLibrary}\n          onInsertShape={onInsertShape}\n          pendingElements={pendingElements}\n          setAppState={setAppState}\n        />\n      )}\n    </Island>\n  );\n};\n\nconst LayerUI = ({\n  actionManager,\n  appState,\n  setAppState,\n  canvas,\n  elements,\n  onCollabButtonClick,\n  onLockToggle,\n  onInsertElements,\n  zenModeEnabled,\n  showExitZenModeBtn,\n  toggleZenMode,\n  isCollaborating,\n  onExportToBackend,\n  renderCustomFooter,\n  viewModeEnabled,\n}: LayerUIProps) => {\n  const isMobile = useIsMobile();\n\n  const renderEncryptedIcon = () => (\n    <a\n      className={clsx(\"encrypted-icon tooltip zen-mode-visibility\", {\n        \"zen-mode-visibility--hidden\": zenModeEnabled,\n      })}\n      href=\"https://blog.excalidraw.com/end-to-end-encryption/\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      <Tooltip label={t(\"encrypted.tooltip\")} position=\"above\" long={true}>\n        {shield}\n      </Tooltip>\n    </a>\n  );\n\n  const renderExportDialog = () => {\n    const createExporter = (type: ExportType): ExportCB => async (\n      exportedElements,\n      scale,\n    ) => {\n      if (canvas) {\n        await exportCanvas(type, exportedElements, appState, canvas, {\n          exportBackground: appState.exportBackground,\n          name: appState.name,\n          viewBackgroundColor: appState.viewBackgroundColor,\n          scale,\n          shouldAddWatermark: appState.shouldAddWatermark,\n        })\n          .catch(muteFSAbortError)\n          .catch((error) => {\n            console.error(error);\n            setAppState({ errorMessage: error.message });\n          });\n      }\n    };\n\n    return (\n      <ExportDialog\n        elements={elements}\n        appState={appState}\n        actionManager={actionManager}\n        onExportToPng={createExporter(\"png\")}\n        onExportToSvg={createExporter(\"svg\")}\n        onExportToClipboard={createExporter(\"clipboard\")}\n        onExportToBackend={\n          onExportToBackend\n            ? (elements) => {\n                onExportToBackend &&\n                  onExportToBackend(elements, appState, canvas);\n              }\n            : undefined\n        }\n      />\n    );\n  };\n\n  const renderViewModeCanvasActions = () => {\n    return (\n      <Section\n        heading=\"canvasActions\"\n        className={clsx(\"zen-mode-transition\", {\n          \"transition-left\": zenModeEnabled,\n        })}\n      >\n        {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n        <Island padding={2} style={{ zIndex: 1 }}>\n          <Stack.Col gap={4}>\n            <Stack.Row gap={1} justifyContent=\"space-between\">\n              {actionManager.renderAction(\"saveScene\")}\n              {actionManager.renderAction(\"saveAsScene\")}\n              {renderExportDialog()}\n            </Stack.Row>\n          </Stack.Col>\n        </Island>\n      </Section>\n    );\n  };\n  const renderCanvasActions = () => (\n    <Section\n      heading=\"canvasActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n      <Island padding={2} style={{ zIndex: 1 }}>\n        <Stack.Col gap={4}>\n          <Stack.Row gap={1} justifyContent=\"space-between\">\n            {actionManager.renderAction(\"loadScene\")}\n            {actionManager.renderAction(\"saveScene\")}\n            {actionManager.renderAction(\"saveAsScene\")}\n            {renderExportDialog()}\n            {actionManager.renderAction(\"clearCanvas\")}\n            {onCollabButtonClick && (\n              <CollabButton\n                isCollaborating={isCollaborating}\n                collaboratorCount={appState.collaborators.size}\n                onClick={onCollabButtonClick}\n              />\n            )}\n          </Stack.Row>\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n          />\n        </Stack.Col>\n      </Island>\n    </Section>\n  );\n\n  const renderSelectedShapeActions = () => (\n    <Section\n      heading=\"selectedShapeActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      <Island className={CLASSES.SHAPE_ACTIONS_MENU} padding={2}>\n        <SelectedShapeActions\n          appState={appState}\n          elements={elements}\n          renderAction={actionManager.renderAction}\n          elementType={appState.elementType}\n        />\n      </Island>\n    </Section>\n  );\n\n  const closeLibrary = useCallback(\n    (event) => {\n      setAppState({ isLibraryOpen: false });\n    },\n    [setAppState],\n  );\n\n  const deselectItems = useCallback(() => {\n    setAppState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n    });\n  }, [setAppState]);\n\n  const libraryMenu = appState.isLibraryOpen ? (\n    <LibraryMenu\n      pendingElements={getSelectedElements(elements, appState)}\n      onClickOutside={closeLibrary}\n      onInsertShape={onInsertElements}\n      onAddToLibrary={deselectItems}\n      setAppState={setAppState}\n    />\n  ) : null;\n\n  const renderFixedSideContainer = () => {\n    const shouldRenderSelectedShapeActions = showSelectedShapeActions(\n      appState,\n      elements,\n    );\n\n    return (\n      <FixedSideContainer side=\"top\">\n        <div className=\"App-menu App-menu_top\">\n          <Stack.Col\n            gap={4}\n            className={clsx({ \"disable-pointerEvents\": zenModeEnabled })}\n          >\n            {viewModeEnabled\n              ? renderViewModeCanvasActions()\n              : renderCanvasActions()}\n            {shouldRenderSelectedShapeActions && renderSelectedShapeActions()}\n          </Stack.Col>\n          {!viewModeEnabled && (\n            <Section heading=\"shapes\">\n              {(heading) => (\n                <Stack.Col gap={4} align=\"start\">\n                  <Stack.Row gap={1}>\n                    <Island\n                      padding={1}\n                      className={clsx({ \"zen-mode\": zenModeEnabled })}\n                    >\n                      <HintViewer appState={appState} elements={elements} />\n                      {heading}\n                      <Stack.Row gap={1}>\n                        <ShapesSwitcher\n                          elementType={appState.elementType}\n                          setAppState={setAppState}\n                          isLibraryOpen={appState.isLibraryOpen}\n                        />\n                      </Stack.Row>\n                    </Island>\n                    <LockIcon\n                      zenModeEnabled={zenModeEnabled}\n                      checked={appState.elementLocked}\n                      onChange={onLockToggle}\n                      title={t(\"toolBar.lock\")}\n                    />\n                  </Stack.Row>\n                  {libraryMenu}\n                </Stack.Col>\n              )}\n            </Section>\n          )}\n          <UserList\n            className={clsx(\"zen-mode-transition\", {\n              \"transition-right\": zenModeEnabled,\n            })}\n          >\n            {appState.collaborators.size > 0 &&\n              Array.from(appState.collaborators)\n                // Collaborator is either not initialized or is actually the current user.\n                .filter(([_, client]) => Object.keys(client).length !== 0)\n                .map(([clientId, client]) => (\n                  <Tooltip\n                    label={client.username || \"Unknown user\"}\n                    key={clientId}\n                  >\n                    {actionManager.renderAction(\"goToCollaborator\", clientId)}\n                  </Tooltip>\n                ))}\n          </UserList>\n        </div>\n      </FixedSideContainer>\n    );\n  };\n\n  const renderBottomAppMenu = () => {\n    return (\n      <div\n        className={clsx(\"App-menu App-menu_bottom zen-mode-transition\", {\n          \"App-menu_bottom--transition-left\": zenModeEnabled,\n        })}\n      >\n        <Stack.Col gap={2}>\n          <Section heading=\"canvasActions\">\n            <Island padding={1}>\n              <ZoomActions\n                renderAction={actionManager.renderAction}\n                zoom={appState.zoom}\n              />\n            </Island>\n            {renderEncryptedIcon()}\n          </Section>\n        </Stack.Col>\n      </div>\n    );\n  };\n\n  const renderGitHubCorner = () => {\n    return (\n      <aside\n        className={clsx(\n          \"layer-ui__wrapper__github-corner zen-mode-transition\",\n          {\n            \"transition-right\": zenModeEnabled,\n          },\n        )}\n      >\n        <GitHubCorner appearance={appState.appearance} />\n      </aside>\n    );\n  };\n  const renderFooter = () => (\n    <footer role=\"contentinfo\" className=\"layer-ui__wrapper__footer\">\n      <div\n        className={clsx(\"zen-mode-transition\", {\n          \"transition-right disable-pointerEvents\": zenModeEnabled,\n        })}\n      >\n        {renderCustomFooter?.(false)}\n        {actionManager.renderAction(\"toggleShortcuts\")}\n      </div>\n      <button\n        className={clsx(\"disable-zen-mode\", {\n          \"disable-zen-mode--visible\": showExitZenModeBtn,\n        })}\n        onClick={toggleZenMode}\n      >\n        {t(\"buttons.exitZenMode\")}\n      </button>\n      {appState.scrolledOutside && (\n        <button\n          className=\"scroll-back-to-content\"\n          onClick={() => {\n            setAppState({\n              ...calculateScrollCenter(elements, appState, canvas),\n            });\n          }}\n        >\n          {t(\"buttons.scrollBackToContent\")}\n        </button>\n      )}\n    </footer>\n  );\n\n  const dialogs = (\n    <>\n      {appState.isLoading && <LoadingMessage />}\n      {appState.errorMessage && (\n        <ErrorDialog\n          message={appState.errorMessage}\n          onClose={() => setAppState({ errorMessage: null })}\n        />\n      )}\n      {appState.showHelpDialog && (\n        <HelpDialog onClose={() => setAppState({ showHelpDialog: false })} />\n      )}\n      {appState.pasteDialog.shown && (\n        <PasteChartDialog\n          setAppState={setAppState}\n          appState={appState}\n          onInsertChart={onInsertElements}\n          onClose={() =>\n            setAppState({\n              pasteDialog: { shown: false, data: null },\n            })\n          }\n        />\n      )}\n    </>\n  );\n\n  return isMobile ? (\n    <>\n      {dialogs}\n      <MobileMenu\n        appState={appState}\n        elements={elements}\n        actionManager={actionManager}\n        libraryMenu={libraryMenu}\n        exportButton={renderExportDialog()}\n        setAppState={setAppState}\n        onCollabButtonClick={onCollabButtonClick}\n        onLockToggle={onLockToggle}\n        canvas={canvas}\n        isCollaborating={isCollaborating}\n        renderCustomFooter={renderCustomFooter}\n        viewModeEnabled={viewModeEnabled}\n      />\n    </>\n  ) : (\n    <div\n      className={clsx(\"layer-ui__wrapper\", {\n        \"disable-pointerEvents\":\n          appState.draggingElement ||\n          appState.resizingElement ||\n          (appState.editingElement && !isTextElement(appState.editingElement)),\n      })}\n    >\n      {dialogs}\n      {renderFixedSideContainer()}\n      {renderBottomAppMenu()}\n      {renderGitHubCorner()}\n      {renderFooter()}\n    </div>\n  );\n};\n\nconst areEqual = (prev: LayerUIProps, next: LayerUIProps) => {\n  const getNecessaryObj = (appState: AppState): Partial<AppState> => {\n    const {\n      suggestedBindings,\n      startBoundElement: boundElement,\n      ...ret\n    } = appState;\n    return ret;\n  };\n  const prevAppState = getNecessaryObj(prev.appState);\n  const nextAppState = getNecessaryObj(next.appState);\n\n  const keys = Object.keys(prevAppState) as (keyof Partial<AppState>)[];\n  return (\n    prev.langCode === next.langCode &&\n    prev.elements === next.elements &&\n    keys.every((key) => prevAppState[key] === nextAppState[key])\n  );\n};\n\nexport default React.memo(LayerUI, areEqual);\n","import { ExcalidrawElement } from \"../../element/types\";\nimport { AppState } from \"../../types\";\nimport {\n  clearAppStateForLocalStorage,\n  getDefaultAppState,\n} from \"../../appState\";\nimport { clearElementsForLocalStorage } from \"../../element\";\nimport { STORAGE_KEYS as APP_STORAGE_KEYS } from \"../../constants\";\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_ELEMENTS: \"excalidraw\",\n  LOCAL_STORAGE_APP_STATE: \"excalidraw-state\",\n  LOCAL_STORAGE_COLLAB: \"excalidraw-collab\",\n  LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG: \"collabLinkForceLoadFlag\",\n};\n\nexport const saveUsernameToLocalStorage = (username: string) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_COLLAB,\n      JSON.stringify({ username }),\n    );\n  } catch (error) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\nexport const importUsernameFromLocalStorage = (): string | null => {\n  try {\n    const data = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_COLLAB);\n    if (data) {\n      return JSON.parse(data).username;\n    }\n  } catch (error) {\n    // Unable to access localStorage\n    console.error(error);\n  }\n\n  return null;\n};\n\nexport const saveToLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS,\n      JSON.stringify(clearElementsForLocalStorage(elements)),\n    );\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_APP_STATE,\n      JSON.stringify(clearAppStateForLocalStorage(appState)),\n    );\n  } catch (error) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\nexport const importFromLocalStorage = () => {\n  let savedElements = null;\n  let savedState = null;\n\n  try {\n    savedElements = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS);\n    savedState = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE);\n  } catch (error) {\n    // Unable to access localStorage\n    console.error(error);\n  }\n\n  let elements: ExcalidrawElement[] = [];\n  if (savedElements) {\n    try {\n      elements = clearElementsForLocalStorage(JSON.parse(savedElements));\n    } catch (error) {\n      console.error(error);\n      // Do nothing because elements array is already empty\n    }\n  }\n\n  let appState = null;\n  if (savedState) {\n    try {\n      appState = {\n        ...getDefaultAppState(),\n        ...clearAppStateForLocalStorage(\n          JSON.parse(savedState) as Partial<AppState>,\n        ),\n      };\n    } catch (error) {\n      console.error(error);\n      // Do nothing because appState is already null\n    }\n  }\n  return { elements, appState };\n};\n\nexport const getElementsStorageSize = () => {\n  try {\n    const elements = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS);\n    const elementsSize = elements ? JSON.stringify(elements).length : 0;\n    return elementsSize;\n  } catch (error) {\n    console.error(error);\n    return 0;\n  }\n};\n\nexport const getTotalStorageSize = () => {\n  try {\n    const appState = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE);\n    const collab = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_COLLAB);\n    const library = localStorage.getItem(\n      APP_STORAGE_KEYS.LOCAL_STORAGE_LIBRARY,\n    );\n\n    const appStateSize = appState ? JSON.stringify(appState).length : 0;\n    const collabSize = collab ? JSON.stringify(collab).length : 0;\n    const librarySize = library ? JSON.stringify(library).length : 0;\n\n    return appStateSize + collabSize + librarySize + getElementsStorageSize();\n  } catch (error) {\n    console.error(error);\n    return 0;\n  }\n};\n","import React, { useEffect, useState } from \"react\";\nimport { copyTextToSystemClipboard } from \"../clipboard\";\nimport { DEFAULT_VERSION } from \"../constants\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport {\n  getElementsStorageSize,\n  getTotalStorageSize,\n} from \"../excalidraw-app/data/localStorage\";\nimport { t } from \"../i18n\";\nimport useIsMobile from \"../is-mobile\";\nimport { getTargetElements } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { debounce, getVersion, nFormatter } from \"../utils\";\nimport { close } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./Stats.scss\";\n\ntype StorageSizes = { scene: number; total: number };\n\nconst getStorageSizes = debounce((cb: (sizes: StorageSizes) => void) => {\n  cb({\n    scene: getElementsStorageSize(),\n    total: getTotalStorageSize(),\n  });\n}, 500);\n\nexport const Stats = (props: {\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onClose: () => void;\n}) => {\n  const isMobile = useIsMobile();\n  const [storageSizes, setStorageSizes] = useState<StorageSizes>({\n    scene: 0,\n    total: 0,\n  });\n\n  useEffect(() => {\n    getStorageSizes((sizes) => {\n      setStorageSizes(sizes);\n    });\n  });\n\n  useEffect(() => () => getStorageSizes.cancel(), []);\n\n  const boundingBox = getCommonBounds(props.elements);\n  const selectedElements = getTargetElements(props.elements, props.appState);\n  const selectedBoundingBox = getCommonBounds(selectedElements);\n\n  if (isMobile && props.appState.openMenu) {\n    return null;\n  }\n\n  const version = getVersion();\n  let hash;\n  let timestamp;\n\n  if (version !== DEFAULT_VERSION) {\n    timestamp = version.slice(0, 16).replace(\"T\", \" \");\n    hash = version.slice(21);\n  } else {\n    timestamp = t(\"stats.versionNotAvailable\");\n  }\n\n  return (\n    <div className=\"Stats\">\n      <Island padding={2}>\n        <div className=\"close\" onClick={props.onClose}>\n          {close}\n        </div>\n        <h3>{t(\"stats.title\")}</h3>\n        <table>\n          <tbody>\n            <tr>\n              <th colSpan={2}>{t(\"stats.scene\")}</th>\n            </tr>\n            <tr>\n              <td>{t(\"stats.elements\")}</td>\n              <td>{props.elements.length}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.width\")}</td>\n              <td>{Math.round(boundingBox[2]) - Math.round(boundingBox[0])}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.height\")}</td>\n              <td>{Math.round(boundingBox[3]) - Math.round(boundingBox[1])}</td>\n            </tr>\n            <tr>\n              <th colSpan={2}>{t(\"stats.storage\")}</th>\n            </tr>\n            <tr>\n              <td>{t(\"stats.scene\")}</td>\n              <td>{nFormatter(storageSizes.scene, 1)}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.total\")}</td>\n              <td>{nFormatter(storageSizes.total, 1)}</td>\n            </tr>\n            {selectedElements.length === 1 && (\n              <tr>\n                <th colSpan={2}>{t(\"stats.element\")}</th>\n              </tr>\n            )}\n\n            {selectedElements.length > 1 && (\n              <>\n                <tr>\n                  <th colSpan={2}>{t(\"stats.selected\")}</th>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.elements\")}</td>\n                  <td>{selectedElements.length}</td>\n                </tr>\n              </>\n            )}\n            {selectedElements.length > 0 && (\n              <>\n                <tr>\n                  <td>{\"x\"}</td>\n                  <td>\n                    {Math.round(\n                      selectedElements.length === 1\n                        ? selectedElements[0].x\n                        : selectedBoundingBox[0],\n                    )}\n                  </td>\n                </tr>\n                <tr>\n                  <td>{\"y\"}</td>\n                  <td>\n                    {Math.round(\n                      selectedElements.length === 1\n                        ? selectedElements[0].y\n                        : selectedBoundingBox[1],\n                    )}\n                  </td>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.width\")}</td>\n                  <td>\n                    {Math.round(\n                      selectedElements.length === 1\n                        ? selectedElements[0].width\n                        : selectedBoundingBox[2] - selectedBoundingBox[0],\n                    )}\n                  </td>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.height\")}</td>\n                  <td>\n                    {Math.round(\n                      selectedElements.length === 1\n                        ? selectedElements[0].height\n                        : selectedBoundingBox[3] - selectedBoundingBox[1],\n                    )}\n                  </td>\n                </tr>\n              </>\n            )}\n            {selectedElements.length === 1 && (\n              <tr>\n                <td>{t(\"stats.angle\")}</td>\n                <td>\n                  {`${Math.round(\n                    (selectedElements[0].angle * 180) / Math.PI,\n                  )}`}\n                </td>\n              </tr>\n            )}\n            <tr>\n              <th colSpan={2}>{t(\"stats.version\")}</th>\n            </tr>\n            <tr>\n              <td\n                colSpan={2}\n                style={{ textAlign: \"center\", cursor: \"pointer\" }}\n                onClick={async () => {\n                  try {\n                    await copyTextToSystemClipboard(getVersion());\n                    props.setAppState({\n                      toastMessage: t(\"toast.copyToClipboard\"),\n                    });\n                  } catch {}\n                }}\n                title={t(\"stats.versionCopy\")}\n              >\n                {timestamp}\n                <br />\n                {hash}\n              </td>\n            </tr>\n          </tbody>\n        </table>\n      </Island>\n    </div>\n  );\n};\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport { TOAST_TIMEOUT } from \"../constants\";\nimport \"./Toast.scss\";\n\nexport const Toast = ({\n  message,\n  clearToast,\n}: {\n  message: string;\n  clearToast: () => void;\n}) => {\n  const timerRef = useRef<number>(0);\n\n  const scheduleTimeout = useCallback(\n    () =>\n      (timerRef.current = window.setTimeout(() => clearToast(), TOAST_TIMEOUT)),\n    [clearToast],\n  );\n\n  useEffect(() => {\n    scheduleTimeout();\n    return () => clearTimeout(timerRef.current);\n  }, [scheduleTimeout, message]);\n\n  return (\n    <div\n      className=\"Toast\"\n      onMouseEnter={() => clearTimeout(timerRef?.current)}\n      onMouseLeave={scheduleTimeout}\n    >\n      <p className=\"Toast__message\">{message}</p>\n    </div>\n  );\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleViewMode = register({\n  name: \"viewMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"view\");\n    return {\n      appState: {\n        ...appState,\n        viewModeEnabled: !this.checked!(appState),\n        selectedElementIds: {},\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.viewModeEnabled,\n  contextItemLabel: \"labels.viewMode\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R,\n});\n","import { Point, simplify } from \"points-on-curve\";\nimport React from \"react\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport rough from \"roughjs/bin/rough\";\nimport clsx from \"clsx\";\n\nimport \"../actions\";\nimport {\n  actionAddToLibrary,\n  actionBringForward,\n  actionBringToFront,\n  actionCopy,\n  actionCopyAsPng,\n  actionCopyAsSvg,\n  actionCopyStyles,\n  actionCut,\n  actionDeleteSelected,\n  actionDuplicateSelection,\n  actionFinalize,\n  actionGroup,\n  actionPasteStyles,\n  actionSelectAll,\n  actionSendBackward,\n  actionSendToBack,\n  actionToggleGridMode,\n  actionToggleStats,\n  actionToggleZenMode,\n  actionUngroup,\n} from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { ActionResult } from \"../actions/types\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport {\n  copyToClipboard,\n  parseClipboard,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport {\n  APP_NAME,\n  CURSOR_TYPE,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  ENV,\n  EVENT,\n  GRID_SIZE,\n  LINE_CONFIRM_THRESHOLD,\n  MIME_TYPES,\n  POINTER_BUTTON,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  TOUCH_CTX_MENU_TIMEOUT,\n  ZOOM_STEP,\n} from \"../constants\";\nimport { loadFromBlob } from \"../data\";\nimport { isValidLibrary } from \"../data/json\";\nimport { Library } from \"../data/library\";\nimport { restore } from \"../data/restore\";\nimport {\n  dragNewElement,\n  dragSelectedElements,\n  duplicateElement,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getDragOffsetXY,\n  getElementWithTransformHandleType,\n  getNonDeletedElements,\n  getNormalizedDimensions,\n  getPerfectElementSize,\n  getResizeArrowDirection,\n  getResizeOffsetXY,\n  getTransformHandleTypeFromCoords,\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n  isInvisiblySmallElement,\n  isNonDeletedElement,\n  isTextElement,\n  newElement,\n  newLinearElement,\n  newTextElement,\n  textWysiwyg,\n  transformElements,\n  updateTextElement,\n} from \"../element\";\nimport {\n  bindOrUnbindSelectedElements,\n  fixBindingsAfterDeletion,\n  fixBindingsAfterDuplication,\n  getEligibleElementsForBinding,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  isLinearElementSimpleAndAlreadyBound,\n  maybeBindLinearElement,\n  shouldEnableBindingForPointerEvent,\n  unbindLinearElements,\n  updateBoundElements,\n} from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { deepCopyElement } from \"../element/newElement\";\nimport { MaybeTransformHandleType } from \"../element/transformHandles\";\nimport {\n  isBindingElement,\n  isBindingElementType,\n  isLinearElement,\n  isLinearElementType,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport {\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n} from \"../groups\";\nimport { createHistory, SceneHistory } from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport {\n  CODES,\n  getResizeCenterPointKey,\n  getResizeWithSidesSameLengthKey,\n  getRotateWithDiscreteAngleKey,\n  isArrowKey,\n  KEYS,\n} from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { renderScene } from \"../renderer\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport {\n  calculateScrollCenter,\n  getElementContainingPosition,\n  getElementsAtPosition,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  isOverScrollBars,\n  isSomeElementSelected,\n} from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { SceneState, ScrollBars } from \"../scene/types\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport {\n  AppState,\n  ExcalidrawProps,\n  Gesture,\n  GestureEvent,\n  SceneData,\n} from \"../types\";\nimport {\n  debounce,\n  distance,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  resetCursor,\n  ResolvablePromise,\n  resolvablePromise,\n  sceneCoordsToViewportCoords,\n  setCursorForShape,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  withBatchedUpdates,\n} from \"../utils\";\nimport { isMobile } from \"../is-mobile\";\nimport ContextMenu, { ContextMenuOption } from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Stats } from \"./Stats\";\nimport { Toast } from \"./Toast\";\nimport { actionToggleViewMode } from \"../actions/actionToggleViewMode\";\n\nconst { history } = createHistory();\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nexport type PointerDownState = Readonly<{\n  // The first position at which pointerDown happened\n  origin: Readonly<{ x: number; y: number }>;\n  // Same as \"origin\" but snapped to the grid, if grid is on\n  originInGrid: Readonly<{ x: number; y: number }>;\n  // Scrollbar checks\n  scrollbars: ReturnType<typeof isOverScrollBars>;\n  // The previous pointer position\n  lastCoords: { x: number; y: number };\n  // map of original elements data\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>;\n  resize: {\n    // Handle when resizing, might change during the pointer interaction\n    handleType: MaybeTransformHandleType;\n    // This is determined on the initial pointer down event\n    isResizing: boolean;\n    // This is determined on the initial pointer down event\n    offset: { x: number; y: number };\n    // This is determined on the initial pointer down event\n    arrowDirection: \"origin\" | \"end\";\n    // This is a center point of selected elements determined on the initial pointer down event (for rotation only)\n    center: { x: number; y: number };\n  };\n  hit: {\n    // The element the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    element: NonDeleted<ExcalidrawElement> | null;\n    // The elements the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    allHitElements: NonDeleted<ExcalidrawElement>[];\n    // This is determined on the initial pointer down event\n    wasAddedToSelection: boolean;\n    // Whether selected element(s) were duplicated, might change during the\n    // pointer interaction\n    hasBeenDuplicated: boolean;\n    hasHitCommonBoundingBoxOfSelectedElements: boolean;\n  };\n  drag: {\n    // Might change during the pointer interation\n    hasOccurred: boolean;\n    // Might change during the pointer interation\n    offset: { x: number; y: number } | null;\n  };\n  // We need to have these in the state so that we can unsubscribe them\n  eventListeners: {\n    // It's defined on the initial pointer down event\n    onMove: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onUp: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyDown: null | ((event: KeyboardEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyUp: null | ((event: KeyboardEvent) => void);\n  };\n}>;\n\nexport type ExcalidrawImperativeAPI = {\n  updateScene: InstanceType<typeof App>[\"updateScene\"];\n  resetScene: InstanceType<typeof App>[\"resetScene\"];\n  getSceneElementsIncludingDeleted: InstanceType<\n    typeof App\n  >[\"getSceneElementsIncludingDeleted\"];\n  history: {\n    clear: InstanceType<typeof App>[\"resetHistory\"];\n  };\n  setScrollToCenter: InstanceType<typeof App>[\"setScrollToCenter\"];\n  getSceneElements: InstanceType<typeof App>[\"getSceneElements\"];\n  getAppState: () => InstanceType<typeof App>[\"state\"];\n  readyPromise: ResolvablePromise<ExcalidrawImperativeAPI>;\n  ready: true;\n};\n\nclass App extends React.Component<ExcalidrawProps, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public static defaultProps: Partial<ExcalidrawProps> = {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n  private scene: Scene;\n  constructor(props: ExcalidrawProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n\n    const {\n      width = window.innerWidth,\n      height = window.innerHeight,\n      offsetLeft,\n      offsetTop,\n      excalidrawRef,\n      viewModeEnabled = false,\n      zenModeEnabled = false,\n      gridModeEnabled = false,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      isLoading: true,\n      width,\n      height,\n      ...this.getCanvasOffsets({ offsetLeft, offsetTop }),\n      viewModeEnabled,\n      zenModeEnabled,\n      gridSize: gridModeEnabled ? GRID_SIZE : null,\n    };\n    if (excalidrawRef) {\n      const readyPromise =\n        (\"current\" in excalidrawRef && excalidrawRef.current?.readyPromise) ||\n        resolvablePromise<ExcalidrawImperativeAPI>();\n\n      const api: ExcalidrawImperativeAPI = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        setScrollToCenter: this.setScrollToCenter,\n        getSceneElements: this.getSceneElements,\n        getAppState: () => this.state,\n      } as const;\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n    this.scene = new Scene();\n\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n      this,\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  private renderCanvas() {\n    const canvasScale = window.devicePixelRatio;\n    const {\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      viewModeEnabled,\n    } = this.state;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    if (viewModeEnabled) {\n      return (\n        <canvas\n          id=\"canvas\"\n          style={{\n            width: canvasDOMWidth,\n            height: canvasDOMHeight,\n            cursor: \"grabbing\",\n          }}\n          width={canvasWidth}\n          height={canvasHeight}\n          ref={this.handleCanvasRef}\n          onContextMenu={this.handleCanvasContextMenu}\n          onPointerMove={this.handleCanvasPointerMove}\n          onPointerUp={this.removePointer}\n          onPointerCancel={this.removePointer}\n          onTouchMove={this.handleTouchMove}\n          onPointerDown={this.handleCanvasPointerDown}\n        >\n          {t(\"labels.drawingCanvas\")}\n        </canvas>\n      );\n    }\n    return (\n      <canvas\n        id=\"canvas\"\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n        }}\n        width={canvasWidth}\n        height={canvasHeight}\n        ref={this.handleCanvasRef}\n        onContextMenu={this.handleCanvasContextMenu}\n        onPointerDown={this.handleCanvasPointerDown}\n        onDoubleClick={this.handleCanvasDoubleClick}\n        onPointerMove={this.handleCanvasPointerMove}\n        onPointerUp={this.removePointer}\n        onPointerCancel={this.removePointer}\n        onTouchMove={this.handleTouchMove}\n        onDrop={this.handleCanvasOnDrop}\n      >\n        {t(\"labels.drawingCanvas\")}\n      </canvas>\n    );\n  }\n\n  public render() {\n    const {\n      zenModeEnabled,\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      offsetTop,\n      offsetLeft,\n      viewModeEnabled,\n    } = this.state;\n\n    const { onCollabButtonClick, onExportToBackend, renderFooter } = this.props;\n\n    const DEFAULT_PASTE_X = canvasDOMWidth / 2;\n    const DEFAULT_PASTE_Y = canvasDOMHeight / 2;\n\n    return (\n      <div\n        className={clsx(\"excalidraw\", {\n          \"excalidraw--view-mode\": viewModeEnabled,\n        })}\n        ref={this.excalidrawContainerRef}\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n          top: offsetTop,\n          left: offsetLeft,\n        }}\n      >\n        <LayerUI\n          canvas={this.canvas}\n          appState={this.state}\n          setAppState={this.setAppState}\n          actionManager={this.actionManager}\n          elements={this.scene.getElements()}\n          onCollabButtonClick={onCollabButtonClick}\n          onLockToggle={this.toggleLock}\n          onInsertElements={(elements) =>\n            this.addElementsFromPasteOrLibrary(\n              elements,\n              DEFAULT_PASTE_X,\n              DEFAULT_PASTE_Y,\n            )\n          }\n          zenModeEnabled={zenModeEnabled}\n          toggleZenMode={this.toggleZenMode}\n          langCode={getLanguage().code}\n          isCollaborating={this.props.isCollaborating || false}\n          onExportToBackend={onExportToBackend}\n          renderCustomFooter={renderFooter}\n          viewModeEnabled={viewModeEnabled}\n          showExitZenModeBtn={\n            typeof this.props?.zenModeEnabled === \"undefined\" && zenModeEnabled\n          }\n        />\n        <div className=\"excalidraw-textEditorContainer\" />\n        {this.state.showStats && (\n          <Stats\n            appState={this.state}\n            setAppState={this.setAppState}\n            elements={this.scene.getElements()}\n            onClose={this.toggleStats}\n          />\n        )}\n        {this.state.toastMessage !== null && (\n          <Toast\n            message={this.state.toastMessage}\n            clearToast={this.clearToast}\n          />\n        )}\n        <main>{this.renderCanvas()}</main>\n      </div>\n    );\n  }\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getElements();\n  };\n\n  private syncActionResult = withBatchedUpdates(\n    (actionResult: ActionResult) => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement: AppState[\"editingElement\"] | null = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach((element) => {\n          if (\n            this.state.editingElement?.id === element.id &&\n            this.state.editingElement !== element &&\n            isNonDeletedElement(element)\n          ) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n      }\n\n      if (actionResult.appState || editingElement) {\n        if (actionResult.commitToHistory) {\n          history.resumeRecording();\n        }\n\n        let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;\n        let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;\n        let gridSize = actionResult?.appState?.gridSize || null;\n\n        if (typeof this.props.viewModeEnabled !== \"undefined\") {\n          viewModeEnabled = this.props.viewModeEnabled;\n        }\n\n        if (typeof this.props.zenModeEnabled !== \"undefined\") {\n          zenModeEnabled = this.props.zenModeEnabled;\n        }\n\n        if (typeof this.props.gridModeEnabled !== \"undefined\") {\n          gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;\n        }\n\n        this.setState(\n          (state) => ({\n            ...actionResult.appState,\n            editingElement:\n              editingElement || actionResult.appState?.editingElement || null,\n            width: state.width,\n            height: state.height,\n            offsetTop: state.offsetTop,\n            offsetLeft: state.offsetLeft,\n            viewModeEnabled,\n            zenModeEnabled,\n            gridSize,\n          }),\n          () => {\n            if (actionResult.syncHistory) {\n              history.setCurrentState(\n                this.state,\n                this.scene.getElementsIncludingDeleted(),\n              );\n            }\n          },\n        );\n      }\n    },\n  );\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventHandlerNonNull = (event) => {\n    event.preventDefault();\n  };\n\n  private onFontLoaded = () => {\n    this.scene.getElementsIncludingDeleted().forEach((element) => {\n      if (isTextElement(element)) {\n        invalidateShapeForElement(element);\n      }\n    });\n    this.onSceneUpdated();\n  };\n\n  private importLibraryFromUrl = async (url: string) => {\n    window.history.replaceState({}, APP_NAME, window.location.origin);\n    try {\n      const request = await fetch(url);\n      const blob = await request.blob();\n      const json = JSON.parse(await blob.text());\n      if (!isValidLibrary(json)) {\n        throw new Error();\n      }\n      if (\n        window.confirm(\n          t(\"alerts.confirmAddLibrary\", { numShapes: json.library.length }),\n        )\n      ) {\n        await Library.importLibrary(blob);\n        this.setState({\n          isLibraryOpen: true,\n        });\n      }\n    } catch (error) {\n      window.alert(t(\"alerts.errorLoadingLibrary\"));\n      console.error(error);\n    }\n  };\n\n  private resetHistory = () => {\n    history.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        appearance: this.state.appearance,\n      }));\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          blob.handle = fileHandle;\n          loadFromBlob(blob, this.state)\n            .then(({ elements, appState }) =>\n              this.syncActionResult({\n                elements,\n                appState: {\n                  ...(appState || this.state),\n                  isLoading: false,\n                },\n                commitToHistory: true,\n              }),\n            )\n            .catch((error) => {\n              this.setState({ isLoading: false, errorMessage: error.message });\n            });\n        },\n      );\n    }\n\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n\n    let initialData = null;\n    try {\n      initialData = (await this.props.initialData) || null;\n    } catch (error) {\n      console.error(error);\n    }\n\n    const scene = restore(initialData, null);\n\n    scene.appState = {\n      ...scene.appState,\n      ...calculateScrollCenter(\n        scene.elements,\n        {\n          ...scene.appState,\n          width: this.state.width,\n          height: this.state.height,\n          offsetTop: this.state.offsetTop,\n          offsetLeft: this.state.offsetLeft,\n        },\n        null,\n      ),\n      isLoading: false,\n    };\n\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      commitToHistory: true,\n    });\n\n    const addToLibraryUrl = new URLSearchParams(window.location.search).get(\n      \"addLibrary\",\n    );\n\n    if (addToLibraryUrl) {\n      await this.importLibraryFromUrl(addToLibraryUrl);\n    }\n  };\n\n  public async componentDidMount() {\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n    this.addEventListeners();\n\n    // optim to avoid extra render on init\n    if (\n      typeof this.props.offsetLeft === \"number\" &&\n      typeof this.props.offsetTop === \"number\"\n    ) {\n      this.initializeScene();\n    } else {\n      this.setState(this.getCanvasOffsets(this.props), () => {\n        this.initializeScene();\n      });\n    }\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private removeEventListeners() {\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    window.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.removeEventListener(EVENT.DROP, this.disableEvent, false);\n\n    document.removeEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n  }\n\n  private addEventListeners() {\n    this.removeEventListeners();\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, { passive: true });\n    document.addEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n    );\n    // rerender text elements on font load to fix #637 && #1553\n    document.fonts?.addEventListener?.(\"loadingdone\", this.onFontLoaded);\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    window.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.addEventListener(EVENT.DROP, this.disableEvent, false);\n  }\n\n  componentDidUpdate(prevProps: ExcalidrawProps, prevState: AppState) {\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      (typeof this.props.offsetLeft === \"number\" &&\n        prevProps.offsetLeft !== this.props.offsetLeft) ||\n      (typeof this.props.offsetTop === \"number\" &&\n        prevProps.offsetTop !== this.props.offsetTop)\n    ) {\n      this.setState({\n        width: this.props.width ?? window.innerWidth,\n        height: this.props.height ?? window.innerHeight,\n        ...this.getCanvasOffsets(this.props),\n      });\n    }\n\n    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {\n      this.setState(\n        { viewModeEnabled: !!this.props.viewModeEnabled },\n        this.addEventListeners,\n      );\n    }\n\n    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {\n      this.addEventListeners();\n    }\n\n    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {\n      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });\n    }\n\n    if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {\n      this.setState({\n        gridSize: this.props.gridModeEnabled ? GRID_SIZE : null,\n      });\n    }\n    document\n      .querySelector(\".excalidraw\")\n      ?.classList.toggle(\"Appearance_dark\", this.state.appearance === \"dark\");\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    }\n    const { multiElement } = prevState;\n    if (\n      prevState.elementType !== this.state.elementType &&\n      multiElement != null &&\n      isBindingEnabled(this.state) &&\n      isBindingElement(multiElement)\n    ) {\n      maybeBindLinearElement(\n        multiElement,\n        this.state,\n        this.scene,\n        tupleToCoors(\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            multiElement,\n            -1,\n          ),\n        ),\n      );\n    }\n\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: SceneState[\"remotePointerViewportCoords\"] = {};\n    const remoteSelectedElementIds: SceneState[\"remoteSelectedElementIds\"] = {};\n    const pointerUsernames: { [id: string]: string } = {};\n    const pointerUserStates: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n      if (user.userState) {\n        pointerUserStates[socketId] = user.userState;\n      }\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n      );\n      cursorButton[socketId] = user.button;\n    });\n    const elements = this.scene.getElements();\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      elements.filter((element) => {\n        // don't render text element that's being currently edited (it's\n        // rendered on remote only)\n        return (\n          !this.state.editingElement ||\n          this.state.editingElement.type !== \"text\" ||\n          element.id !== this.state.editingElement.id\n        );\n      }),\n      this.state,\n      this.state.selectionElement,\n      window.devicePixelRatio,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n        remotePointerButton: cursorButton,\n        remoteSelectedElementIds,\n        remotePointerUsernames: pointerUsernames,\n        remotePointerUserStates: pointerUserStates,\n        shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n      },\n      {\n        renderOptimizations: true,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside =\n      // hide when editing text\n      this.state.editingElement?.type === \"text\"\n        ? false\n        : !atLeastOneVisibleElement && elements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside });\n    }\n\n    history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(\n        this.scene.getElementsIncludingDeleted(),\n        this.state,\n      );\n    }\n  }\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.cutAll();\n    event.preventDefault();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n  });\n\n  private cutAll = () => {\n    this.copyAll();\n    this.actionManager.executeAction(actionDeleteSelected);\n  };\n\n  private copyAll = () => {\n    copyToClipboard(this.scene.getElements(), this.state);\n  };\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTapStart = (event: TouchEvent) => {\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    event.preventDefault();\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: {},\n      });\n    }\n  };\n\n  private onTapEnd = (event: TouchEvent) => {\n    event.preventDefault();\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: this.state.previousSelectedElementIds,\n      });\n    }\n  };\n\n  private pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      // #686\n      const target = document.activeElement;\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n      if (\n        // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n        // thus these checks don't make sense\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n      const data = await parseClipboard(event);\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        this.addElementsFromPasteOrLibrary(data.elements);\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPasteOrLibrary = (\n    clipboardElements: readonly ExcalidrawElement[],\n    clientX = cursorX,\n    clientY = cursorY,\n  ) => {\n    const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n    const groupIdMap = new Map();\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n\n    const oldIdToDuplicatedId = new Map();\n    const newElements = clipboardElements.map((element) => {\n      const newElement = duplicateElement(\n        this.state.editingGroupId,\n        groupIdMap,\n        element,\n        {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        },\n      );\n      oldIdToDuplicatedId.set(element.id, newElement.id);\n      return newElement;\n    });\n    const nextElements = [\n      ...this.scene.getElementsIncludingDeleted(),\n      ...newElements,\n    ];\n    fixBindingsAfterDuplication(\n      nextElements,\n      clipboardElements,\n      oldIdToDuplicatedId,\n    );\n\n    this.scene.replaceAllElements(nextElements);\n    history.resumeRecording();\n    this.setState(\n      selectGroupsForSelectedElements(\n        {\n          ...this.state,\n          isLibraryOpen: false,\n          selectedElementIds: newElements.reduce((map, element) => {\n            map[element.id] = true;\n            return map;\n          }, {} as any),\n          selectedGroupIds: {},\n        },\n        this.scene.getElements(),\n      ),\n    );\n  };\n\n  private addTextFromPaste(text: any) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n    );\n\n    const element = newTextElement({\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    });\n\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({ selectedElementIds: { [element.id]: true } });\n    history.resumeRecording();\n  }\n\n  // Collaboration\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement>) => {\n    // remove touch handler for context menu on touch devices\n    if (event.pointerType === \"touch\" && touchTimeout) {\n      clearTimeout(touchTimeout);\n      touchTimeout = 0;\n      invalidateContextMenu = false;\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = () => {\n    this.setState((prevState) => {\n      return {\n        elementLocked: !prevState.elementLocked,\n        elementType: prevState.elementLocked\n          ? \"selection\"\n          : prevState.elementType,\n      };\n    });\n  };\n\n  toggleZenMode = () => {\n    this.actionManager.executeAction(actionToggleZenMode);\n  };\n\n  toggleStats = () => {\n    if (!this.state.showStats) {\n      trackEvent(\"dialog\", \"stats\");\n    }\n    this.actionManager.executeAction(actionToggleStats);\n  };\n\n  setScrollToCenter = (remoteElements: readonly ExcalidrawElement[]) => {\n    this.setState({\n      ...calculateScrollCenter(\n        getNonDeletedElements(remoteElements),\n        this.state,\n        this.canvas,\n      ),\n    });\n  };\n\n  clearToast = () => {\n    this.setState({ toastMessage: null });\n  };\n\n  public updateScene = withBatchedUpdates((sceneData: SceneData) => {\n    if (sceneData.commitToHistory) {\n      history.resumeRecording();\n    }\n\n    // currently we only support syncing background color\n    if (sceneData.appState?.viewBackgroundColor) {\n      this.setState({\n        viewBackgroundColor: sceneData.appState.viewBackgroundColor,\n      });\n    }\n\n    if (sceneData.elements) {\n      this.scene.replaceAllElements(sceneData.elements);\n    }\n\n    if (sceneData.collaborators) {\n      this.setState({ collaborators: sceneData.collaborators });\n    }\n  });\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      cursorX = event.x;\n      cursorY = event.y;\n    },\n  );\n\n  // Input handling\n\n  private onKeyDown = withBatchedUpdates((event: KeyboardEvent) => {\n    // normalize `event.key` when CapsLock is pressed #2372\n    if (\n      \"Proxy\" in window &&\n      ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n        (event.shiftKey && /^[a-z]$/.test(event.key)))\n    ) {\n      event = new Proxy(event, {\n        get(ev: any, prop) {\n          const value = ev[prop];\n          if (typeof value === \"function\") {\n            // fix for Proxies hijacking `this`\n            return value.bind(ev);\n          }\n          return prop === \"key\"\n            ? // CapsLock inverts capitalization based on ShiftKey, so invert\n              // it back\n              event.shiftKey\n              ? ev.key.toUpperCase()\n              : ev.key.toLowerCase()\n            : value;\n        },\n      });\n    }\n\n    if (\n      (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n      // case: using arrows to move between buttons\n      (isArrowKey(event.key) && isInputLike(event.target))\n    ) {\n      return;\n    }\n\n    if (event.key === KEYS.QUESTION_MARK) {\n      this.setState({\n        showHelpDialog: true,\n      });\n    }\n\n    if (this.actionManager.handleKeyDown(event)) {\n      return;\n    }\n\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n\n    if (event[KEYS.CTRL_OR_CMD]) {\n      this.setState({ isBindingEnabled: false });\n    }\n\n    if (event.code === CODES.NINE) {\n      this.setState({ isLibraryOpen: !this.state.isLibraryOpen });\n    }\n\n    if (isArrowKey(event.key)) {\n      const step =\n        (this.state.gridSize &&\n          (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.state.gridSize)) ||\n        (event.shiftKey\n          ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n          : ELEMENT_TRANSLATE_AMOUNT);\n\n      const selectedElements = this.scene\n        .getElements()\n        .filter((element) => this.state.selectedElementIds[element.id]);\n\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (event.key === KEYS.ARROW_LEFT) {\n        offsetX = -step;\n      } else if (event.key === KEYS.ARROW_RIGHT) {\n        offsetX = step;\n      } else if (event.key === KEYS.ARROW_UP) {\n        offsetY = -step;\n      } else if (event.key === KEYS.ARROW_DOWN) {\n        offsetY = step;\n      }\n\n      selectedElements.forEach((element) => {\n        mutateElement(element, {\n          x: element.x + offsetX,\n          y: element.y + offsetY,\n        });\n\n        updateBoundElements(element, {\n          simultaneouslyUpdated: selectedElements,\n        });\n      });\n\n      this.maybeSuggestBindingForAll(selectedElements);\n\n      event.preventDefault();\n    } else if (event.key === KEYS.ENTER) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n\n      if (\n        selectedElements.length === 1 &&\n        isLinearElement(selectedElements[0])\n      ) {\n        if (\n          !this.state.editingLinearElement ||\n          this.state.editingLinearElement.elementId !== selectedElements[0].id\n        ) {\n          history.resumeRecording();\n          this.setState({\n            editingLinearElement: new LinearElementEditor(\n              selectedElements[0],\n              this.scene,\n            ),\n          });\n        }\n      } else if (\n        selectedElements.length === 1 &&\n        !isLinearElement(selectedElements[0])\n      ) {\n        const selectedElement = selectedElements[0];\n        this.startTextEditing({\n          sceneX: selectedElement.x + selectedElement.width / 2,\n          sceneY: selectedElement.y + selectedElement.height / 2,\n        });\n        event.preventDefault();\n        return;\n      }\n    } else if (\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.metaKey &&\n      this.state.draggingElement === null\n    ) {\n      const shape = findShapeByKey(event.key);\n      if (shape) {\n        this.selectShapeTool(shape);\n      } else if (event.key === KEYS.Q) {\n        this.toggleLock();\n      }\n    }\n    if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n      isHoldingSpace = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    }\n  });\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.elementType === \"selection\") {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n      isBindingEnabled(this.state)\n        ? bindOrUnbindSelectedElements(selectedElements)\n        : unbindLinearElements(selectedElements);\n      this.setState({ suggestedBindings: [] });\n    }\n  });\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n    if (!isLinearElementType(elementType)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      selectedElementIds: {},\n    });\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location on the touchMove handler already.\n    // On Macbook, we don't have those events so will zoom in at the\n    // current location instead.\n    if (gesture.pointers.size === 2) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * event.scale),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          { x: cursorX, y: cursorY },\n        ),\n      }));\n    }\n  });\n\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      previousSelectedElementIds: {},\n      selectedElementIds: this.state.previousSelectedElementIds,\n    });\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const updateElement = (text: string, isDeleted = false) => {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return updateTextElement(_element, {\n              text,\n              isDeleted,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      appState: this.state,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [viewportX, viewportY];\n      },\n      onChange: withBatchedUpdates((text) => {\n        updateElement(text);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates((text) => {\n        const isDeleted = !text.trim();\n        updateElement(text, isDeleted);\n        if (!isDeleted) {\n          this.setState((prevState) => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [element.id]: true,\n            },\n          }));\n        } else {\n          fixBindingsAfterDeletion(this.scene.getElements(), [element]);\n        }\n        if (!isDeleted || isExistingElement) {\n          history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n        if (this.state.elementLocked) {\n          setCursorForShape(this.state.elementType);\n        }\n      }),\n      element,\n    });\n    // deselect all other elements when inserting text\n    this.setState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      editingGroupId: null,\n    });\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text);\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y);\n\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  private getElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement> | null {\n    const allHitElements = this.getElementsAtPosition(x, y);\n    if (allHitElements.length > 1) {\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(\n        elementWithHighestZIndex,\n        this.state,\n        x,\n        y,\n      )\n        ? allHitElements[allHitElements.length - 2]\n        : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement>[] {\n    return getElementsAtPosition(this.scene.getElements(), (element) =>\n      hitTest(element, this.state, x, y),\n    );\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n  }) => {\n    const existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n\n    const parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n    const element = existingTextElement\n      ? existingTextElement\n      : newTextElement({\n          x: parentCenterPosition\n            ? parentCenterPosition.elementCenterX\n            : sceneX,\n          y: parentCenterPosition\n            ? parentCenterPosition.elementCenterY\n            : sceneY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          strokeSharpness: this.state.currentItemStrokeSharpness,\n          text: \"\",\n          fontSize: this.state.currentItemFontSize,\n          fontFamily: this.state.currentItemFontFamily,\n          textAlign: parentCenterPosition\n            ? \"center\"\n            : this.state.currentItemTextAlign,\n          verticalAlign: parentCenterPosition\n            ? \"middle\"\n            : DEFAULT_VERTICAL_ALIGN,\n        });\n\n    this.setState({ editingElement: element });\n\n    if (existingTextElement) {\n      // if text element is no longer centered to a container, reset\n      // verticalAlign to default because it's currently internal-only\n      if (!parentCenterPosition || element.textAlign !== \"center\") {\n        mutateElement(element, { verticalAlign: DEFAULT_VERTICAL_ALIGN });\n      }\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n\n      // case: creating new text not centered to parent elemenent  offset Y\n      // so that the text is centered to cursor position\n      if (!parentCenterPosition) {\n        mutateElement(element, {\n          y: element.y - element.baseline / 2,\n        });\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      isExistingElement: !!existingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.elementType !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      if (\n        !this.state.editingLinearElement ||\n        this.state.editingLinearElement.elementId !== selectedElements[0].id\n      ) {\n        history.resumeRecording();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedElements[0],\n            this.scene,\n          ),\n        });\n      }\n      return;\n    }\n\n    resetCursor();\n\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n              selectedGroupIds: {},\n            },\n            this.scene.getElements(),\n          ),\n        );\n        return;\n      }\n    }\n\n    resetCursor();\n\n    if (!event[KEYS.CTRL_OR_CMD]) {\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n      });\n    }\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance;\n\n      this.setState(({ zoom, scrollX, scrollY, offsetLeft, offsetTop }) => ({\n        scrollX: scrollX + deltaX / zoom.value,\n        scrollY: scrollY + deltaY / zoom.value,\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * scaleFactor),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          center,\n        ),\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX - this.state.offsetLeft,\n      event.clientY - this.state.offsetTop,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this.state.editingLinearElement,\n        this.state.gridSize,\n      );\n      if (editingLinearElement !== this.state.editingLinearElement) {\n        this.setState({ editingLinearElement });\n      }\n      if (editingLinearElement.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      } else {\n        this.setState({ suggestedBindings: [] });\n      }\n    }\n\n    if (isBindingElementType(this.state.elementType)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { draggingElement } = this.state;\n      if (isBindingElement(draggingElement)) {\n        this.maybeSuggestBindingForLinearElementAtCursor(\n          draggingElement,\n          \"end\",\n          scenePointer,\n          this.state.startBoundElement,\n        );\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.state.elementType);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          distance2d(\n            scenePointerX - rx,\n            scenePointerY - ry,\n            lastPoint[0],\n            lastPoint[1],\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [scenePointerX - rx, scenePointerY - ry]],\n          });\n        } else {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        distance2d(\n          scenePointerX - rx,\n          scenePointerY - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        mutateElement(multiElement, {\n          points: points.slice(0, -1),\n        });\n      } else {\n        if (isPathALoop(points)) {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        }\n        // update last uncommitted point\n        mutateElement(multiElement, {\n          points: [\n            ...points.slice(0, -1),\n            [scenePointerX - rx, scenePointerY - ry],\n          ],\n        });\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.elementType !== \"selection\" &&\n        this.state.elementType !== \"text\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      const elementWithTransformHandleType = getElementWithTransformHandleType(\n        elements,\n        this.state,\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (\n        elementWithTransformHandleType &&\n        elementWithTransformHandleType.transformHandleType\n      ) {\n        document.documentElement.style.cursor = getCursorForResizingElement(\n          elementWithTransformHandleType,\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (transformHandleType) {\n        document.documentElement.style.cursor = getCursorForResizingElement({\n          transformHandleType,\n        });\n        return;\n      }\n    }\n\n    const hitElement = this.getElementAtPosition(\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (this.state.elementType === \"text\") {\n      document.documentElement.style.cursor = isTextElement(hitElement)\n        ? CURSOR_TYPE.TEXT\n        : CURSOR_TYPE.CROSSHAIR;\n    } else if (isOverScrollBar) {\n      document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n    } else if (\n      hitElement ||\n      this.isHittingCommonBoundingBoxOfSelectedElements(\n        scenePointer,\n        selectedElements,\n      )\n    ) {\n      document.documentElement.style.cursor = CURSOR_TYPE.MOVE;\n    } else {\n      document.documentElement.style.cursor = CURSOR_TYPE.AUTO;\n    }\n  };\n\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.persist();\n\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n    this.maybeCleanupAfterMissingPointerUp(event);\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // fixes pointermove causing selection of UI texts #32\n    event.preventDefault();\n    // Preventing the event above disables default behavior\n    // of defocusing potentially focused element, which is what we\n    // want when clicking inside the canvas.\n    if (document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur();\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    if (this.state.elementType === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"draw\" ||\n      this.state.elementType === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else {\n      this.createGenericElementOnPointerDown(\n        this.state.elementType,\n        pointerDownState,\n      );\n    }\n\n    const onPointerMove = this.onPointerMoveFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onPointerUp = this.onPointerUpFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    lastPointerUp = onPointerUp;\n\n    if (!this.state.viewModeEnabled) {\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n      window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n      window.addEventListener(EVENT.KEYUP, onKeyUp);\n      pointerDownState.eventListeners.onMove = onPointerMove;\n      pointerDownState.eventListeners.onUp = onPointerUp;\n      pointerDownState.eventListeners.onKeyUp = onKeyUp;\n      pointerDownState.eventListeners.onKeyDown = onKeyDown;\n    }\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.openContextMenu({\n              clientX: event.clientX,\n              clientY: event.clientY,\n            });\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private maybeCleanupAfterMissingPointerUp(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n\n  // Returns whether the event is a panning\n  private handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size === 0 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace) ||\n          this.state.viewModeEnabled)\n      )\n    ) {\n      return false;\n    }\n    isPanning = true;\n\n    let nextPastePrevented = false;\n    const isLinux = /Linux/.test(window.navigator.platform);\n\n    document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - rigth click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.setState({\n        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,\n        scrollY: this.state.scrollY - deltaY / this.state.zoom.value,\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          setCursorForShape(this.state.elementType);\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n\n    return {\n      origin,\n      originInGrid: tupleToCoors(\n        getGridPoint(origin.x, origin.y, this.state.gridSize),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX - this.state.offsetLeft,\n        event.clientY - this.state.offsetTop,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene.getElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(\n          origin,\n          selectedElements,\n        ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.state.elementType);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (this.state.elementType !== \"selection\") {\n      this.setState({\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.elementType === \"selection\") {\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType = getElementWithTransformHandleType(\n          elements,\n          this.state,\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n        if (elementWithTransformHandleType != null) {\n          this.setState({\n            resizingElement: elementWithTransformHandleType.element,\n          });\n          pointerDownState.resize.handleType =\n            elementWithTransformHandleType.transformHandleType;\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        document.documentElement.style.cursor = getCursorForResizingElement({\n          transformHandleType: pointerDownState.resize.handleType,\n        });\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.editingLinearElement) {\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this.state,\n            (appState) => this.setState(appState),\n            history,\n            pointerDownState.origin,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n\n        // hitElement may already be set above, so check first\n        pointerDownState.hit.element =\n          pointerDownState.hit.element ??\n          this.getElementAtPosition(\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          );\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        );\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(\n          (element) => this.isASelectedElement(element),\n        );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        // If we click on something\n        if (hitElement != null) {\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: {},\n                selectedGroupIds: {},\n                editingGroupId: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement.id]: true,\n                    },\n                  },\n                  this.scene.getElements(),\n                );\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.elementLocked)\n    if (this.state.editingElement?.type === \"text\") {\n      return;\n    }\n\n    this.startTextEditing({\n      sceneX: pointerDownState.origin.x,\n      sceneY: pointerDownState.origin.y,\n      insertAtParentCenter: !event.altKey,\n    });\n\n    resetCursor();\n    if (!this.state.elementLocked) {\n      this.setState({\n        elementType: \"selection\",\n      });\n    }\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (multiElement.type === \"line\" && isPathALoop(multiElement.points)) {\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone  finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        distance2d(\n          pointerDownState.origin.x - rx,\n          pointerDownState.origin.y - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [multiElement.id]: true,\n        },\n      }));\n      // clicking outside commit zone  update reference for last committed\n      // point\n      mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        elementType === \"draw\" ? null : this.state.gridSize,\n      );\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element = newLinearElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n        startArrowhead,\n        endArrowhead,\n      });\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [element.id]: false,\n        },\n      }));\n      mutateElement(element, {\n        points: [...element.points, [0, 0]],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene,\n      );\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n    const element = newElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n    });\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        multiElement: null,\n        draggingElement: element,\n        editingElement: element,\n      });\n    }\n  };\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((event: PointerEvent) => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            getSelectedElements(this.scene.getElements(), this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        if (\n          distance2d(\n            pointerCoords.x,\n            pointerCoords.y,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.editingLinearElement) {\n        const didDrag = LinearElementEditor.handlePointDragging(\n          this.state,\n          (appState) => this.setState(appState),\n          pointerCoords.x,\n          pointerCoords.y,\n          (element, startOrEnd) => {\n            this.maybeSuggestBindingForLinearElementAtCursor(\n              element,\n              startOrEnd,\n              pointerCoords,\n            );\n          },\n        );\n\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n      if (\n        hasHitASelectedElement ||\n        pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n      ) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n        if (selectedElements.length > 0) {\n          const [dragX, dragY] = getGridPoint(\n            pointerCoords.x - pointerDownState.drag.offset.x,\n            pointerCoords.y - pointerDownState.drag.offset.y,\n            this.state.gridSize,\n          );\n\n          const [dragDistanceX, dragDistanceY] = [\n            Math.abs(pointerCoords.x - pointerDownState.origin.x),\n            Math.abs(pointerCoords.y - pointerDownState.origin.y),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n\n          dragSelectedElements(\n            pointerDownState,\n            selectedElements,\n            dragX,\n            dragY,\n            this.scene,\n            lockDirection,\n            dragDistanceX,\n            dragDistanceY,\n          );\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            for (const element of this.scene.getElementsIncludingDeleted()) {\n              if (\n                this.state.selectedElementIds[element.id] ||\n                // case: the state.selectedElementIds might not have been\n                // updated yet by the time this mousemove event is fired\n                (element.id === hitElement?.id &&\n                  pointerDownState.hit.wasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(\n                  this.state.editingGroupId,\n                  groupIdMap,\n                  element,\n                );\n                const [originDragX, originDragY] = getGridPoint(\n                  pointerDownState.origin.x - pointerDownState.drag.offset.x,\n                  pointerDownState.origin.y - pointerDownState.drag.offset.y,\n                  this.state.gridSize,\n                );\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            fixBindingsAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n              \"duplicatesServeAsOld\",\n            );\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        const points = draggingElement.points;\n        let dx: number;\n        let dy: number;\n        if (draggingElement.type === \"draw\") {\n          dx = pointerCoords.x - draggingElement.x;\n          dy = pointerCoords.y - draggingElement.y;\n        } else {\n          dx = gridX - draggingElement.x;\n          dy = gridY - draggingElement.y;\n        }\n\n        if (getRotateWithDiscreteAngleKey(event) && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, { points: [...points, [dx, dy]] });\n        } else if (points.length > 1) {\n          if (draggingElement.type === \"draw\") {\n            mutateElement(draggingElement, {\n              points: simplify(\n                [...(points as Point[]), [dx, dy]],\n                0.7 / this.state.zoom.value,\n              ),\n            });\n          } else {\n            mutateElement(draggingElement, {\n              points: [...points.slice(0, -1), [dx, dy]],\n            });\n          }\n        }\n        if (isBindingElement(draggingElement)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingForLinearElementAtCursor(\n            draggingElement,\n            \"end\",\n            pointerCoords,\n            this.state.startBoundElement,\n          );\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          this.setState({\n            selectedElementIds: {},\n            selectedGroupIds: {},\n            editingGroupId: null,\n          });\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                ...elementsWithinSelection.reduce((map, element) => {\n                  map[element.id] = true;\n                  return map;\n                }, {} as any),\n              },\n            },\n            this.scene.getElements(),\n          ),\n        );\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.setState({\n        scrollX: this.state.scrollX - dx / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.setState({\n        scrollY: this.state.scrollY - dy / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n        isResizing,\n        isRotating,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement:\n          multiElement || isTextElement(this.state.editingElement)\n            ? this.state.editingElement\n            : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        const editingLinearElement = LinearElementEditor.handlePointerUp(\n          childEvent,\n          this.state.editingLinearElement,\n          this.state,\n        );\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement,\n            suggestedBindings: [],\n          });\n        }\n      }\n\n      lastPointerUp = null;\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      if (draggingElement?.type === \"draw\") {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (\n          !pointerDownState.drag.hasOccurred &&\n          draggingElement &&\n          !multiElement\n        ) {\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [\n                pointerCoords.x - draggingElement.x,\n                pointerCoords.y - draggingElement.y,\n              ],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(draggingElement)\n          ) {\n            maybeBindLinearElement(\n              draggingElement,\n              this.state,\n              this.scene,\n              pointerCoords,\n            );\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!elementLocked && elementType !== \"draw\") {\n            resetCursor();\n            this.setState((prevState) => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(\n          this.scene.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        mutateElement(\n          draggingElement,\n          getNormalizedDimensions(draggingElement),\n        );\n      }\n\n      if (resizingElement) {\n        history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(\n          this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection\n      ) {\n        if (childEvent.shiftKey) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              // We want to unselect all groups hitElement is part of\n              // as well as all elements that are part of the groups\n              // hitElement is part of\n              const idsOfSelectedElementsThatAreInGroups = hitElement.groupIds\n                .flatMap((groupId) =>\n                  getElementsInGroup(this.scene.getElements(), groupId),\n                )\n                .map((element) => ({ [element.id]: false }))\n                .reduce((prevId, acc) => ({ ...prevId, ...acc }), {});\n\n              this.setState((_prevState) => ({\n                selectedGroupIds: {\n                  ..._prevState.selectedElementIds,\n                  ...hitElement.groupIds\n                    .map((gId) => ({ [gId]: false }))\n                    .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                },\n                selectedElementIds: {\n                  ..._prevState.selectedElementIds,\n                  ...idsOfSelectedElementsThatAreInGroups,\n                },\n              }));\n            } else {\n              // remove element from selection while\n              // keeping prev elements selected\n              this.setState((prevState) => ({\n                selectedElementIds: {\n                  ...prevState.selectedElementIds,\n                  [hitElement!.id]: false,\n                },\n              }));\n            }\n          } else {\n            // add element to selection while\n            // keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: {\n                ..._prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: { [hitElement.id]: true },\n              },\n              this.scene.getElements(),\n            ),\n          }));\n        }\n      }\n\n      if (\n        !this.state.editingLinearElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !this.state.isResizing &&\n        ((hitElement &&\n          isHittingElementBoundingBoxWithoutHittingElement(\n            hitElement,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        // Deselect selected elements\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n\n        return;\n      }\n\n      if (!elementLocked && elementType !== \"draw\" && draggingElement) {\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(this.scene.getElements(), this.state)\n      ) {\n        history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state)\n          ? bindOrUnbindSelectedElements\n          : unbindLinearElements)(\n          getSelectedElements(this.scene.getElements(), this.state),\n        );\n      }\n\n      if (!elementLocked && elementType !== \"draw\") {\n        resetCursor();\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n        });\n      }\n    });\n  }\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (pointerCoords: {\n    x: number;\n    y: number;\n  }): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private maybeSuggestBindingForLinearElementAtCursor = (\n    linearElement: NonDeleted<ExcalidrawLinearElement>,\n    startOrEnd: \"start\" | \"end\",\n    pointerCoords: {\n      x: number;\n      y: number;\n    },\n    // During line creation the start binding hasn't been written yet\n    // into `linearElement`\n    oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n  ): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null &&\n        !isLinearElementSimpleAndAlreadyBound(\n          linearElement,\n          oppositeBindingBoundElement?.id,\n          hoveredBindableElement,\n        )\n          ? [hoveredBindableElement]\n          : [],\n    });\n  };\n\n  private maybeSuggestBindingForAll(\n    selectedElements: NonDeleted<ExcalidrawElement>[],\n  ): void {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({ suggestedBindings });\n  }\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n        hitElement != null &&\n        isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: {},\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    } else {\n      this.canvas?.removeEventListener(EVENT.WHEEL, this.handleWheel);\n      this.canvas?.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas?.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    }\n  };\n\n  private handleCanvasOnDrop = async (\n    event: React.DragEvent<HTMLCanvasElement>,\n  ) => {\n    try {\n      const file = event.dataTransfer.files[0];\n      if (file?.type === \"image/png\" || file?.type === \"image/svg+xml\") {\n        const { elements, appState } = await loadFromBlob(file, this.state);\n        this.syncActionResult({\n          elements,\n          appState: {\n            ...(appState || this.state),\n            isLoading: false,\n          },\n          commitToHistory: true,\n        });\n        return;\n      }\n    } catch (error) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryShapes = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryShapes !== \"\") {\n      this.addElementsFromPasteOrLibrary(\n        JSON.parse(libraryShapes),\n        event.clientX,\n        event.clientY,\n      );\n      return;\n    }\n\n    const file = event.dataTransfer?.files[0];\n    if (\n      file?.type === \"application/json\" ||\n      file?.name.endsWith(\".excalidraw\")\n    ) {\n      this.setState({ isLoading: true });\n      if (\n        \"chooseFileSystemEntries\" in window ||\n        \"showOpenFilePicker\" in window\n      ) {\n        try {\n          // This will only work as of Chrome 86,\n          // but can be safely ignored on older releases.\n          const item = event.dataTransfer.items[0];\n          // TODO: Make this part of `AppState`.\n          (file as any).handle = await (item as any).getAsFileSystemHandle();\n        } catch (error) {\n          console.warn(error.name, error.message);\n        }\n      }\n      loadFromBlob(file, this.state)\n        .then(({ elements, appState }) =>\n          this.syncActionResult({\n            elements,\n            appState: {\n              ...(appState || this.state),\n              isLoading: false,\n            },\n            commitToHistory: true,\n          }),\n        )\n        .catch((error) => {\n          this.setState({ isLoading: false, errorMessage: error.message });\n        });\n    } else if (\n      file?.type === MIME_TYPES.excalidrawlib ||\n      file?.name.endsWith(\".excalidrawlib\")\n    ) {\n      Library.importLibrary(file)\n        .then(() => {\n          this.setState({ isLibraryOpen: false });\n        })\n        .catch((error) =>\n          this.setState({ isLoading: false, errorMessage: error.message }),\n        );\n    } else {\n      this.setState({\n        isLoading: false,\n        errorMessage: t(\"alerts.couldNotLoadInvalidFile\"),\n      });\n    }\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n    this.openContextMenu(event);\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): void => {\n    const draggingElement = this.state.draggingElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (!draggingElement) {\n      return;\n    }\n    if (draggingElement.type === \"selection\") {\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        pointerCoords.x,\n        pointerCoords.y,\n        distance(pointerDownState.origin.x, pointerCoords.x),\n        distance(pointerDownState.origin.y, pointerCoords.y),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.originInGrid.x,\n        pointerDownState.originInGrid.y,\n        gridX,\n        gridY,\n        distance(pointerDownState.originInGrid.x, gridX),\n        distance(pointerDownState.originInGrid.y, gridY),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n      this.maybeSuggestBindingForAll([draggingElement]);\n    }\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const transformHandleType = pointerDownState.resize.handleType;\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    const [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      this.state.gridSize,\n    );\n    if (\n      transformElements(\n        pointerDownState,\n        transformHandleType,\n        selectedElements,\n        pointerDownState.resize.arrowDirection,\n        getRotateWithDiscreteAngleKey(event),\n        getResizeCenterPointKey(event),\n        getResizeWithSidesSameLengthKey(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      this.maybeSuggestBindingForAll(selectedElements);\n      return true;\n    }\n    return false;\n  };\n\n  private openContextMenu = ({\n    clientX,\n    clientY,\n  }: {\n    clientX: number;\n    clientY: number;\n  }) => {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const maybeGroupAction = actionGroup.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeUngroupAction = actionUngroup.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const separator = \"separator\";\n\n    const _isMobile = isMobile();\n\n    const elements = this.scene.getElements();\n    const element = this.getElementAtPosition(x, y);\n    const options: ContextMenuOption[] = [];\n    if (probablySupportsClipboardBlob && elements.length > 0) {\n      options.push(actionCopyAsPng);\n    }\n\n    if (probablySupportsClipboardWriteText && elements.length > 0) {\n      options.push(actionCopyAsSvg);\n    }\n    if (!element) {\n      const viewModeOptions: ContextMenuOption[] = [\n        ...options,\n        actionToggleStats,\n      ];\n\n      if (typeof this.props.viewModeEnabled === \"undefined\") {\n        viewModeOptions.push(actionToggleViewMode);\n      }\n\n      ContextMenu.push({\n        options: viewModeOptions,\n        top: clientY,\n        left: clientX,\n        actionManager: this.actionManager,\n        appState: this.state,\n      });\n\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n\n      ContextMenu.push({\n        options: [\n          _isMobile &&\n            navigator.clipboard && {\n              name: \"paste\",\n              perform: (elements, appStates) => {\n                this.pasteFromClipboard(null);\n                return {\n                  commitToHistory: false,\n                };\n              },\n              contextItemLabel: \"labels.paste\",\n            },\n          _isMobile && navigator.clipboard && separator,\n          probablySupportsClipboardBlob &&\n            elements.length > 0 &&\n            actionCopyAsPng,\n          probablySupportsClipboardWriteText &&\n            elements.length > 0 &&\n            actionCopyAsSvg,\n          ((probablySupportsClipboardBlob && elements.length > 0) ||\n            (probablySupportsClipboardWriteText && elements.length > 0)) &&\n            separator,\n          actionSelectAll,\n          separator,\n          typeof this.props.gridModeEnabled === \"undefined\" &&\n            actionToggleGridMode,\n          typeof this.props.zenModeEnabled === \"undefined\" &&\n            actionToggleZenMode,\n          typeof this.props.viewModeEnabled === \"undefined\" &&\n            actionToggleViewMode,\n          actionToggleStats,\n        ],\n        top: clientY,\n        left: clientX,\n        actionManager: this.actionManager,\n        appState: this.state,\n      });\n      return;\n    }\n\n    if (!this.state.selectedElementIds[element.id]) {\n      this.setState({ selectedElementIds: { [element.id]: true } });\n    }\n\n    if (this.state.viewModeEnabled) {\n      ContextMenu.push({\n        options: [navigator.clipboard && actionCopy, ...options],\n        top: clientY,\n        left: clientX,\n        actionManager: this.actionManager,\n        appState: this.state,\n      });\n      return;\n    }\n\n    ContextMenu.push({\n      options: [\n        _isMobile && actionCut,\n        _isMobile && navigator.clipboard && actionCopy,\n        _isMobile &&\n          navigator.clipboard && {\n            name: \"paste\",\n            perform: (elements, appStates) => {\n              this.pasteFromClipboard(null);\n              return {\n                commitToHistory: false,\n              };\n            },\n            contextItemLabel: \"labels.paste\",\n          },\n        _isMobile && separator,\n        ...options,\n        separator,\n        actionCopyStyles,\n        actionPasteStyles,\n        separator,\n        maybeGroupAction && actionGroup,\n        maybeUngroupAction && actionUngroup,\n        (maybeGroupAction || maybeUngroupAction) && separator,\n        actionAddToLibrary,\n        separator,\n        actionSendBackward,\n        actionBringForward,\n        actionSendToBack,\n        actionBringToFront,\n        separator,\n        actionDuplicateSelection,\n        actionDeleteSelected,\n      ],\n      top: clientY,\n      left: clientX,\n      actionManager: this.actionManager,\n      appState: this.state,\n    });\n  };\n\n  private handleWheel = withBatchedUpdates((event: WheelEvent) => {\n    event.preventDefault();\n\n    if (isPanning) {\n      return;\n    }\n\n    const { deltaX, deltaY } = event;\n    const { selectedElementIds, previousSelectedElementIds } = this.state;\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      if (Object.keys(previousSelectedElementIds).length !== 0) {\n        setTimeout(() => {\n          this.setState({\n            selectedElementIds: previousSelectedElementIds,\n            previousSelectedElementIds: {},\n          });\n        }, 1000);\n      }\n\n      let newZoom = this.state.zoom.value - delta / 100;\n      // increase zoom steps the more zoomed-in we are (applies to >100% only)\n      newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign;\n      // round to nearest step\n      newZoom = Math.round(newZoom * ZOOM_STEP * 100) / (ZOOM_STEP * 100);\n\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(newZoom),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          {\n            x: cursorX,\n            y: cursorY,\n          },\n        ),\n        selectedElementIds: {},\n        previousSelectedElementIds:\n          Object.keys(selectedElementIds).length !== 0\n            ? selectedElementIds\n            : previousSelectedElementIds,\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n      return;\n    }\n\n    // scroll horizontally when shift pressed\n    if (event.shiftKey) {\n      this.setState(({ zoom, scrollX }) => ({\n        // on Mac, shift+wheel tends to result in deltaX\n        scrollX: scrollX - (deltaY || deltaX) / zoom.value,\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: scrollX - deltaX / zoom.value,\n      scrollY: scrollY - deltaY / zoom.value,\n    }));\n  });\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n    scale: number,\n  ) {\n    const elementClickedInside = getElementContainingPosition(\n      this.scene\n        .getElementsIncludingDeleted()\n        .filter((element) => !isTextElement(element)),\n      x,\n      y,\n    );\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointer = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(pointer.x) || isNaN(pointer.y)) {\n      // sometimes the pointer goes off screen\n    }\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private getCanvasOffsets(offsets?: {\n    offsetLeft?: number;\n    offsetTop?: number;\n  }): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (\n      typeof offsets?.offsetLeft === \"number\" &&\n      typeof offsets?.offsetTop === \"number\"\n    ) {\n      return {\n        offsetLeft: offsets.offsetLeft,\n        offsetTop: offsets.offsetTop,\n      };\n    }\n    if (this.excalidrawContainerRef?.current?.parentElement) {\n      const parentElement = this.excalidrawContainerRef.current.parentElement;\n      const { left, top } = parentElement.getBoundingClientRect();\n      return {\n        offsetLeft:\n          typeof offsets?.offsetLeft === \"number\" ? offsets.offsetLeft : left,\n        offsetTop:\n          typeof offsets?.offsetTop === \"number\" ? offsets.offsetTop : top,\n      };\n    }\n    return {\n      offsetLeft:\n        typeof offsets?.offsetLeft === \"number\" ? offsets.offsetLeft : 0,\n      offsetTop: typeof offsets?.offsetTop === \"number\" ? offsets.offsetTop : 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      history: SceneHistory;\n      app: InstanceType<typeof App>;\n      library: typeof Library;\n      collab: InstanceType<\n        typeof import(\"../excalidraw-app/collab/CollabWrapper\").default\n      >;\n    };\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.h = window.h || ({} as Window[\"h\"]);\n\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        return this.app.scene.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return this.app.scene.replaceAllElements(elements);\n      },\n    },\n    history: {\n      configurable: true,\n      get: () => history,\n    },\n    library: {\n      configurable: true,\n      value: Library,\n    },\n  });\n}\nexport default App;\n","import React, { useEffect, forwardRef } from \"react\";\n\nimport { InitializeApp } from \"../../components/InitializeApp\";\nimport App from \"../../components/App\";\n\nimport \"../../css/app.scss\";\nimport \"../../css/styles.scss\";\n\nimport { ExcalidrawAPIRefValue, ExcalidrawProps } from \"../../types\";\nimport { IsMobileProvider } from \"../../is-mobile\";\nimport { defaultLang } from \"../../i18n\";\n\nconst Excalidraw = (props: ExcalidrawProps) => {\n  const {\n    width,\n    height,\n    offsetLeft,\n    offsetTop,\n    onChange,\n    initialData,\n    excalidrawRef,\n    onCollabButtonClick,\n    isCollaborating,\n    onPointerUpdate,\n    onExportToBackend,\n    renderFooter,\n    langCode = defaultLang.code,\n    viewModeEnabled,\n    zenModeEnabled,\n    gridModeEnabled,\n  } = props;\n\n  useEffect(() => {\n    // Block pinch-zooming on iOS outside of the content area\n    const handleTouchMove = (event: TouchEvent) => {\n      // @ts-ignore\n      if (typeof event.scale === \"number\" && event.scale !== 1) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"touchmove\", handleTouchMove, {\n      passive: false,\n    });\n\n    return () => {\n      document.removeEventListener(\"touchmove\", handleTouchMove);\n    };\n  }, []);\n\n  return (\n    <InitializeApp langCode={langCode}>\n      <IsMobileProvider>\n        <App\n          width={width}\n          height={height}\n          offsetLeft={offsetLeft}\n          offsetTop={offsetTop}\n          onChange={onChange}\n          initialData={initialData}\n          excalidrawRef={excalidrawRef}\n          onCollabButtonClick={onCollabButtonClick}\n          isCollaborating={isCollaborating}\n          onPointerUpdate={onPointerUpdate}\n          onExportToBackend={onExportToBackend}\n          renderFooter={renderFooter}\n          langCode={langCode}\n          viewModeEnabled={viewModeEnabled}\n          zenModeEnabled={zenModeEnabled}\n          gridModeEnabled={gridModeEnabled}\n        />\n      </IsMobileProvider>\n    </InitializeApp>\n  );\n};\n\ntype PublicExcalidrawProps = Omit<ExcalidrawProps, \"forwardedRef\">;\n\nconst areEqual = (\n  prevProps: PublicExcalidrawProps,\n  nextProps: PublicExcalidrawProps,\n) => {\n  const { initialData: prevInitialData, ...prev } = prevProps;\n  const { initialData: nextInitialData, ...next } = nextProps;\n\n  const prevKeys = Object.keys(prevProps) as (keyof typeof prev)[];\n  const nextKeys = Object.keys(nextProps) as (keyof typeof next)[];\n  return (\n    prevKeys.length === nextKeys.length &&\n    prevKeys.every((key) => prev[key] === next[key])\n  );\n};\n\nExcalidraw.defaultProps = {\n  lanCode: defaultLang.code,\n};\n\nconst forwardedRefComp = forwardRef<\n  ExcalidrawAPIRefValue,\n  PublicExcalidrawProps\n>((props, ref) => <Excalidraw {...props} excalidrawRef={ref} />);\nexport default React.memo(forwardedRefComp, areEqual);\nexport {\n  getSceneVersion,\n  getSyncableElements,\n  getElementMap,\n} from \"../../element\";\nexport { defaultLang, languages } from \"../../i18n\";\n","// time constants (ms)\nexport const SAVE_TO_LOCAL_STORAGE_TIMEOUT = 300;\nexport const INITIAL_SCENE_UPDATE_TIMEOUT = 5000;\nexport const SYNC_FULL_SCENE_INTERVAL_MS = 20000;\n\nexport const BROADCAST = {\n  SERVER_VOLATILE: \"server-volatile-broadcast\",\n  SERVER: \"server-broadcast\",\n};\n\nexport enum SCENE {\n  INIT = \"SCENE_INIT\",\n  UPDATE = \"SCENE_UPDATE\",\n}\n","import { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport { AppState } from \"../../types\";\nimport { UserIdleState } from \"../collab/types\";\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nconst generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketId: string;\n      pointer: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n  IDLE_STATUS: {\n    type: \"IDLE_STATUS\";\n    payload: {\n      socketId: string;\n      userState: UserIdleState;\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\nexport type SocketUpdateData = SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n  _brand: \"socketUpdateData\";\n};\n\nexport const createIV = () => {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  const hash = new URL(link).hash;\n  const match = hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n  return match ? { roomId: match[1], roomKey: match[2] } : null;\n};\n\nexport const generateCollaborationLinkData = async () => {\n  const roomId = await generateRandomID();\n  const roomKey = await generateEncryptionKey();\n\n  if (!roomKey) {\n    throw new Error(\"Couldn't generate room key\");\n  }\n\n  return { roomId, roomKey };\n};\n\nexport const getCollaborationLink = (data: {\n  roomId: string;\n  roomKey: string;\n}) => {\n  return `${window.location.origin}${window.location.pathname}#room=${data.roomId},${data.roomKey}`;\n};\n\nexport const getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv,\n        },\n        key,\n        buffer,\n      );\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply initialData even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  initialData: ImportedDataState | undefined | null,\n) => {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      initialData?.appState,\n    );\n  } else {\n    data = restore(initialData || null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n  const iv = new Uint8Array(12);\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encoded,\n  );\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n      window.prompt(`${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      window.alert(t(\"alerts.couldNotCreateShareableLinkTooBig\"));\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n","import { getImportedKey } from \"../data\";\nimport { createIV } from \"./index\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { getSceneVersion } from \"../../element\";\nimport Portal from \"../collab/Portal\";\nimport { restoreElements } from \"../../data/restore\";\n\nlet firebasePromise: Promise<\n  typeof import(\"firebase/app\").default\n> | null = null;\n\nconst loadFirebase = async () => {\n  const firebase = (\n    await import(/* webpackChunkName: \"firebase\" */ \"firebase/app\")\n  ).default;\n  await import(/* webpackChunkName: \"firestore\" */ \"firebase/firestore\");\n\n  const firebaseConfig = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n  firebase.initializeApp(firebaseConfig);\n\n  return firebase;\n};\n\nconst getFirebase = async (): Promise<\n  typeof import(\"firebase/app\").default\n> => {\n  if (!firebasePromise) {\n    firebasePromise = loadFirebase();\n  }\n  return await firebasePromise!;\n};\n\ninterface FirebaseStoredScene {\n  sceneVersion: number;\n  iv: firebase.default.firestore.Blob;\n  ciphertext: firebase.default.firestore.Blob;\n}\n\nconst encryptElements = async (\n  key: string,\n  elements: readonly ExcalidrawElement[],\n): Promise<{ ciphertext: ArrayBuffer; iv: Uint8Array }> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const ciphertext = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    encoded,\n  );\n\n  return { ciphertext, iv };\n};\n\nconst decryptElements = async (\n  key: string,\n  iv: Uint8Array,\n  ciphertext: ArrayBuffer,\n): Promise<readonly ExcalidrawElement[]> => {\n  const importedKey = await getImportedKey(key, \"decrypt\");\n  const decrypted = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    ciphertext,\n  );\n\n  const decodedData = new TextDecoder(\"utf-8\").decode(\n    new Uint8Array(decrypted) as any,\n  );\n  return JSON.parse(decodedData);\n};\n\nconst firebaseSceneVersionCache = new WeakMap<SocketIOClient.Socket, number>();\n\nexport const isSavedToFirebase = (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n): boolean => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n    return firebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  }\n  // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n  return true;\n};\n\nexport const saveToFirebase = async (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n) => {\n  const { roomId, roomKey, socket } = portal;\n  if (\n    // if no room exists, consider the room saved because there's nothing we can\n    // do at this point\n    !roomId ||\n    !roomKey ||\n    !socket ||\n    isSavedToFirebase(portal, elements)\n  ) {\n    return true;\n  }\n\n  const firebase = await getFirebase();\n  const sceneVersion = getSceneVersion(elements);\n  const { ciphertext, iv } = await encryptElements(roomKey, elements);\n\n  const nextDocData = {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(\n      new Uint8Array(ciphertext),\n    ),\n    iv: firebase.firestore.Blob.fromUint8Array(iv),\n  } as FirebaseStoredScene;\n\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const didUpdate = await db.runTransaction(async (transaction) => {\n    const doc = await transaction.get(docRef);\n    if (!doc.exists) {\n      transaction.set(docRef, nextDocData);\n      return true;\n    }\n\n    const prevDocData = doc.data() as FirebaseStoredScene;\n    if (prevDocData.sceneVersion >= nextDocData.sceneVersion) {\n      return false;\n    }\n\n    transaction.update(docRef, nextDocData);\n    return true;\n  });\n\n  if (didUpdate) {\n    firebaseSceneVersionCache.set(socket, sceneVersion);\n  }\n\n  return didUpdate;\n};\n\nexport const loadFromFirebase = async (\n  roomId: string,\n  roomKey: string,\n  socket: SocketIOClient.Socket | null,\n): Promise<readonly ExcalidrawElement[] | null> => {\n  const firebase = await getFirebase();\n  const db = firebase.firestore();\n\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n  if (!doc.exists) {\n    return null;\n  }\n  const storedScene = doc.data() as FirebaseStoredScene;\n  const ciphertext = storedScene.ciphertext.toUint8Array();\n  const iv = storedScene.iv.toUint8Array();\n\n  const elements = await decryptElements(roomKey, iv, ciphertext);\n\n  if (socket) {\n    firebaseSceneVersionCache.set(socket, getSceneVersion(elements));\n  }\n\n  return restoreElements(elements);\n};\n","import {\n  encryptAESGEM,\n  SocketUpdateData,\n  SocketUpdateDataSource,\n} from \"../data\";\n\nimport CollabWrapper from \"./CollabWrapper\";\n\nimport { getSyncableElements } from \"../../packages/excalidraw/index\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { BROADCAST, SCENE } from \"../app_constants\";\nimport { UserIdleState } from \"./types\";\n\nclass Portal {\n  collab: CollabWrapper;\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initialized\n  roomId: string | null = null;\n  roomKey: string | null = null;\n  broadcastedElementVersions: Map<string, number> = new Map();\n\n  constructor(collab: CollabWrapper) {\n    this.collab = collab;\n  }\n\n  open(socket: SocketIOClient.Socket, id: string, key: string) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key;\n\n    // Initialize socket listeners\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n      }\n    });\n    this.socket.on(\"new-user\", async (_socketId: string) => {\n      this.broadcastScene(\n        SCENE.INIT,\n        getSyncableElements(this.collab.getSceneElementsIncludingDeleted()),\n        /* syncAll */ true,\n      );\n    });\n    this.socket.on(\"room-user-change\", (clients: string[]) => {\n      this.collab.setCollaborators(clients);\n    });\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n\n  isOpen() {\n    return !!(\n      this.socketInitialized &&\n      this.socket &&\n      this.roomId &&\n      this.roomKey\n    );\n  }\n\n  async _broadcastSocketData(\n    data: SocketUpdateData,\n    volatile: boolean = false,\n  ) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey!);\n      this.socket!.emit(\n        volatile ? BROADCAST.SERVER_VOLATILE : BROADCAST.SERVER,\n        this.roomId,\n        encrypted.data,\n        encrypted.iv,\n      );\n    }\n  }\n\n  broadcastScene = async (\n    sceneType: SCENE.INIT | SCENE.UPDATE,\n    syncableElements: ExcalidrawElement[],\n    syncAll: boolean,\n  ) => {\n    if (sceneType === SCENE.INIT && !syncAll) {\n      throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n    }\n\n    if (!syncAll) {\n      // sync out only the elements we think we need to to save bandwidth.\n      // periodically we'll resync the whole thing to make sure no one diverges\n      // due to a dropped message (server goes down etc).\n      syncableElements = syncableElements.filter(\n        (syncableElement) =>\n          !this.broadcastedElementVersions.has(syncableElement.id) ||\n          syncableElement.version >\n            this.broadcastedElementVersions.get(syncableElement.id)!,\n      );\n    }\n\n    const data: SocketUpdateDataSource[typeof sceneType] = {\n      type: sceneType,\n      payload: {\n        elements: syncableElements,\n      },\n    };\n\n    for (const syncableElement of syncableElements) {\n      this.broadcastedElementVersions.set(\n        syncableElement.id,\n        syncableElement.version,\n      );\n    }\n\n    const broadcastPromise = this._broadcastSocketData(\n      data as SocketUpdateData,\n    );\n\n    if (syncAll && this.collab.isCollaborating) {\n      await Promise.all([\n        broadcastPromise,\n        this.collab.saveCollabRoomToFirebase(syncableElements),\n      ]);\n    } else {\n      await broadcastPromise;\n    }\n  };\n\n  broadcastIdleChange = (userState: UserIdleState) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"IDLE_STATUS\"] = {\n        type: \"IDLE_STATUS\",\n        payload: {\n          socketId: this.socket.id,\n          userState,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n\n  broadcastMouseLocation = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n  }) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"MOUSE_LOCATION\"] = {\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketId: this.socket.id,\n          pointer: payload.pointer,\n          button: payload.button || \"up\",\n          selectedElementIds: this.collab.excalidrawAPI.getAppState()\n            .selectedElementIds,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n}\n\nexport default Portal;\n","import React, { useRef } from \"react\";\nimport { copyTextToSystemClipboard } from \"../../clipboard\";\nimport { Dialog } from \"../../components/Dialog\";\nimport { clipboard, start, stop } from \"../../components/icons\";\nimport { ToolButton } from \"../../components/ToolButton\";\nimport { t } from \"../../i18n\";\nimport \"./RoomDialog.scss\";\n\nconst RoomDialog = ({\n  handleClose,\n  activeRoomLink,\n  username,\n  onUsernameChange,\n  onRoomCreate,\n  onRoomDestroy,\n  setErrorMessage,\n}: {\n  handleClose: () => void;\n  activeRoomLink: string;\n  username: string;\n  onUsernameChange: (username: string) => void;\n  onRoomCreate: () => void;\n  onRoomDestroy: () => void;\n  setErrorMessage: (message: string) => void;\n}) => {\n  const roomLinkInput = useRef<HTMLInputElement>(null);\n\n  const copyRoomLink = async () => {\n    try {\n      await copyTextToSystemClipboard(activeRoomLink);\n    } catch (error) {\n      setErrorMessage(error.message);\n    }\n    if (roomLinkInput.current) {\n      roomLinkInput.current.select();\n    }\n  };\n\n  const selectInput = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (event.target !== document.activeElement) {\n      event.preventDefault();\n      (event.target as HTMLInputElement).select();\n    }\n  };\n\n  const renderRoomDialog = () => {\n    return (\n      <div className=\"RoomDialog-modal\">\n        {!activeRoomLink && (\n          <>\n            <p>{t(\"roomDialog.desc_intro\")}</p>\n            <p>{` ${t(\"roomDialog.desc_privacy\")}`}</p>\n            <div className=\"RoomDialog-sessionStartButtonContainer\">\n              <ToolButton\n                className=\"RoomDialog-startSession\"\n                type=\"button\"\n                icon={start}\n                title={t(\"roomDialog.button_startSession\")}\n                aria-label={t(\"roomDialog.button_startSession\")}\n                showAriaLabel={true}\n                onClick={onRoomCreate}\n              />\n            </div>\n          </>\n        )}\n        {activeRoomLink && (\n          <>\n            <p>{t(\"roomDialog.desc_inProgressIntro\")}</p>\n            <p>{t(\"roomDialog.desc_shareLink\")}</p>\n            <div className=\"RoomDialog-linkContainer\">\n              <ToolButton\n                type=\"button\"\n                icon={clipboard}\n                title={t(\"labels.copy\")}\n                aria-label={t(\"labels.copy\")}\n                onClick={copyRoomLink}\n              />\n              <input\n                value={activeRoomLink}\n                readOnly={true}\n                className=\"RoomDialog-link\"\n                ref={roomLinkInput}\n                onPointerDown={selectInput}\n              />\n            </div>\n            <div className=\"RoomDialog-usernameContainer\">\n              <label className=\"RoomDialog-usernameLabel\" htmlFor=\"username\">\n                {t(\"labels.yourName\")}\n              </label>\n              <input\n                id=\"username\"\n                value={username || \"\"}\n                className=\"RoomDialog-username TextInput\"\n                onChange={(event) => onUsernameChange(event.target.value)}\n                onKeyPress={(event) => event.key === \"Enter\" && handleClose()}\n              />\n            </div>\n            <p>\n              <span role=\"img\" aria-hidden=\"true\" className=\"RoomDialog-emoji\">\n                {\"\"}\n              </span>{\" \"}\n              {t(\"roomDialog.desc_privacy\")}\n            </p>\n            <p>{t(\"roomDialog.desc_exitSession\")}</p>\n            <div className=\"RoomDialog-sessionStartButtonContainer\">\n              <ToolButton\n                className=\"RoomDialog-stopSession\"\n                type=\"button\"\n                icon={stop}\n                title={t(\"roomDialog.button_stopSession\")}\n                aria-label={t(\"roomDialog.button_stopSession\")}\n                showAriaLabel={true}\n                onClick={onRoomDestroy}\n              />\n            </div>\n          </>\n        )}\n      </div>\n    );\n  };\n  return (\n    <Dialog small onCloseRequest={handleClose} title={t(\"labels.createRoom\")}>\n      {renderRoomDialog()}\n    </Dialog>\n  );\n};\n\nexport default RoomDialog;\n","import React from \"react\";\n\nexport const createInverseContext = <T extends unknown = null>(\n  initialValue: T,\n) => {\n  const Context = React.createContext(initialValue) as React.Context<T> & {\n    _updateProviderValue?: (value: T) => void;\n  };\n\n  class InverseConsumer extends React.Component {\n    state = { value: initialValue };\n    constructor(props: any) {\n      super(props);\n      Context._updateProviderValue = (value: T) => this.setState({ value });\n    }\n    render() {\n      return (\n        <Context.Provider value={this.state.value}>\n          {this.props.children}\n        </Context.Provider>\n      );\n    }\n  }\n\n  class InverseProvider extends React.Component<{ value: T }> {\n    componentDidMount() {\n      Context._updateProviderValue?.(this.props.value);\n    }\n    componentDidUpdate() {\n      Context._updateProviderValue?.(this.props.value);\n    }\n    render() {\n      return <Context.Consumer>{() => this.props.children}</Context.Consumer>;\n    }\n  }\n\n  return {\n    Context,\n    Consumer: InverseConsumer,\n    Provider: InverseProvider,\n  };\n};\n","import throttle from \"lodash.throttle\";\nimport React, { PureComponent } from \"react\";\nimport { ExcalidrawImperativeAPI } from \"../../components/App\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport {\n  getElementMap,\n  getSceneVersion,\n  getSyncableElements,\n} from \"../../packages/excalidraw/index\";\nimport { Collaborator, Gesture } from \"../../types\";\nimport { resolvablePromise, withBatchedUpdates } from \"../../utils\";\nimport {\n  INITIAL_SCENE_UPDATE_TIMEOUT,\n  SCENE,\n  SYNC_FULL_SCENE_INTERVAL_MS,\n} from \"../app_constants\";\nimport {\n  decryptAESGEM,\n  generateCollaborationLinkData,\n  getCollaborationLink,\n  SocketUpdateDataSource,\n  SOCKET_SERVER,\n} from \"../data\";\nimport {\n  isSavedToFirebase,\n  loadFromFirebase,\n  saveToFirebase,\n} from \"../data/firebase\";\nimport {\n  importUsernameFromLocalStorage,\n  saveUsernameToLocalStorage,\n  STORAGE_KEYS,\n} from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\nimport { createInverseContext } from \"../../createInverseContext\";\nimport { t } from \"../../i18n\";\nimport { UserIdleState } from \"./types\";\nimport { IDLE_THRESHOLD, ACTIVE_THRESHOLD } from \"../../constants\";\n\ninterface CollabState {\n  modalIsShown: boolean;\n  errorMessage: string;\n  username: string;\n  userState: UserIdleState;\n  activeRoomLink: string;\n}\n\ntype CollabInstance = InstanceType<typeof CollabWrapper>;\n\nexport interface CollabAPI {\n  /** function so that we can access the latest value from stale callbacks */\n  isCollaborating: () => boolean;\n  username: CollabState[\"username\"];\n  userState: CollabState[\"userState\"];\n  onPointerUpdate: CollabInstance[\"onPointerUpdate\"];\n  initializeSocketClient: CollabInstance[\"initializeSocketClient\"];\n  onCollabButtonClick: CollabInstance[\"onCollabButtonClick\"];\n  broadcastElements: CollabInstance[\"broadcastElements\"];\n}\n\ntype ReconciledElements = readonly ExcalidrawElement[] & {\n  _brand: \"reconciledElements\";\n};\n\ninterface Props {\n  excalidrawAPI: ExcalidrawImperativeAPI;\n}\n\nconst {\n  Context: CollabContext,\n  Consumer: CollabContextConsumer,\n  Provider: CollabContextProvider,\n} = createInverseContext<{ api: CollabAPI | null }>({ api: null });\n\nexport { CollabContext, CollabContextConsumer };\n\nclass CollabWrapper extends PureComponent<Props, CollabState> {\n  portal: Portal;\n  excalidrawAPI: Props[\"excalidrawAPI\"];\n  isCollaborating: boolean = false;\n  activeIntervalId: number | null;\n  idleTimeoutId: number | null;\n\n  private socketInitializationTimer?: NodeJS.Timeout;\n  private lastBroadcastedOrReceivedSceneVersion: number = -1;\n  private collaborators = new Map<string, Collaborator>();\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      modalIsShown: false,\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      userState: UserIdleState.ACTIVE,\n      activeRoomLink: \"\",\n    };\n    this.portal = new Portal(this);\n    this.excalidrawAPI = props.excalidrawAPI;\n    this.activeIntervalId = null;\n    this.idleTimeoutId = null;\n  }\n\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      window.h = window.h || ({} as Window[\"h\"]);\n      Object.defineProperties(window.h, {\n        collab: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n    window.removeEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    window.removeEventListener(\n      EVENT.VISIBILITY_CHANGE,\n      this.onVisibilityChange,\n    );\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n  }\n\n  private onUnload = () => {\n    this.destroySocketClient({ isUnload: true });\n  };\n\n  private beforeUnload = withBatchedUpdates((event: BeforeUnloadEvent) => {\n    const syncableElements = getSyncableElements(\n      this.getSceneElementsIncludingDeleted(),\n    );\n\n    if (\n      this.isCollaborating &&\n      !isSavedToFirebase(this.portal, syncableElements)\n    ) {\n      // this won't run in time if user decides to leave the site, but\n      //  the purpose is to run in immediately after user decides to stay\n      this.saveCollabRoomToFirebase(syncableElements);\n\n      event.preventDefault();\n      // NOTE: modern browsers no longer allow showing a custom message here\n      event.returnValue = \"\";\n    }\n\n    if (this.isCollaborating || this.portal.roomId) {\n      try {\n        localStorage?.setItem(\n          STORAGE_KEYS.LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG,\n          JSON.stringify({\n            timestamp: Date.now(),\n            room: this.portal.roomId,\n          }),\n        );\n      } catch {}\n    }\n  });\n\n  saveCollabRoomToFirebase = async (\n    syncableElements: ExcalidrawElement[] = getSyncableElements(\n      this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n    ),\n  ) => {\n    try {\n      await saveToFirebase(this.portal, syncableElements);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  openPortal = async () => {\n    return this.initializeSocketClient(null);\n  };\n\n  closePortal = () => {\n    this.saveCollabRoomToFirebase();\n    if (window.confirm(t(\"alerts.collabStopOverridePrompt\"))) {\n      window.history.pushState({}, APP_NAME, window.location.origin);\n      this.destroySocketClient();\n    }\n  };\n\n  private destroySocketClient = (opts?: { isUnload: boolean }) => {\n    if (!opts?.isUnload) {\n      this.collaborators = new Map();\n      this.excalidrawAPI.updateScene({\n        collaborators: this.collaborators,\n      });\n      this.setState({\n        activeRoomLink: \"\",\n      });\n      this.isCollaborating = false;\n    }\n    this.portal.close();\n  };\n\n  private initializeSocketClient = async (\n    existingRoomLinkData: null | { roomId: string; roomKey: string },\n  ): Promise<ImportedDataState | null> => {\n    if (this.portal.socket) {\n      return null;\n    }\n\n    let roomId;\n    let roomKey;\n\n    if (existingRoomLinkData) {\n      ({ roomId, roomKey } = existingRoomLinkData);\n    } else {\n      ({ roomId, roomKey } = await generateCollaborationLinkData());\n      window.history.pushState(\n        {},\n        APP_NAME,\n        getCollaborationLink({ roomId, roomKey }),\n      );\n    }\n\n    const scenePromise = resolvablePromise<ImportedDataState | null>();\n\n    this.isCollaborating = true;\n\n    const { default: socketIOClient }: any = await import(\n      /* webpackChunkName: \"socketIoClient\" */ \"socket.io-client\"\n    );\n\n    this.portal.open(socketIOClient(SOCKET_SERVER), roomId, roomKey);\n\n    if (existingRoomLinkData) {\n      this.excalidrawAPI.resetScene();\n\n      try {\n        const elements = await loadFromFirebase(\n          roomId,\n          roomKey,\n          this.portal.socket,\n        );\n        if (elements) {\n          scenePromise.resolve({\n            elements,\n          });\n        }\n      } catch (error) {\n        // log the error and move on. other peers will sync us the scene.\n        console.error(error);\n      }\n    } else {\n      const elements = this.excalidrawAPI.getSceneElements();\n      // remove deleted elements from elements array & history to ensure we don't\n      // expose potentially sensitive user data in case user manually deletes\n      // existing elements (or clears scene), which would otherwise be persisted\n      // to database even if deleted before creating the room.\n      this.excalidrawAPI.history.clear();\n      this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: true,\n      });\n    }\n\n    // fallback in case you're not alone in the room but still don't receive\n    // initial SCENE_UPDATE message\n    this.socketInitializationTimer = setTimeout(() => {\n      this.initializeSocket();\n      scenePromise.resolve(null);\n    }, INITIAL_SCENE_UPDATE_TIMEOUT);\n\n    // All socket listeners are moving to Portal\n    this.portal.socket!.on(\n      \"client-broadcast\",\n      async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n        if (!this.portal.roomKey) {\n          return;\n        }\n        const decryptedData = await decryptAESGEM(\n          encryptedData,\n          this.portal.roomKey,\n          iv,\n        );\n\n        switch (decryptedData.type) {\n          case \"INVALID_RESPONSE\":\n            return;\n          case SCENE.INIT: {\n            if (!this.portal.socketInitialized) {\n              this.initializeSocket();\n              const remoteElements = decryptedData.payload.elements;\n              const reconciledElements = this.reconcileElements(remoteElements);\n              this.handleRemoteSceneUpdate(reconciledElements, {\n                init: true,\n              });\n              // noop if already resolved via init from firebase\n              scenePromise.resolve({ elements: reconciledElements });\n            }\n            break;\n          }\n          case SCENE.UPDATE:\n            this.handleRemoteSceneUpdate(\n              this.reconcileElements(decryptedData.payload.elements),\n            );\n            break;\n          case \"MOUSE_LOCATION\": {\n            const {\n              pointer,\n              button,\n              username,\n              selectedElementIds,\n            } = decryptedData.payload;\n            const socketId: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"socketId\"] =\n              decryptedData.payload.socketId ||\n              // @ts-ignore legacy, see #2094 (#2097)\n              decryptedData.payload.socketID;\n\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.pointer = pointer;\n            user.button = button;\n            user.selectedElementIds = selectedElementIds;\n            user.username = username;\n            collaborators.set(socketId, user);\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n          case \"IDLE_STATUS\": {\n            const { userState, socketId, username } = decryptedData.payload;\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.userState = userState;\n            user.username = username;\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n        }\n      },\n    );\n\n    this.portal.socket!.on(\"first-in-room\", () => {\n      if (this.portal.socket) {\n        this.portal.socket.off(\"first-in-room\");\n      }\n      this.initializeSocket();\n      scenePromise.resolve(null);\n    });\n\n    this.initializeIdleDetector();\n\n    this.setState({\n      activeRoomLink: window.location.href,\n    });\n\n    return scenePromise;\n  };\n\n  private initializeSocket = () => {\n    this.portal.socketInitialized = true;\n    clearTimeout(this.socketInitializationTimer!);\n  };\n\n  private reconcileElements = (\n    elements: readonly ExcalidrawElement[],\n  ): ReconciledElements => {\n    const currentElements = this.getSceneElementsIncludingDeleted();\n    // create a map of ids so we don't have to iterate\n    // over the array more than once.\n    const localElementMap = getElementMap(currentElements);\n\n    const appState = this.excalidrawAPI.getAppState();\n\n    // Reconcile\n    const newElements: readonly ExcalidrawElement[] = elements\n      .reduce((elements, element) => {\n        // if the remote element references one that's currently\n        // edited on local, skip it (it'll be added in the next step)\n        if (\n          element.id === appState.editingElement?.id ||\n          element.id === appState.resizingElement?.id ||\n          element.id === appState.draggingElement?.id\n        ) {\n          return elements;\n        }\n\n        if (\n          localElementMap.hasOwnProperty(element.id) &&\n          localElementMap[element.id].version > element.version\n        ) {\n          elements.push(localElementMap[element.id]);\n          delete localElementMap[element.id];\n        } else if (\n          localElementMap.hasOwnProperty(element.id) &&\n          localElementMap[element.id].version === element.version &&\n          localElementMap[element.id].versionNonce !== element.versionNonce\n        ) {\n          // resolve conflicting edits deterministically by taking the one with the lowest versionNonce\n          if (localElementMap[element.id].versionNonce < element.versionNonce) {\n            elements.push(localElementMap[element.id]);\n          } else {\n            // it should be highly unlikely that the two versionNonces are the same. if we are\n            // really worried about this, we can replace the versionNonce with the socket id.\n            elements.push(element);\n          }\n          delete localElementMap[element.id];\n        } else {\n          elements.push(element);\n          delete localElementMap[element.id];\n        }\n\n        return elements;\n      }, [] as Mutable<typeof elements>)\n      // add local elements that weren't deleted or on remote\n      .concat(...Object.values(localElementMap));\n\n    // Avoid broadcasting to the rest of the collaborators the scene\n    // we just received!\n    // Note: this needs to be set before updating the scene as it\n    // synchronously calls render.\n    this.setLastBroadcastedOrReceivedSceneVersion(getSceneVersion(newElements));\n\n    return newElements as ReconciledElements;\n  };\n\n  private handleRemoteSceneUpdate = (\n    elements: ReconciledElements,\n    {\n      init = false,\n      initFromSnapshot = false,\n    }: { init?: boolean; initFromSnapshot?: boolean } = {},\n  ) => {\n    if (init || initFromSnapshot) {\n      this.excalidrawAPI.setScrollToCenter(elements);\n    }\n\n    this.excalidrawAPI.updateScene({\n      elements,\n      commitToHistory: !!init,\n    });\n\n    // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n    // when we receive any messages from another peer. This UX can be pretty rough -- if you\n    // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n    // right now we think this is the right tradeoff.\n    this.excalidrawAPI.history.clear();\n  };\n\n  private onPointerMove = () => {\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n    this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n    if (!this.activeIntervalId) {\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n    }\n  };\n\n  private onVisibilityChange = () => {\n    if (document.hidden) {\n      if (this.idleTimeoutId) {\n        window.clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = null;\n      }\n      if (this.activeIntervalId) {\n        window.clearInterval(this.activeIntervalId);\n        this.activeIntervalId = null;\n      }\n      this.onIdleStateChange(UserIdleState.AWAY);\n    } else {\n      this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n      this.onIdleStateChange(UserIdleState.ACTIVE);\n    }\n  };\n\n  private reportIdle = () => {\n    this.onIdleStateChange(UserIdleState.IDLE);\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n  };\n\n  private reportActive = () => {\n    this.onIdleStateChange(UserIdleState.ACTIVE);\n  };\n\n  private initializeIdleDetector = () => {\n    document.addEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    document.addEventListener(EVENT.VISIBILITY_CHANGE, this.onVisibilityChange);\n  };\n\n  setCollaborators(sockets: string[]) {\n    this.setState((state) => {\n      const collaborators: InstanceType<\n        typeof CollabWrapper\n      >[\"collaborators\"] = new Map();\n      for (const socketId of sockets) {\n        if (this.collaborators.has(socketId)) {\n          collaborators.set(socketId, this.collaborators.get(socketId)!);\n        } else {\n          collaborators.set(socketId, {});\n        }\n      }\n      this.collaborators = collaborators;\n      this.excalidrawAPI.updateScene({ collaborators });\n    });\n  }\n\n  public setLastBroadcastedOrReceivedSceneVersion = (version: number) => {\n    this.lastBroadcastedOrReceivedSceneVersion = version;\n  };\n\n  public getLastBroadcastedOrReceivedSceneVersion = () => {\n    return this.lastBroadcastedOrReceivedSceneVersion;\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.excalidrawAPI.getSceneElementsIncludingDeleted();\n  };\n\n  onPointerUpdate = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n    pointersMap: Gesture[\"pointers\"];\n  }) => {\n    payload.pointersMap.size < 2 &&\n      this.portal.socket &&\n      this.portal.broadcastMouseLocation(payload);\n  };\n\n  onIdleStateChange = (userState: UserIdleState) => {\n    this.setState({ userState });\n    this.portal.broadcastIdleChange(userState);\n  };\n\n  broadcastElements = (elements: readonly ExcalidrawElement[]) => {\n    if (\n      getSceneVersion(elements) >\n      this.getLastBroadcastedOrReceivedSceneVersion()\n    ) {\n      this.portal.broadcastScene(\n        SCENE.UPDATE,\n        getSyncableElements(elements),\n        false,\n      );\n      this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n      this.queueBroadcastAllElements();\n    }\n  };\n\n  queueBroadcastAllElements = throttle(() => {\n    this.portal.broadcastScene(\n      SCENE.UPDATE,\n      getSyncableElements(\n        this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      ),\n      true,\n    );\n    const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n    const newVersion = Math.max(\n      currentVersion,\n      getSceneVersion(this.getSceneElementsIncludingDeleted()),\n    );\n    this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n  }, SYNC_FULL_SCENE_INTERVAL_MS);\n\n  handleClose = () => {\n    this.setState({ modalIsShown: false });\n    const collabIcon = document.querySelector(\".CollabButton\") as HTMLElement;\n    collabIcon.focus();\n  };\n\n  onUsernameChange = (username: string) => {\n    this.setState({ username });\n    saveUsernameToLocalStorage(username);\n  };\n\n  onCollabButtonClick = () => {\n    this.setState({\n      modalIsShown: true,\n    });\n  };\n\n  /** PRIVATE. Use `this.getContextValue()` instead. */\n  private contextValue: CollabAPI | null = null;\n\n  /** Getter of context value. Returned object is stable. */\n  getContextValue = (): CollabAPI => {\n    if (!this.contextValue) {\n      this.contextValue = {} as CollabAPI;\n    }\n\n    this.contextValue.isCollaborating = () => this.isCollaborating;\n    this.contextValue.username = this.state.username;\n    this.contextValue.onPointerUpdate = this.onPointerUpdate;\n    this.contextValue.initializeSocketClient = this.initializeSocketClient;\n    this.contextValue.onCollabButtonClick = this.onCollabButtonClick;\n    this.contextValue.broadcastElements = this.broadcastElements;\n    return this.contextValue;\n  };\n\n  render() {\n    const { modalIsShown, username, errorMessage, activeRoomLink } = this.state;\n\n    return (\n      <>\n        {modalIsShown && (\n          <RoomDialog\n            handleClose={this.handleClose}\n            activeRoomLink={activeRoomLink}\n            username={username}\n            onUsernameChange={this.onUsernameChange}\n            onRoomCreate={this.openPortal}\n            onRoomDestroy={this.closePortal}\n            setErrorMessage={(errorMessage) => {\n              this.setState({ errorMessage });\n            }}\n          />\n        )}\n        {errorMessage && (\n          <ErrorDialog\n            message={errorMessage}\n            onClose={() => this.setState({ errorMessage: \"\" })}\n          />\n        )}\n        <CollabContextProvider\n          value={{\n            api: this.getContextValue(),\n          }}\n        />\n      </>\n    );\n  }\n}\n\nexport default CollabWrapper;\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport * as i18n from \"../../i18n\";\n\nexport const LanguageList = ({\n  onChange,\n  languages = i18n.languages,\n  currentLangCode = i18n.getLanguage().code,\n  floating,\n}: {\n  languages?: { code: string; label: string }[];\n  onChange: (langCode: i18n.Language[\"code\"]) => void;\n  currentLangCode?: i18n.Language[\"code\"];\n  floating?: boolean;\n}) => (\n  <React.Fragment>\n    <select\n      className={clsx(\"dropdown-select dropdown-select__language\", {\n        \"dropdown-select--floating\": floating,\n      })}\n      onChange={({ target }) => onChange(target.value)}\n      value={currentLangCode}\n      aria-label={i18n.t(\"buttons.selectLanguage\")}\n    >\n      <option key={i18n.defaultLang.code} value={i18n.defaultLang.code}>\n        {i18n.defaultLang.label}\n      </option>\n      {languages.map((lang) => (\n        <option key={lang.code} value={lang.code}>\n          {lang.label}\n        </option>\n      ))}\n    </select>\n  </React.Fragment>\n);\n","import LanguageDetector from \"i18next-browser-languagedetector\";\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport { ExcalidrawImperativeAPI } from \"../components/App\";\nimport { ErrorDialog } from \"../components/ErrorDialog\";\nimport { TopErrorBoundary } from \"../components/TopErrorBoundary\";\nimport { APP_NAME, EVENT, TITLE_TIMEOUT, VERSION_TIMEOUT } from \"../constants\";\nimport { ImportedDataState } from \"../data/types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { Language, t } from \"../i18n\";\nimport Excalidraw, {\n  defaultLang,\n  languages,\n} from \"../packages/excalidraw/index\";\nimport { AppState } from \"../types\";\nimport {\n  debounce,\n  getVersion,\n  ResolvablePromise,\n  resolvablePromise,\n} from \"../utils\";\nimport { SAVE_TO_LOCAL_STORAGE_TIMEOUT } from \"./app_constants\";\nimport CollabWrapper, {\n  CollabAPI,\n  CollabContext,\n  CollabContextConsumer,\n} from \"./collab/CollabWrapper\";\nimport { LanguageList } from \"./components/LanguageList\";\nimport { exportToBackend, getCollaborationLinkData, loadScene } from \"./data\";\nimport {\n  importFromLocalStorage,\n  saveToLocalStorage,\n} from \"./data/localStorage\";\n\nconst languageDetector = new LanguageDetector();\nlanguageDetector.init({\n  languageUtils: {\n    formatLanguageCode: (langCode: Language[\"code\"]) => langCode,\n    isWhitelisted: () => true,\n  },\n  checkWhitelist: false,\n});\n\nconst saveDebounced = debounce(\n  (elements: readonly ExcalidrawElement[], state: AppState) => {\n    saveToLocalStorage(elements, state);\n  },\n  SAVE_TO_LOCAL_STORAGE_TIMEOUT,\n);\n\nconst onBlur = () => {\n  saveDebounced.flush();\n};\n\nconst initializeScene = async (opts: {\n  collabAPI: CollabAPI;\n}): Promise<ImportedDataState | null> => {\n  const searchParams = new URLSearchParams(window.location.search);\n  const id = searchParams.get(\"id\");\n  const jsonMatch = window.location.hash.match(\n    /^#json=([0-9]+),([a-zA-Z0-9_-]+)$/,\n  );\n\n  const initialData = importFromLocalStorage();\n\n  let scene = await loadScene(null, null, initialData);\n\n  let roomLinkData = getCollaborationLinkData(window.location.href);\n  const isExternalScene = !!(id || jsonMatch || roomLinkData);\n  if (isExternalScene) {\n    if (\n      // don't prompt if scene is empty\n      !scene.elements.length ||\n      // don't prompt for collab scenes because we don't override local storage\n      roomLinkData ||\n      // otherwise, prompt whether user wants to override current scene\n      window.confirm(t(\"alerts.loadSceneOverridePrompt\"))\n    ) {\n      // Backwards compatibility with legacy url format\n      if (id) {\n        scene = await loadScene(id, null, initialData);\n      } else if (jsonMatch) {\n        scene = await loadScene(jsonMatch[1], jsonMatch[2], initialData);\n      }\n      if (!roomLinkData) {\n        window.history.replaceState({}, APP_NAME, window.location.origin);\n      }\n    } else {\n      // https://github.com/excalidraw/excalidraw/issues/1919\n      if (document.hidden) {\n        return new Promise((resolve, reject) => {\n          window.addEventListener(\n            \"focus\",\n            () => initializeScene(opts).then(resolve).catch(reject),\n            {\n              once: true,\n            },\n          );\n        });\n      }\n\n      roomLinkData = null;\n      window.history.replaceState({}, APP_NAME, window.location.origin);\n    }\n  }\n  if (roomLinkData) {\n    return opts.collabAPI.initializeSocketClient(roomLinkData);\n  } else if (scene) {\n    return scene;\n  }\n  return null;\n};\n\nfunction ExcalidrawWrapper() {\n  // dimensions\n  // ---------------------------------------------------------------------------\n\n  const [dimensions, setDimensions] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  const currentLangCode = languageDetector.detect() || defaultLang.code;\n  const [langCode, setLangCode] = useState(currentLangCode);\n\n  useLayoutEffect(() => {\n    const onResize = () => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    window.addEventListener(\"resize\", onResize);\n\n    return () => window.removeEventListener(\"resize\", onResize);\n  }, []);\n\n  // initial state\n  // ---------------------------------------------------------------------------\n\n  const initialStatePromiseRef = useRef<{\n    promise: ResolvablePromise<ImportedDataState | null>;\n  }>({ promise: null! });\n  if (!initialStatePromiseRef.current.promise) {\n    initialStatePromiseRef.current.promise = resolvablePromise<ImportedDataState | null>();\n  }\n\n  useEffect(() => {\n    // Delayed so that the app has a time to load the latest SW\n    setTimeout(() => {\n      trackEvent(\"load\", \"version\", getVersion());\n    }, VERSION_TIMEOUT);\n  }, []);\n\n  const [\n    excalidrawAPI,\n    excalidrawRefCallback,\n  ] = useCallbackRefState<ExcalidrawImperativeAPI>();\n\n  const collabAPI = useContext(CollabContext)?.api;\n\n  useEffect(() => {\n    if (!collabAPI || !excalidrawAPI) {\n      return;\n    }\n\n    initializeScene({ collabAPI }).then((scene) => {\n      initialStatePromiseRef.current.promise.resolve(scene);\n    });\n\n    const onHashChange = (_: HashChangeEvent) => {\n      initializeScene({ collabAPI }).then((scene) => {\n        if (scene) {\n          excalidrawAPI.updateScene(scene);\n        }\n      });\n    };\n\n    const titleTimeout = setTimeout(\n      () => (document.title = APP_NAME),\n      TITLE_TIMEOUT,\n    );\n    window.addEventListener(EVENT.HASHCHANGE, onHashChange, false);\n    window.addEventListener(EVENT.UNLOAD, onBlur, false);\n    window.addEventListener(EVENT.BLUR, onBlur, false);\n    return () => {\n      window.removeEventListener(EVENT.HASHCHANGE, onHashChange, false);\n      window.removeEventListener(EVENT.UNLOAD, onBlur, false);\n      window.removeEventListener(EVENT.BLUR, onBlur, false);\n      clearTimeout(titleTimeout);\n    };\n  }, [collabAPI, excalidrawAPI]);\n\n  useEffect(() => {\n    languageDetector.cacheUserLanguage(langCode);\n  }, [langCode]);\n\n  const onChange = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n  ) => {\n    if (collabAPI?.isCollaborating()) {\n      collabAPI.broadcastElements(elements);\n    } else {\n      // collab scenes are persisted to the server, so we don't have to persist\n      // them locally, which has the added benefit of not overwriting whatever\n      // the user was working on before joining\n      saveDebounced(elements, appState);\n    }\n  };\n\n  const onExportToBackend = async (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => {\n    if (exportedElements.length === 0) {\n      return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n    }\n    if (canvas) {\n      try {\n        await exportToBackend(exportedElements, {\n          ...appState,\n          viewBackgroundColor: appState.exportBackground\n            ? appState.viewBackgroundColor\n            : getDefaultAppState().viewBackgroundColor,\n        });\n      } catch (error) {\n        if (error.name !== \"AbortError\") {\n          const { width, height } = canvas;\n          console.error(error, { width, height });\n          setErrorMessage(error.message);\n        }\n      }\n    }\n  };\n\n  const renderFooter = useCallback(\n    (isMobile: boolean) => {\n      const renderLanguageList = () => (\n        <LanguageList\n          onChange={(langCode) => {\n            setLangCode(langCode);\n          }}\n          languages={languages}\n          floating={!isMobile}\n          currentLangCode={langCode}\n        />\n      );\n      if (isMobile) {\n        return (\n          <fieldset>\n            <legend>{t(\"labels.language\")}</legend>\n            {renderLanguageList()}\n          </fieldset>\n        );\n      }\n      return renderLanguageList();\n    },\n    [langCode],\n  );\n\n  return (\n    <>\n      <Excalidraw\n        ref={excalidrawRefCallback}\n        onChange={onChange}\n        width={dimensions.width}\n        height={dimensions.height}\n        initialData={initialStatePromiseRef.current.promise}\n        onCollabButtonClick={collabAPI?.onCollabButtonClick}\n        isCollaborating={collabAPI?.isCollaborating()}\n        onPointerUpdate={collabAPI?.onPointerUpdate}\n        onExportToBackend={onExportToBackend}\n        renderFooter={renderFooter}\n        langCode={langCode}\n      />\n      {excalidrawAPI && <CollabWrapper excalidrawAPI={excalidrawAPI} />}\n      {errorMessage && (\n        <ErrorDialog\n          message={errorMessage}\n          onClose={() => setErrorMessage(\"\")}\n        />\n      )}\n    </>\n  );\n}\n\nexport default function ExcalidrawApp() {\n  return (\n    <TopErrorBoundary>\n      <CollabContextConsumer>\n        <ExcalidrawWrapper />\n      </CollabContextConsumer>\n    </TopErrorBoundary>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport const register = (config?: Config) => {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.info(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n};\n\nconst registerValidSW = (swUrl: string, config?: Config) => {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n\n              console.info(\n                \"New content is available and will be used when all tabs for this page are closed.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n\n              console.info(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n};\n\nconst checkValidServiceWorker = (swUrl: string, config?: Config) => {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch((error) => {\n      console.info(\n        \"No internet connection found. App is running in offline mode.\",\n        error.message,\n      );\n    });\n};\n\nexport const unregister = () => {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n};\n","import { register as registerServiceWorker } from \"../serviceWorker\";\nimport { EVENT } from \"../constants\";\n\n// On Apple mobile devices add the proprietary app icon and splashscreen markup.\n// No one should have to do this manually, and eventually this annoyance will\n// go away once https://bugs.webkit.org/show_bug.cgi?id=183937 is fixed.\nif (\n  /\\b(iPad|iPhone|iPod|Safari)\\b/.test(navigator.userAgent) &&\n  !matchMedia(\"(display-mode: standalone)\").matches\n) {\n  import(/* webpackChunkName: \"pwacompat\" */ \"pwacompat\");\n}\n\nregisterServiceWorker({\n  onUpdate: (registration) => {\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\n        EVENT.STATE_CHANGE,\n        (event: Event) => {\n          const target = event.target as ServiceWorker;\n          const state = target.state as ServiceWorkerState;\n          if (state === \"activated\") {\n            window.location.reload();\n          }\n        },\n      );\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  },\n});\n","import * as Sentry from \"@sentry/browser\";\nimport * as SentryIntegrations from \"@sentry/integrations\";\n\nconst SentryEnvHostnameMap: { [key: string]: string } = {\n  \"excalidraw.com\": \"production\",\n  \"vercel.app\": \"staging\",\n};\n\nconst REACT_APP_DISABLE_SENTRY =\n  process.env.REACT_APP_DISABLE_SENTRY === \"true\";\n\n// Disable Sentry locally or inside the Docker to avoid noise/respect privacy\nconst onlineEnv =\n  !REACT_APP_DISABLE_SENTRY &&\n  Object.keys(SentryEnvHostnameMap).find(\n    (item) => window.location.hostname.indexOf(item) >= 0,\n  );\n\nSentry.init({\n  dsn: onlineEnv\n    ? \"https://7bfc596a5bf945eda6b660d3015a5460@sentry.io/5179260\"\n    : undefined,\n  environment: onlineEnv ? SentryEnvHostnameMap[onlineEnv] : undefined,\n  release: process.env.REACT_APP_GIT_SHA,\n  ignoreErrors: [\n    \"undefined is not an object (evaluating 'window.__pad.performLoop')\", // Only happens on Safari, but spams our servers. Doesn't break anything\n  ],\n  integrations: [\n    new SentryIntegrations.CaptureConsole({\n      levels: [\"error\"],\n    }),\n  ],\n  beforeSend(event) {\n    if (event.request?.url) {\n      event.request.url = event.request.url.replace(/#.*$/, \"\");\n    }\n    return event;\n  },\n});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport ExcalidrawApp from \"./excalidraw-app\";\n\nimport \"./excalidraw-app/pwa\";\nimport \"./excalidraw-app/sentry\";\n\nwindow.__EXCALIDRAW_SHA__ = process.env.REACT_APP_GIT_SHA;\n\nReactDOM.render(<ExcalidrawApp />, document.getElementById(\"root\"));\n"],"sourceRoot":""}